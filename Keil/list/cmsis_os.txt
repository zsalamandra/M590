; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -ogsm_stm32f103\cmsis_os.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\cmsis_os.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS -IE:\MC\2.STM32\STMProjects\GSM\GSM_M590\Project\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.c]
                          THUMB

                          AREA ||i.inHandlerMode||, CODE, READONLY, ALIGN=1

                  inHandlerMode PROC
;;;172    /* Determine whether we are in thread mode or handler mode. */
;;;173    static int inHandlerMode (void)
000000  f3ef8005          MRS      r0,IPSR
;;;174    {
;;;175      return __get_IPSR() != 0;
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L1.12|
000008  2001              MOVS     r0,#1
;;;176    }
00000a  4770              BX       lr
                  |L1.12|
00000c  2000              MOVS     r0,#0                 ;175
00000e  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.makeCmsisPriority||, CODE, READONLY, ALIGN=1

                  makeCmsisPriority PROC
;;;158    /* Convert from FreeRTOS priority number to CMSIS type osPriority */
;;;159    static osPriority makeCmsisPriority (unsigned portBASE_TYPE fpriority)
000000  4601              MOV      r1,r0
;;;160    {
;;;161      osPriority priority = osPriorityError;
000002  2084              MOVS     r0,#0x84
;;;162      
;;;163      if ((fpriority - tskIDLE_PRIORITY) <= (osPriorityRealtime - osPriorityIdle)) {
000004  2906              CMP      r1,#6
000006  d801              BHI      |L2.12|
;;;164        priority = (osPriority)((int)osPriorityIdle + (int)(fpriority - tskIDLE_PRIORITY));
000008  1ec9              SUBS     r1,r1,#3
00000a  b208              SXTH     r0,r1
                  |L2.12|
;;;165      }
;;;166      
;;;167      return priority;
;;;168    }
00000c  4770              BX       lr
;;;169    #endif
                          ENDP


                          AREA ||i.makeFreeRtosPriority||, CODE, READONLY, ALIGN=1

                  makeFreeRtosPriority PROC
;;;145    /* Convert from CMSIS type osPriority to FreeRTOS priority number */
;;;146    static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
000000  4601              MOV      r1,r0
;;;147    {
;;;148      unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
000002  2000              MOVS     r0,#0
;;;149      
;;;150      if (priority != osPriorityError) {
000004  2984              CMP      r1,#0x84
000006  d000              BEQ      |L3.10|
;;;151        fpriority += (priority - osPriorityIdle);
000008  1cc8              ADDS     r0,r1,#3
                  |L3.10|
;;;152      }
;;;153      
;;;154      return fpriority;
;;;155    }
00000a  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.osAbortDelay||, CODE, READONLY, ALIGN=1

                  osAbortDelay PROC
;;;1565   */
;;;1566   osStatus osAbortDelay(osThreadId thread_id)
000000  2081              MOVS     r0,#0x81
;;;1567   {
;;;1568   #if INCLUDE_xTaskAbortDelay
;;;1569     
;;;1570     xTaskAbortDelay(thread_id);
;;;1571     
;;;1572     return osOK;
;;;1573   #else
;;;1574     (void) thread_id;
;;;1575     
;;;1576     return osErrorResource;
;;;1577   #endif
;;;1578   }
000002  4770              BX       lr
;;;1579   
                          ENDP


                          AREA ||i.osDelay||, CODE, READONLY, ALIGN=1

                  osDelay PROC
;;;364    */
;;;365    osStatus osDelay (uint32_t millisec)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367    #if INCLUDE_vTaskDelay
;;;368      TickType_t ticks = millisec / portTICK_PERIOD_MS;
;;;369      
;;;370      vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
000002  2800              CMP      r0,#0
000004  d100              BNE      |L5.8|
000006  2001              MOVS     r0,#1
                  |L5.8|
000008  f7fffffe          BL       vTaskDelay
;;;371      
;;;372      return osOK;
00000c  2000              MOVS     r0,#0
;;;373    #else
;;;374      (void) millisec;
;;;375      
;;;376      return osErrorResource;
;;;377    #endif
;;;378    }
00000e  bd10              POP      {r4,pc}
;;;379    
                          ENDP


                          AREA ||i.osDelayUntil||, CODE, READONLY, ALIGN=1

                  osDelayUntil PROC
;;;1545   */
;;;1546   osStatus osDelayUntil (uint32_t *PreviousWakeTime, uint32_t millisec)
000000  2081              MOVS     r0,#0x81
;;;1547   {
;;;1548   #if INCLUDE_vTaskDelayUntil
;;;1549     TickType_t ticks = (millisec / portTICK_PERIOD_MS);
;;;1550     vTaskDelayUntil((TickType_t *) PreviousWakeTime, ticks ? ticks : 1);
;;;1551     
;;;1552     return osOK;
;;;1553   #else
;;;1554     (void) millisec;
;;;1555     (void) PreviousWakeTime;
;;;1556     
;;;1557     return osErrorResource;
;;;1558   #endif
;;;1559   }
000002  4770              BX       lr
;;;1560   
                          ENDP


                          AREA ||i.osKernelRunning||, CODE, READONLY, ALIGN=1

                  osKernelRunning PROC
;;;207    */
;;;208    int32_t osKernelRunning(void)
000000  b510              PUSH     {r4,lr}
;;;209    {
;;;210    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;211      if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L7.14|
;;;212        return 0;
;;;213      else
;;;214        return 1;
00000a  2001              MOVS     r0,#1
;;;215    #else
;;;216    	return (-1);
;;;217    #endif	
;;;218    }
00000c  bd10              POP      {r4,pc}
                  |L7.14|
00000e  2000              MOVS     r0,#0                 ;212
000010  bd10              POP      {r4,pc}
;;;219    
                          ENDP


                          AREA ||i.osKernelStart||, CODE, READONLY, ALIGN=1

                  osKernelStart PROC
;;;192    */
;;;193    osStatus osKernelStart (void)
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195      vTaskStartScheduler();
000002  f7fffffe          BL       vTaskStartScheduler
;;;196      
;;;197      return osOK;
000006  2000              MOVS     r0,#0
;;;198    }
000008  bd10              POP      {r4,pc}
;;;199    
                          ENDP


                          AREA ||i.osKernelSysTick||, CODE, READONLY, ALIGN=1

                  osKernelSysTick PROC
;;;226    */
;;;227    uint32_t osKernelSysTick(void)
000000  b510              PUSH     {r4,lr}
;;;228    {
;;;229      if (inHandlerMode()) {
000002  f7fffffe          BL       inHandlerMode
000006  b118              CBZ      r0,|L9.16|
;;;230        return xTaskGetTickCountFromISR();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      xTaskGetTickCountFromISR
                  |L9.16|
;;;231      }
;;;232      else {
;;;233        return xTaskGetTickCount();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      xTaskGetTickCount
;;;234      }
;;;235    }
;;;236    #endif    // System Timer available
                          ENDP


                          AREA ||i.osMailAlloc||, CODE, READONLY, ALIGN=1

                  osMailAlloc PROC
;;;1259   */
;;;1260   void *osMailAlloc (osMailQId queue_id, uint32_t millisec)
000000  2800              CMP      r0,#0
;;;1261   {
000002  d002              BEQ      |L10.10|
;;;1262     (void) millisec;
;;;1263     void *p;
;;;1264     
;;;1265     
;;;1266     if (queue_id == NULL) {
;;;1267       return NULL;
;;;1268     }
;;;1269     
;;;1270     p = osPoolAlloc(queue_id->pool);
000004  6880              LDR      r0,[r0,#8]
000006  f7ffbffe          B.W      osPoolAlloc
                  |L10.10|
00000a  2000              MOVS     r0,#0                 ;1267
;;;1271     
;;;1272     return p;
;;;1273   }
00000c  4770              BX       lr
;;;1274   
                          ENDP


                          AREA ||i.osMailCAlloc||, CODE, READONLY, ALIGN=1

                  osMailCAlloc PROC
;;;1281   */
;;;1282   void *osMailCAlloc (osMailQId queue_id, uint32_t millisec)
000000  b510              PUSH     {r4,lr}
;;;1283   {
000002  4604              MOV      r4,r0
;;;1284     uint32_t i;
;;;1285     void *p = osMailAlloc(queue_id, millisec);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       osMailAlloc
;;;1286     
;;;1287     if (p) {
00000a  2800              CMP      r0,#0
00000c  d008              BEQ      |L11.32|
;;;1288       for (i = 0; i < queue_id->queue_def->item_sz; i++) {
00000e  2100              MOVS     r1,#0
000010  2200              MOVS     r2,#0
000012  e001              B        |L11.24|
                  |L11.20|
;;;1289         ((uint8_t *)p)[i] = 0;
000014  5442              STRB     r2,[r0,r1]
000016  1c49              ADDS     r1,r1,#1              ;1288
                  |L11.24|
000018  6823              LDR      r3,[r4,#0]            ;1288
00001a  685b              LDR      r3,[r3,#4]            ;1288
00001c  428b              CMP      r3,r1                 ;1288
00001e  d8f9              BHI      |L11.20|
                  |L11.32|
;;;1290       }
;;;1291     }
;;;1292     
;;;1293     return p;
;;;1294   }
000020  bd10              POP      {r4,pc}
;;;1295   
                          ENDP


                          AREA ||i.osMailCreate||, CODE, READONLY, ALIGN=1

                  osMailCreate PROC
;;;1213   */
;;;1214   osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id)
000000  b53e              PUSH     {r1-r5,lr}
;;;1215   {
000002  4604              MOV      r4,r0
;;;1216   #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1217     (void) thread_id;
;;;1218     
;;;1219     osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  6820              LDR      r0,[r4,#0]
00000e  9000              STR      r0,[sp,#0]
000010  6860              LDR      r0,[r4,#4]
000012  9001              STR      r0,[sp,#4]
;;;1220     
;;;1221     /* Create a mail queue control block */
;;;1222   
;;;1223     *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
000014  200c              MOVS     r0,#0xc
000016  f7fffffe          BL       pvPortMalloc
00001a  68a1              LDR      r1,[r4,#8]
00001c  6008              STR      r0,[r1,#0]
;;;1224   
;;;1225     if (*(queue_def->cb) == NULL) {
00001e  b1d0              CBZ      r0,|L12.86|
;;;1226       return NULL;
;;;1227     }
;;;1228     (*(queue_def->cb))->queue_def = queue_def;
000020  6004              STR      r4,[r0,#0]
;;;1229     
;;;1230     /* Create a queue in FreeRTOS */
;;;1231     (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
000022  2200              MOVS     r2,#0
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       xQueueGenericCreate
00002c  68a1              LDR      r1,[r4,#8]
00002e  6809              LDR      r1,[r1,#0]
000030  6048              STR      r0,[r1,#4]
;;;1232   
;;;1233   
;;;1234     if ((*(queue_def->cb))->handle == NULL) {
000032  68a1              LDR      r1,[r4,#8]
000034  6809              LDR      r1,[r1,#0]
000036  b180              CBZ      r0,|L12.90|
;;;1235       vPortFree(*(queue_def->cb));
;;;1236       return NULL;
;;;1237     }
;;;1238     
;;;1239     /* Create a mail pool */
;;;1240     (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       osPoolCreate
00003e  4601              MOV      r1,r0
000040  68a0              LDR      r0,[r4,#8]
000042  6800              LDR      r0,[r0,#0]
000044  6081              STR      r1,[r0,#8]
;;;1241     if ((*(queue_def->cb))->pool == NULL) {
000046  68a0              LDR      r0,[r4,#8]
000048  2900              CMP      r1,#0
00004a  6800              LDR      r0,[r0,#0]
00004c  d102              BNE      |L12.84|
;;;1242       //TODO: Delete queue. How to do it in FreeRTOS?
;;;1243       vPortFree(*(queue_def->cb));
00004e  f7fffffe          BL       vPortFree
;;;1244       return NULL;
000052  2000              MOVS     r0,#0
                  |L12.84|
;;;1245     }
;;;1246     
;;;1247     return *(queue_def->cb);
;;;1248   #else
;;;1249     return NULL;
;;;1250   #endif
;;;1251   }
000054  bd3e              POP      {r1-r5,pc}
                  |L12.86|
000056  2000              MOVS     r0,#0                 ;1226
000058  bd3e              POP      {r1-r5,pc}
                  |L12.90|
00005a  4608              MOV      r0,r1                 ;1235
00005c  f7fffffe          BL       vPortFree
000060  2000              MOVS     r0,#0                 ;1236
000062  bd3e              POP      {r1-r5,pc}
;;;1252   
                          ENDP


                          AREA ||i.osMailFree||, CODE, READONLY, ALIGN=1

                  osMailFree PROC
;;;1391   */
;;;1392   osStatus osMailFree (osMailQId queue_id, void *mail)
000000  2800              CMP      r0,#0
;;;1393   {
000002  d002              BEQ      |L13.10|
;;;1394     if (queue_id == NULL) {
;;;1395       return osErrorParameter;
;;;1396     }
;;;1397     
;;;1398     return osPoolFree(queue_id->pool, mail);
000004  6880              LDR      r0,[r0,#8]
000006  f7ffbffe          B.W      osPoolFree
                  |L13.10|
00000a  2080              MOVS     r0,#0x80              ;1395
;;;1399   }
00000c  4770              BX       lr
;;;1400   #endif  /* Use Mail Queues */
                          ENDP


                          AREA ||i.osMailGet||, CODE, READONLY, ALIGN=2

                  osMailGet PROC
;;;1335   */
;;;1336   osEvent osMailGet (osMailQId queue_id, uint32_t millisec)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1337   {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;1338     portBASE_TYPE taskWoken;
;;;1339     TickType_t ticks;
;;;1340     osEvent event;
;;;1341     
;;;1342     event.def.mail_id = queue_id;
000008  9502              STR      r5,[sp,#8]
;;;1343     
;;;1344     if (queue_id == NULL) {
00000a  2d00              CMP      r5,#0
00000c  d021              BEQ      |L14.82|
;;;1345       event.status = osErrorParameter;
;;;1346       return event;
;;;1347     }
;;;1348     
;;;1349     taskWoken = pdFALSE;
00000e  f04f0800          MOV      r8,#0
000012  f8cd800c          STR      r8,[sp,#0xc]
;;;1350     
;;;1351     ticks = 0;
000016  2400              MOVS     r4,#0
;;;1352     if (millisec == osWaitForever) {
000018  1c50              ADDS     r0,r2,#1
00001a  d021              BEQ      |L14.96|
;;;1353       ticks = portMAX_DELAY;
;;;1354     }
;;;1355     else if (millisec != 0) {
00001c  b102              CBZ      r2,|L14.32|
;;;1356       ticks = millisec / portTICK_PERIOD_MS;
00001e  4614              MOV      r4,r2
                  |L14.32|
;;;1357       if (ticks == 0) {
;;;1358         ticks = 1;
;;;1359       }
;;;1360     }
;;;1361     
;;;1362     if (inHandlerMode()) {
000020  f7fffffe          BL       inHandlerMode
000024  4669              MOV      r1,sp                 ;1340
;;;1363       if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {
;;;1364         /* We have mail */
;;;1365         event.status = osEventMail;
000026  2720              MOVS     r7,#0x20
000028  b1f8              CBZ      r0,|L14.106|
00002a  aa03              ADD      r2,sp,#0xc            ;1363
00002c  1d09              ADDS     r1,r1,#4              ;1363
00002e  6868              LDR      r0,[r5,#4]            ;1363
000030  f7fffffe          BL       xQueueReceiveFromISR
000034  2801              CMP      r0,#1                 ;1363
000036  d016              BEQ      |L14.102|
;;;1366       }
;;;1367       else {
;;;1368         event.status = osOK;
000038  f8cd8000          STR      r8,[sp,#0]
                  |L14.60|
;;;1369       }
;;;1370       portEND_SWITCHING_ISR(taskWoken);
00003c  9803              LDR      r0,[sp,#0xc]
00003e  b1f8              CBZ      r0,|L14.128|
000040  4913              LDR      r1,|L14.144|
000042  f04f5080          MOV      r0,#0x10000000
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
000050  e016              B        |L14.128|
                  |L14.82|
000052  2080              MOVS     r0,#0x80              ;1345
000054  9000              STR      r0,[sp,#0]            ;1345
000056  e9dd1201          LDRD     r1,r2,[sp,#4]         ;1346
00005a  c607              STM      r6!,{r0-r2}           ;1346
                  |L14.92|
;;;1371     }
;;;1372     else {
;;;1373       if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {
;;;1374         /* We have mail */
;;;1375         event.status = osEventMail;
;;;1376       }
;;;1377       else {
;;;1378         event.status = (ticks == 0) ? osOK : osEventTimeout;
;;;1379       }
;;;1380     }
;;;1381     
;;;1382     return event;
;;;1383   }
00005c  e8bd81ff          POP      {r0-r8,pc}
                  |L14.96|
000060  f04f34ff          MOV      r4,#0xffffffff        ;1353
000064  e7dc              B        |L14.32|
                  |L14.102|
000066  9700              STR      r7,[sp,#0]            ;1365
000068  e7e8              B        |L14.60|
                  |L14.106|
00006a  2300              MOVS     r3,#0                 ;1373
00006c  4622              MOV      r2,r4                 ;1373
00006e  1d09              ADDS     r1,r1,#4              ;1373
000070  6868              LDR      r0,[r5,#4]            ;1373
000072  f7fffffe          BL       xQueueGenericReceive
000076  2801              CMP      r0,#1                 ;1373
000078  d006              BEQ      |L14.136|
00007a  b13c              CBZ      r4,|L14.140|
00007c  2140              MOVS     r1,#0x40              ;1378
                  |L14.126|
00007e  9100              STR      r1,[sp,#0]            ;1378
                  |L14.128|
000080  e89d0007          LDM      sp,{r0-r2}            ;1382
000084  c607              STM      r6!,{r0-r2}           ;1382
000086  e7e9              B        |L14.92|
                  |L14.136|
000088  9700              STR      r7,[sp,#0]            ;1375
00008a  e7f9              B        |L14.128|
                  |L14.140|
00008c  2100              MOVS     r1,#0                 ;1378
00008e  e7f6              B        |L14.126|
;;;1384   
                          ENDP

                  |L14.144|
                          DCD      0xe000ed04

                          AREA ||i.osMailPut||, CODE, READONLY, ALIGN=2

                  osMailPut PROC
;;;1302   */
;;;1303   osStatus osMailPut (osMailQId queue_id, void *mail)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;1304   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;1305     portBASE_TYPE taskWoken;
;;;1306     
;;;1307     
;;;1308     if (queue_id == NULL) {
000006  2c00              CMP      r4,#0
000008  d00f              BEQ      |L15.42|
;;;1309       return osErrorParameter;
;;;1310     }
;;;1311     
;;;1312     taskWoken = pdFALSE;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1313     
;;;1314     if (inHandlerMode()) {
00000e  f7fffffe          BL       inHandlerMode
000012  b1b8              CBZ      r0,|L15.68|
;;;1315       if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
000014  2300              MOVS     r3,#0
000016  aa01              ADD      r2,sp,#4
000018  a903              ADD      r1,sp,#0xc
00001a  6860              LDR      r0,[r4,#4]
00001c  f7fffffe          BL       xQueueGenericSendFromISR
000020  2801              CMP      r0,#1
000022  d004              BEQ      |L15.46|
;;;1316         return osErrorOS;
000024  20ff              MOVS     r0,#0xff
                  |L15.38|
;;;1317       }
;;;1318       portEND_SWITCHING_ISR(taskWoken);
;;;1319     }
;;;1320     else {
;;;1321       if (xQueueSend(queue_id->handle, &mail, 0) != pdTRUE) { 
;;;1322         return osErrorOS;
;;;1323       }
;;;1324     }
;;;1325     
;;;1326     return osOK;
;;;1327   }
000026  b004              ADD      sp,sp,#0x10
000028  bd10              POP      {r4,pc}
                  |L15.42|
00002a  2080              MOVS     r0,#0x80              ;1309
00002c  e7fb              B        |L15.38|
                  |L15.46|
00002e  9801              LDR      r0,[sp,#4]            ;1318
000030  b190              CBZ      r0,|L15.88|
000032  490a              LDR      r1,|L15.92|
000034  f04f5080          MOV      r0,#0x10000000        ;1318
000038  6008              STR      r0,[r1,#0]            ;1318
00003a  f3bf8f4f          DSB                            ;1318
00003e  f3bf8f6f          ISB                            ;1318
000042  e009              B        |L15.88|
                  |L15.68|
000044  2300              MOVS     r3,#0                 ;1321
000046  461a              MOV      r2,r3                 ;1321
000048  a903              ADD      r1,sp,#0xc            ;1321
00004a  6860              LDR      r0,[r4,#4]            ;1321
00004c  f7fffffe          BL       xQueueGenericSend
000050  2801              CMP      r0,#1                 ;1321
000052  d001              BEQ      |L15.88|
000054  20ff              MOVS     r0,#0xff              ;1322
000056  e7e6              B        |L15.38|
                  |L15.88|
000058  2000              MOVS     r0,#0                 ;1326
00005a  e7e4              B        |L15.38|
;;;1328   
                          ENDP

                  |L15.92|
                          DCD      0xe000ed04

                          AREA ||i.osMessageAvailableSpace||, CODE, READONLY, ALIGN=1

                  osMessageAvailableSpace PROC
;;;1657   */
;;;1658   uint32_t osMessageAvailableSpace(osMessageQId queue_id)  
000000  f7ffbffe          B.W      uxQueueSpacesAvailable
;;;1659   {
;;;1660     return uxQueueSpacesAvailable(queue_id);
;;;1661   }
;;;1662   
                          ENDP


                          AREA ||i.osMessageCreate||, CODE, READONLY, ALIGN=1

                  osMessageCreate PROC
;;;1085   */
;;;1086   osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
000000  c803              LDM      r0,{r0,r1}
;;;1087   {
;;;1088     (void) thread_id;
;;;1089     
;;;1090   #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;1091   
;;;1092     if ((queue_def->buffer != NULL) && (queue_def->controlblock != NULL)) {
;;;1093       return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
;;;1094     }
;;;1095     else {
;;;1096       return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
;;;1097     }
;;;1098   #elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1099     return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
;;;1100   #else  
;;;1101     return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
000002  2200              MOVS     r2,#0
000004  f7ffbffe          B.W      xQueueGenericCreate
;;;1102   #endif
;;;1103   }
;;;1104   
                          ENDP


                          AREA ||i.osMessageDelete||, CODE, READONLY, ALIGN=1

                  osMessageDelete PROC
;;;1667   */
;;;1668   osStatus osMessageDelete (osMessageQId queue_id)
000000  b510              PUSH     {r4,lr}
;;;1669   {
000002  4604              MOV      r4,r0
;;;1670     if (inHandlerMode()) {
000004  f7fffffe          BL       inHandlerMode
000008  b108              CBZ      r0,|L18.14|
;;;1671       return osErrorISR;
00000a  2082              MOVS     r0,#0x82
;;;1672     }
;;;1673   
;;;1674     vQueueDelete(queue_id);
;;;1675   
;;;1676     return osOK; 
;;;1677   }
00000c  bd10              POP      {r4,pc}
                  |L18.14|
00000e  4620              MOV      r0,r4                 ;1674
000010  f7fffffe          BL       vQueueDelete
000014  2000              MOVS     r0,#0                 ;1676
000016  bd10              POP      {r4,pc}
;;;1678   
                          ENDP


                          AREA ||i.osMessageGet||, CODE, READONLY, ALIGN=2

                  osMessageGet PROC
;;;1144   */
;;;1145   osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1146   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1147     portBASE_TYPE taskWoken;
;;;1148     TickType_t ticks;
;;;1149     osEvent event;
;;;1150     
;;;1151     event.def.message_id = queue_id;
000008  9602              STR      r6,[sp,#8]
;;;1152     event.value.v = 0;
00000a  2700              MOVS     r7,#0
00000c  9701              STR      r7,[sp,#4]
;;;1153     
;;;1154     if (queue_id == NULL) {
00000e  2e00              CMP      r6,#0
000010  d01e              BEQ      |L19.80|
;;;1155       event.status = osErrorParameter;
;;;1156       return event;
;;;1157     }
;;;1158     
;;;1159     taskWoken = pdFALSE;
000012  9703              STR      r7,[sp,#0xc]
;;;1160     
;;;1161     ticks = 0;
000014  2400              MOVS     r4,#0
;;;1162     if (millisec == osWaitForever) {
000016  1c50              ADDS     r0,r2,#1
000018  d021              BEQ      |L19.94|
;;;1163       ticks = portMAX_DELAY;
;;;1164     }
;;;1165     else if (millisec != 0) {
00001a  b102              CBZ      r2,|L19.30|
;;;1166       ticks = millisec / portTICK_PERIOD_MS;
00001c  4614              MOV      r4,r2
                  |L19.30|
;;;1167       if (ticks == 0) {
;;;1168         ticks = 1;
;;;1169       }
;;;1170     }
;;;1171     
;;;1172     if (inHandlerMode()) {
00001e  f7fffffe          BL       inHandlerMode
000022  4669              MOV      r1,sp                 ;1149
;;;1173       if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
;;;1174         /* We have mail */
;;;1175         event.status = osEventMessage;
000024  f04f0810          MOV      r8,#0x10
000028  b1f8              CBZ      r0,|L19.106|
00002a  aa03              ADD      r2,sp,#0xc            ;1173
00002c  1d09              ADDS     r1,r1,#4              ;1173
00002e  4630              MOV      r0,r6                 ;1173
000030  f7fffffe          BL       xQueueReceiveFromISR
000034  2801              CMP      r0,#1                 ;1173
000036  d015              BEQ      |L19.100|
;;;1176       }
;;;1177       else {
;;;1178         event.status = osOK;
000038  9700              STR      r7,[sp,#0]
                  |L19.58|
;;;1179       }
;;;1180       portEND_SWITCHING_ISR(taskWoken);
00003a  9803              LDR      r0,[sp,#0xc]
00003c  b300              CBZ      r0,|L19.128|
00003e  4915              LDR      r1,|L19.148|
000040  f04f5080          MOV      r0,#0x10000000
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
00004e  e017              B        |L19.128|
                  |L19.80|
000050  2080              MOVS     r0,#0x80              ;1155
000052  9000              STR      r0,[sp,#0]            ;1155
000054  e9dd1201          LDRD     r1,r2,[sp,#4]         ;1156
000058  c507              STM      r5!,{r0-r2}           ;1156
                  |L19.90|
;;;1181     }
;;;1182     else {
;;;1183       if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
;;;1184         /* We have mail */
;;;1185         event.status = osEventMessage;
;;;1186       }
;;;1187       else {
;;;1188         event.status = (ticks == 0) ? osOK : osEventTimeout;
;;;1189       }
;;;1190     }
;;;1191     
;;;1192     return event;
;;;1193   }
00005a  e8bd81ff          POP      {r0-r8,pc}
                  |L19.94|
00005e  f04f34ff          MOV      r4,#0xffffffff        ;1163
000062  e7dc              B        |L19.30|
                  |L19.100|
000064  f8cd8000          STR      r8,[sp,#0]            ;1175
000068  e7e7              B        |L19.58|
                  |L19.106|
00006a  2300              MOVS     r3,#0                 ;1183
00006c  4622              MOV      r2,r4                 ;1183
00006e  1d09              ADDS     r1,r1,#4              ;1183
000070  4630              MOV      r0,r6                 ;1183
000072  f7fffffe          BL       xQueueGenericReceive
000076  2801              CMP      r0,#1                 ;1183
000078  d006              BEQ      |L19.136|
00007a  b144              CBZ      r4,|L19.142|
00007c  2040              MOVS     r0,#0x40              ;1188
                  |L19.126|
00007e  9000              STR      r0,[sp,#0]            ;1188
                  |L19.128|
000080  e89d0007          LDM      sp,{r0-r2}            ;1192
000084  c507              STM      r5!,{r0-r2}           ;1192
000086  e7e8              B        |L19.90|
                  |L19.136|
000088  f8cd8000          STR      r8,[sp,#0]            ;1185
00008c  e7f8              B        |L19.128|
                  |L19.142|
00008e  2000              MOVS     r0,#0                 ;1188
000090  e7f5              B        |L19.126|
;;;1194   
                          ENDP

000092  0000              DCW      0x0000
                  |L19.148|
                          DCD      0xe000ed04

                          AREA ||i.osMessagePeek||, CODE, READONLY, ALIGN=1

                  osMessagePeek PROC
;;;1600   */
;;;1601   osEvent osMessagePeek (osMessageQId queue_id, uint32_t millisec)
000000  b53e              PUSH     {r1-r5,lr}
;;;1602   {
000002  4605              MOV      r5,r0
000004  4608              MOV      r0,r1
;;;1603     TickType_t ticks;
;;;1604     osEvent event;
;;;1605     
;;;1606     event.def.message_id = queue_id;
000006  9002              STR      r0,[sp,#8]
;;;1607     
;;;1608     if (queue_id == NULL) {
000008  2800              CMP      r0,#0
00000a  d012              BEQ      |L20.50|
;;;1609       event.status = osErrorParameter;
;;;1610       return event;
;;;1611     }
;;;1612     
;;;1613     ticks = 0;
00000c  2400              MOVS     r4,#0
;;;1614     if (millisec == osWaitForever) {
00000e  1c51              ADDS     r1,r2,#1
000010  d015              BEQ      |L20.62|
;;;1615       ticks = portMAX_DELAY;
;;;1616     }
;;;1617     else if (millisec != 0) {
000012  b102              CBZ      r2,|L20.22|
;;;1618       ticks = millisec / portTICK_PERIOD_MS;
000014  4614              MOV      r4,r2
                  |L20.22|
;;;1619       if (ticks == 0) {
;;;1620         ticks = 1;
;;;1621       }
;;;1622     }
;;;1623     
;;;1624     if (xQueuePeek(queue_id, &event.value.v, ticks) == pdTRUE) 
000016  2301              MOVS     r3,#1
000018  4622              MOV      r2,r4
00001a  a901              ADD      r1,sp,#4
00001c  f7fffffe          BL       xQueueGenericReceive
000020  2801              CMP      r0,#1
000022  d00f              BEQ      |L20.68|
;;;1625     {
;;;1626       /* We have mail */
;;;1627       event.status = osEventMessage;
;;;1628     }
;;;1629     else 
;;;1630     {
;;;1631       event.status = (ticks == 0) ? osOK : osEventTimeout;
000024  b18c              CBZ      r4,|L20.74|
000026  2040              MOVS     r0,#0x40
                  |L20.40|
000028  9000              STR      r0,[sp,#0]
                  |L20.42|
;;;1632     }
;;;1633     
;;;1634     return event;
00002a  e89d0007          LDM      sp,{r0-r2}
00002e  c507              STM      r5!,{r0-r2}
;;;1635   }
000030  bd3e              POP      {r1-r5,pc}
                  |L20.50|
000032  2080              MOVS     r0,#0x80              ;1609
000034  9000              STR      r0,[sp,#0]            ;1609
000036  e9dd1201          LDRD     r1,r2,[sp,#4]         ;1610
00003a  c507              STM      r5!,{r0-r2}           ;1610
00003c  bd3e              POP      {r1-r5,pc}
                  |L20.62|
00003e  f04f34ff          MOV      r4,#0xffffffff        ;1615
000042  e7e8              B        |L20.22|
                  |L20.68|
000044  2010              MOVS     r0,#0x10              ;1627
000046  9000              STR      r0,[sp,#0]            ;1627
000048  e7ef              B        |L20.42|
                  |L20.74|
00004a  2000              MOVS     r0,#0                 ;1631
00004c  e7ec              B        |L20.40|
;;;1636   
                          ENDP


                          AREA ||i.osMessagePut||, CODE, READONLY, ALIGN=2

                  osMessagePut PROC
;;;1112   */
;;;1113   osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1114   {
000002  b082              SUB      sp,sp,#8
000004  4605              MOV      r5,r0
000006  4614              MOV      r4,r2
;;;1115     portBASE_TYPE taskWoken = pdFALSE;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;1116     TickType_t ticks;
;;;1117     
;;;1118     ticks = millisec / portTICK_PERIOD_MS;
;;;1119     if (ticks == 0) {
00000c  2c00              CMP      r4,#0
00000e  d100              BNE      |L21.18|
;;;1120       ticks = 1;
000010  2401              MOVS     r4,#1
                  |L21.18|
;;;1121     }
;;;1122     
;;;1123     if (inHandlerMode()) {
000012  f7fffffe          BL       inHandlerMode
000016  b1a8              CBZ      r0,|L21.68|
;;;1124       if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
000018  2300              MOVS     r3,#0
00001a  aa01              ADD      r2,sp,#4
00001c  a903              ADD      r1,sp,#0xc
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       xQueueGenericSendFromISR
000024  2801              CMP      r0,#1
000026  d002              BEQ      |L21.46|
;;;1125         return osErrorOS;
000028  20ff              MOVS     r0,#0xff
                  |L21.42|
;;;1126       }
;;;1127       portEND_SWITCHING_ISR(taskWoken);
;;;1128     }
;;;1129     else {
;;;1130       if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
;;;1131         return osErrorOS;
;;;1132       }
;;;1133     }
;;;1134     
;;;1135     return osOK;
;;;1136   }
00002a  b005              ADD      sp,sp,#0x14
00002c  bd30              POP      {r4,r5,pc}
                  |L21.46|
00002e  9801              LDR      r0,[sp,#4]            ;1127
000030  b190              CBZ      r0,|L21.88|
000032  490a              LDR      r1,|L21.92|
000034  f04f5080          MOV      r0,#0x10000000        ;1127
000038  6008              STR      r0,[r1,#0]            ;1127
00003a  f3bf8f4f          DSB                            ;1127
00003e  f3bf8f6f          ISB                            ;1127
000042  e009              B        |L21.88|
                  |L21.68|
000044  2300              MOVS     r3,#0                 ;1130
000046  4622              MOV      r2,r4                 ;1130
000048  a903              ADD      r1,sp,#0xc            ;1130
00004a  4628              MOV      r0,r5                 ;1130
00004c  f7fffffe          BL       xQueueGenericSend
000050  2801              CMP      r0,#1                 ;1130
000052  d001              BEQ      |L21.88|
000054  20ff              MOVS     r0,#0xff              ;1131
000056  e7e8              B        |L21.42|
                  |L21.88|
000058  2000              MOVS     r0,#0                 ;1135
00005a  e7e6              B        |L21.42|
;;;1137   
                          ENDP

                  |L21.92|
                          DCD      0xe000ed04

                          AREA ||i.osMessageWaiting||, CODE, READONLY, ALIGN=1

                  osMessageWaiting PROC
;;;1641   */
;;;1642   uint32_t osMessageWaiting(osMessageQId queue_id)
000000  b510              PUSH     {r4,lr}
;;;1643   {
000002  4604              MOV      r4,r0
;;;1644     if (inHandlerMode()) {
000004  f7fffffe          BL       inHandlerMode
000008  b120              CBZ      r0,|L22.20|
;;;1645       return uxQueueMessagesWaitingFromISR(queue_id);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      uxQueueMessagesWaitingFromISR
                  |L22.20|
;;;1646     }
;;;1647     else
;;;1648     {
;;;1649       return uxQueueMessagesWaiting(queue_id);
000014  4620              MOV      r0,r4
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      uxQueueMessagesWaiting
;;;1650     }
;;;1651   }
;;;1652   
                          ENDP


                          AREA ||i.osMutexCreate||, CODE, READONLY, ALIGN=1

                  osMutexCreate PROC
;;;639    */
;;;640    osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
000000  2001              MOVS     r0,#1
;;;641    {
;;;642    #if ( configUSE_MUTEXES == 1)
;;;643    
;;;644    #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;645    
;;;646      if (mutex_def->controlblock != NULL) {
;;;647        return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
;;;648         }
;;;649      else {
;;;650        return xSemaphoreCreateMutex(); 
;;;651      }
;;;652    #elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;653      return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
;;;654    #else  
;;;655        return xSemaphoreCreateMutex(); 
000002  f7ffbffe          B.W      xQueueCreateMutex
;;;656    #endif
;;;657    #else
;;;658      return NULL;
;;;659    #endif
;;;660    }
;;;661    
                          ENDP


                          AREA ||i.osMutexDelete||, CODE, READONLY, ALIGN=1

                  osMutexDelete PROC
;;;732    */
;;;733    osStatus osMutexDelete (osMutexId mutex_id)
000000  b510              PUSH     {r4,lr}
;;;734    {
000002  4604              MOV      r4,r0
;;;735      if (inHandlerMode()) {
000004  f7fffffe          BL       inHandlerMode
000008  b108              CBZ      r0,|L24.14|
;;;736        return osErrorISR;
00000a  2082              MOVS     r0,#0x82
;;;737      }
;;;738    
;;;739      vQueueDelete(mutex_id);
;;;740    
;;;741      return osOK;
;;;742    }
00000c  bd10              POP      {r4,pc}
                  |L24.14|
00000e  4620              MOV      r0,r4                 ;739
000010  f7fffffe          BL       vQueueDelete
000014  2000              MOVS     r0,#0                 ;741
000016  bd10              POP      {r4,pc}
;;;743    
                          ENDP


                          AREA ||i.osMutexRelease||, CODE, READONLY, ALIGN=2

                  osMutexRelease PROC
;;;708    */
;;;709    osStatus osMutexRelease (osMutexId mutex_id)
000000  b538              PUSH     {r3-r5,lr}
;;;710    {
000002  4605              MOV      r5,r0
;;;711      osStatus result = osOK;
000004  2400              MOVS     r4,#0
;;;712      portBASE_TYPE taskWoken = pdFALSE;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;713      
;;;714      if (inHandlerMode()) {
00000a  f7fffffe          BL       inHandlerMode
00000e  b190              CBZ      r0,|L25.54|
;;;715        if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
000010  4669              MOV      r1,sp
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       xQueueGiveFromISR
000018  2801              CMP      r0,#1
00001a  d001              BEQ      |L25.32|
;;;716          return osErrorOS;
00001c  20ff              MOVS     r0,#0xff
;;;717        }
;;;718        portEND_SWITCHING_ISR(taskWoken);
;;;719      }
;;;720      else if (xSemaphoreGive(mutex_id) != pdTRUE) 
;;;721      {
;;;722        result = osErrorOS;
;;;723      }
;;;724      return result;
;;;725    }
00001e  bd38              POP      {r3-r5,pc}
                  |L25.32|
000020  9800              LDR      r0,[sp,#0]            ;718
000022  b188              CBZ      r0,|L25.72|
000024  4909              LDR      r1,|L25.76|
000026  f04f5080          MOV      r0,#0x10000000        ;718
00002a  6008              STR      r0,[r1,#0]            ;718
00002c  f3bf8f4f          DSB                            ;718
000030  f3bf8f6f          ISB                            ;718
000034  e008              B        |L25.72|
                  |L25.54|
000036  2300              MOVS     r3,#0                 ;720
000038  461a              MOV      r2,r3                 ;720
00003a  4619              MOV      r1,r3                 ;720
00003c  4628              MOV      r0,r5                 ;720
00003e  f7fffffe          BL       xQueueGenericSend
000042  2801              CMP      r0,#1                 ;720
000044  d000              BEQ      |L25.72|
000046  24ff              MOVS     r4,#0xff              ;722
                  |L25.72|
000048  4620              MOV      r0,r4                 ;724
00004a  bd38              POP      {r3-r5,pc}
;;;726    
                          ENDP

                  |L25.76|
                          DCD      0xe000ed04

                          AREA ||i.osMutexWait||, CODE, READONLY, ALIGN=2

                  osMutexWait PROC
;;;668    */
;;;669    osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
000000  b538              PUSH     {r3-r5,lr}
;;;670    {
000002  4605              MOV      r5,r0
;;;671      TickType_t ticks;
;;;672      portBASE_TYPE taskWoken = pdFALSE;  
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;673      
;;;674      
;;;675      if (mutex_id == NULL) {
000008  2d00              CMP      r5,#0
00000a  d010              BEQ      |L26.46|
;;;676        return osErrorParameter;
;;;677      }
;;;678      
;;;679      ticks = 0;
00000c  2400              MOVS     r4,#0
;;;680      if (millisec == osWaitForever) {
00000e  1c4a              ADDS     r2,r1,#1
000010  d00f              BEQ      |L26.50|
;;;681        ticks = portMAX_DELAY;
;;;682      }
;;;683      else if (millisec != 0) {
000012  b101              CBZ      r1,|L26.22|
;;;684        ticks = millisec / portTICK_PERIOD_MS;
000014  460c              MOV      r4,r1
                  |L26.22|
;;;685        if (ticks == 0) {
;;;686          ticks = 1;
;;;687        }
;;;688      }
;;;689      
;;;690      if (inHandlerMode()) {
000016  f7fffffe          BL       inHandlerMode
00001a  b1c0              CBZ      r0,|L26.78|
;;;691        if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
00001c  466a              MOV      r2,sp
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       xQueueReceiveFromISR
000026  2801              CMP      r0,#1
000028  d006              BEQ      |L26.56|
;;;692          return osErrorOS;
00002a  20ff              MOVS     r0,#0xff
;;;693        }
;;;694    	portEND_SWITCHING_ISR(taskWoken);
;;;695      } 
;;;696      else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
;;;697        return osErrorOS;
;;;698      }
;;;699      
;;;700      return osOK;
;;;701    }
00002c  bd38              POP      {r3-r5,pc}
                  |L26.46|
00002e  2080              MOVS     r0,#0x80              ;676
000030  bd38              POP      {r3-r5,pc}
                  |L26.50|
000032  f04f34ff          MOV      r4,#0xffffffff        ;681
000036  e7ee              B        |L26.22|
                  |L26.56|
000038  9800              LDR      r0,[sp,#0]            ;694
00003a  b190              CBZ      r0,|L26.98|
00003c  490a              LDR      r1,|L26.104|
00003e  f04f5080          MOV      r0,#0x10000000        ;694
000042  6008              STR      r0,[r1,#0]            ;694
000044  f3bf8f4f          DSB                            ;694
000048  f3bf8f6f          ISB                            ;694
00004c  e009              B        |L26.98|
                  |L26.78|
00004e  2300              MOVS     r3,#0                 ;696
000050  4622              MOV      r2,r4                 ;696
000052  4619              MOV      r1,r3                 ;696
000054  4628              MOV      r0,r5                 ;696
000056  f7fffffe          BL       xQueueGenericReceive
00005a  2801              CMP      r0,#1                 ;696
00005c  d001              BEQ      |L26.98|
00005e  20ff              MOVS     r0,#0xff              ;697
000060  bd38              POP      {r3-r5,pc}
                  |L26.98|
000062  2000              MOVS     r0,#0                 ;700
000064  bd38              POP      {r3-r5,pc}
;;;702    
                          ENDP

000066  0000              DCW      0x0000
                  |L26.104|
                          DCD      0xe000ed04

                          AREA ||i.osPoolAlloc||, CODE, READONLY, ALIGN=1

                  osPoolAlloc PROC
;;;978    */
;;;979    void *osPoolAlloc (osPoolId pool_id)
000000  b570              PUSH     {r4-r6,lr}
;;;980    {
000002  4604              MOV      r4,r0
;;;981      int dummy = 0;
000004  2500              MOVS     r5,#0
;;;982      void *p = NULL;
000006  2600              MOVS     r6,#0
;;;983      uint32_t i;
;;;984      uint32_t index;
;;;985      
;;;986      if (inHandlerMode()) {
000008  f7fffffe          BL       inHandlerMode
00000c  b148              CBZ      r0,|L27.34|
00000e  2050              MOVS     r0,#0x50
000010  f3ef8511          MRS      r5,BASEPRI
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
;;;987        dummy = portSET_INTERRUPT_MASK_FROM_ISR();
000020  e001              B        |L27.38|
                  |L27.34|
;;;988      }
;;;989      else {
;;;990        vPortEnterCritical();
000022  f7fffffe          BL       vPortEnterCritical
                  |L27.38|
;;;991      }
;;;992      
;;;993      for (i = 0; i < pool_id->pool_sz; i++) {
000026  2000              MOVS     r0,#0
;;;994        index = pool_id->currentIndex + i;
;;;995        if (index >= pool_id->pool_sz) {
000028  68a2              LDR      r2,[r4,#8]
00002a  e008              B        |L27.62|
                  |L27.44|
00002c  6921              LDR      r1,[r4,#0x10]         ;994
00002e  4401              ADD      r1,r1,r0              ;994
000030  428a              CMP      r2,r1
000032  d800              BHI      |L27.54|
;;;996          index = 0;
000034  2100              MOVS     r1,#0
                  |L27.54|
;;;997        }
;;;998        
;;;999        if (pool_id->markers[index] == 0) {
000036  6863              LDR      r3,[r4,#4]
000038  5c5b              LDRB     r3,[r3,r1]
00003a  b143              CBZ      r3,|L27.78|
00003c  1c40              ADDS     r0,r0,#1              ;993
                  |L27.62|
00003e  4282              CMP      r2,r0                 ;993
000040  d8f4              BHI      |L27.44|
                  |L27.66|
;;;1000         pool_id->markers[index] = 1;
;;;1001         p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
;;;1002         pool_id->currentIndex = index;
;;;1003         break;
;;;1004       }
;;;1005     }
;;;1006     
;;;1007     if (inHandlerMode()) {
000042  f7fffffe          BL       inHandlerMode
000046  b158              CBZ      r0,|L27.96|
000048  f3858811          MSR      BASEPRI,r5            ;1003
;;;1008       portCLEAR_INTERRUPT_MASK_FROM_ISR(dummy);
00004c  e00a              B        |L27.100|
                  |L27.78|
00004e  6862              LDR      r2,[r4,#4]            ;1000
000050  2001              MOVS     r0,#1                 ;1000
000052  5450              STRB     r0,[r2,r1]            ;1000
000054  68e2              LDR      r2,[r4,#0xc]          ;1001
000056  6820              LDR      r0,[r4,#0]            ;1001
000058  fb010602          MLA      r6,r1,r2,r0           ;1001
00005c  6121              STR      r1,[r4,#0x10]         ;1002
00005e  e7f0              B        |L27.66|
                  |L27.96|
;;;1009     }
;;;1010     else {
;;;1011       vPortExitCritical();
000060  f7fffffe          BL       vPortExitCritical
                  |L27.100|
;;;1012     }
;;;1013     
;;;1014     return p;
000064  4630              MOV      r0,r6
;;;1015   }
000066  bd70              POP      {r4-r6,pc}
;;;1016   
                          ENDP


                          AREA ||i.osPoolCAlloc||, CODE, READONLY, ALIGN=1

                  osPoolCAlloc PROC
;;;1022   */
;;;1023   void *osPoolCAlloc (osPoolId pool_id)
000000  b510              PUSH     {r4,lr}
;;;1024   {
;;;1025     void *p = osPoolAlloc(pool_id);
000002  f7fffffe          BL       osPoolAlloc
;;;1026     
;;;1027     if (p != NULL)
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L28.14|
;;;1028     {
;;;1029       memset(p, 0, sizeof(pool_id->pool_sz));
00000a  2100              MOVS     r1,#0
00000c  6001              STR      r1,[r0,#0]
                  |L28.14|
;;;1030     }
;;;1031     
;;;1032     return p;
;;;1033   }
00000e  bd10              POP      {r4,pc}
;;;1034   
                          ENDP


                          AREA ||i.osPoolCreate||, CODE, READONLY, ALIGN=1

                  osPoolCreate PROC
;;;925    */
;;;926    osPoolId osPoolCreate (const osPoolDef_t *pool_def)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;927    {
000004  4605              MOV      r5,r0
;;;928    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;929      osPoolId thePool;
;;;930      int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
000006  6868              LDR      r0,[r5,#4]
000008  1cc0              ADDS     r0,r0,#3
00000a  f0200703          BIC      r7,r0,#3
;;;931      uint32_t i;
;;;932      
;;;933      /* First have to allocate memory for the pool control block. */
;;;934     thePool = pvPortMalloc(sizeof(os_pool_cb_t));
00000e  2014              MOVS     r0,#0x14
000010  f7fffffe          BL       pvPortMalloc
000014  4604              MOV      r4,r0
;;;935    
;;;936      
;;;937      if (thePool) {
000016  0020              MOVS     r0,r4
000018  d024              BEQ      |L29.100|
;;;938        thePool->pool_sz = pool_def->pool_sz;
00001a  6828              LDR      r0,[r5,#0]
00001c  60a0              STR      r0,[r4,#8]
;;;939        thePool->item_sz = itemSize;
00001e  60e7              STR      r7,[r4,#0xc]
;;;940        thePool->currentIndex = 0;
000020  2600              MOVS     r6,#0
000022  6126              STR      r6,[r4,#0x10]
;;;941        
;;;942        /* Memory for markers */
;;;943        thePool->markers = pvPortMalloc(pool_def->pool_sz);
000024  6828              LDR      r0,[r5,#0]
000026  f7fffffe          BL       pvPortMalloc
00002a  6060              STR      r0,[r4,#4]
;;;944       
;;;945        if (thePool->markers) {
00002c  b1b0              CBZ      r0,|L29.92|
;;;946          /* Now allocate the pool itself. */
;;;947         thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
00002e  6828              LDR      r0,[r5,#0]
000030  4378              MULS     r0,r7,r0
000032  f7fffffe          BL       pvPortMalloc
000036  6020              STR      r0,[r4,#0]
;;;948          
;;;949          if (thePool->pool) {
000038  b140              CBZ      r0,|L29.76|
;;;950            for (i = 0; i < pool_def->pool_sz; i++) {
00003a  2000              MOVS     r0,#0
00003c  e002              B        |L29.68|
                  |L29.62|
;;;951              thePool->markers[i] = 0;
00003e  6861              LDR      r1,[r4,#4]
000040  540e              STRB     r6,[r1,r0]
000042  1c40              ADDS     r0,r0,#1              ;950
                  |L29.68|
000044  6829              LDR      r1,[r5,#0]            ;950
000046  4281              CMP      r1,r0                 ;950
000048  d8f9              BHI      |L29.62|
00004a  e00b              B        |L29.100|
                  |L29.76|
;;;952            }
;;;953          }
;;;954          else {
;;;955            vPortFree(thePool->markers);
00004c  6860              LDR      r0,[r4,#4]
00004e  f7fffffe          BL       vPortFree
;;;956            vPortFree(thePool);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       vPortFree
;;;957            thePool = NULL;
000058  2400              MOVS     r4,#0
00005a  e003              B        |L29.100|
                  |L29.92|
;;;958          }
;;;959        }
;;;960        else {
;;;961          vPortFree(thePool);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       vPortFree
;;;962          thePool = NULL;
000062  2400              MOVS     r4,#0
                  |L29.100|
;;;963        }
;;;964      }
;;;965    
;;;966      return thePool;
000064  4620              MOV      r0,r4
;;;967     
;;;968    #else
;;;969      return NULL;
;;;970    #endif
;;;971    }
000066  e8bd81f0          POP      {r4-r8,pc}
;;;972    
                          ENDP


                          AREA ||i.osPoolFree||, CODE, READONLY, ALIGN=1

                  osPoolFree PROC
;;;1041   */
;;;1042   osStatus osPoolFree (osPoolId pool_id, void *block)
000000  2800              CMP      r0,#0
;;;1043   {
000002  d005              BEQ      |L30.16|
;;;1044     uint32_t index;
;;;1045     
;;;1046     if (pool_id == NULL) {
;;;1047       return osErrorParameter;
;;;1048     }
;;;1049     
;;;1050     if (block == NULL) {
000004  b131              CBZ      r1,|L30.20|
;;;1051       return osErrorParameter;
;;;1052     }
;;;1053     
;;;1054     if (block < pool_id->pool) {
000006  6802              LDR      r2,[r0,#0]
000008  428a              CMP      r2,r1
00000a  d905              BLS      |L30.24|
;;;1055       return osErrorParameter;
00000c  2080              MOVS     r0,#0x80
;;;1056     }
;;;1057     
;;;1058     index = (uint32_t)block - (uint32_t)(pool_id->pool);
;;;1059     if (index % pool_id->item_sz) {
;;;1060       return osErrorParameter;
;;;1061     }
;;;1062     index = index / pool_id->item_sz;
;;;1063     if (index >= pool_id->pool_sz) {
;;;1064       return osErrorParameter;
;;;1065     }
;;;1066     
;;;1067     pool_id->markers[index] = 0;
;;;1068     
;;;1069     return osOK;
;;;1070   }
00000e  4770              BX       lr
                  |L30.16|
000010  2080              MOVS     r0,#0x80              ;1047
000012  4770              BX       lr
                  |L30.20|
000014  2080              MOVS     r0,#0x80              ;1051
000016  4770              BX       lr
                  |L30.24|
000018  1a8a              SUBS     r2,r1,r2              ;1058
00001a  68c1              LDR      r1,[r0,#0xc]          ;1059
00001c  fbb2f3f1          UDIV     r3,r2,r1              ;1059
000020  fb012313          MLS      r3,r1,r3,r2           ;1059
000024  b10b              CBZ      r3,|L30.42|
000026  2080              MOVS     r0,#0x80              ;1060
000028  4770              BX       lr
                  |L30.42|
00002a  fbb2f1f1          UDIV     r1,r2,r1              ;1062
00002e  6882              LDR      r2,[r0,#8]            ;1063
000030  428a              CMP      r2,r1                 ;1063
000032  d801              BHI      |L30.56|
000034  2080              MOVS     r0,#0x80              ;1064
000036  4770              BX       lr
                  |L30.56|
000038  6840              LDR      r0,[r0,#4]            ;1067
00003a  2200              MOVS     r2,#0                 ;1067
00003c  5442              STRB     r2,[r0,r1]            ;1067
00003e  2000              MOVS     r0,#0                 ;1069
000040  4770              BX       lr
;;;1071   
                          ENDP


                          AREA ||i.osRecursiveMutexCreate||, CODE, READONLY, ALIGN=1

                  osRecursiveMutexCreate PROC
;;;1683   */
;;;1684   osMutexId osRecursiveMutexCreate (const osMutexDef_t *mutex_def)
000000  2000              MOVS     r0,#0
;;;1685   {
;;;1686   #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1687   #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;1688   
;;;1689     if (mutex_def->controlblock != NULL){
;;;1690       return xSemaphoreCreateRecursiveMutexStatic( mutex_def->controlblock );
;;;1691     }
;;;1692     else {
;;;1693       return xSemaphoreCreateRecursiveMutex();
;;;1694     }
;;;1695   #elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1696     return xSemaphoreCreateRecursiveMutexStatic( mutex_def->controlblock );
;;;1697   #else 
;;;1698     return xSemaphoreCreateRecursiveMutex();
;;;1699   #endif
;;;1700   #else
;;;1701     return NULL;
;;;1702   #endif	
;;;1703   }
000002  4770              BX       lr
;;;1704   
                          ENDP


                          AREA ||i.osRecursiveMutexRelease||, CODE, READONLY, ALIGN=1

                  osRecursiveMutexRelease PROC
;;;1709   */
;;;1710   osStatus osRecursiveMutexRelease (osMutexId mutex_id)
000000  2081              MOVS     r0,#0x81
;;;1711   {
;;;1712   #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1713     osStatus result = osOK;
;;;1714    
;;;1715     if (xSemaphoreGiveRecursive(mutex_id) != pdTRUE) 
;;;1716     {
;;;1717       result = osErrorOS;
;;;1718     }
;;;1719     return result;
;;;1720   #else
;;;1721   	return osErrorResource;
;;;1722   #endif
;;;1723   }
000002  4770              BX       lr
;;;1724   
                          ENDP


                          AREA ||i.osRecursiveMutexWait||, CODE, READONLY, ALIGN=1

                  osRecursiveMutexWait PROC
;;;1730   */
;;;1731   osStatus osRecursiveMutexWait (osMutexId mutex_id, uint32_t millisec)
000000  2081              MOVS     r0,#0x81
;;;1732   {
;;;1733   #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1734     TickType_t ticks;
;;;1735     
;;;1736     if (mutex_id == NULL)
;;;1737     {
;;;1738       return osErrorParameter;
;;;1739     }
;;;1740     
;;;1741     ticks = 0;
;;;1742     if (millisec == osWaitForever) 
;;;1743     {
;;;1744       ticks = portMAX_DELAY;
;;;1745     }
;;;1746     else if (millisec != 0) 
;;;1747     {
;;;1748       ticks = millisec / portTICK_PERIOD_MS;
;;;1749       if (ticks == 0) 
;;;1750       {
;;;1751         ticks = 1;
;;;1752       }
;;;1753     }
;;;1754     
;;;1755     if (xSemaphoreTakeRecursive(mutex_id, ticks) != pdTRUE) 
;;;1756     {
;;;1757       return osErrorOS;
;;;1758     }
;;;1759     return osOK;
;;;1760   #else
;;;1761   	return osErrorResource;
;;;1762   #endif
;;;1763   }
000002  4770              BX       lr
;;;1764   
                          ENDP


                          AREA ||i.osSemaphoreCreate||, CODE, READONLY, ALIGN=1

                  osSemaphoreCreate PROC
;;;754    */
;;;755    osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
000000  b510              PUSH     {r4,lr}
;;;756    { 
;;;757    #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;758    
;;;759      osSemaphoreId sema;
;;;760      
;;;761      if (semaphore_def->controlblock != NULL){
;;;762        if (count == 1) {
;;;763          return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
;;;764        }
;;;765        else {
;;;766    #if (configUSE_COUNTING_SEMAPHORES == 1 )
;;;767          return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
;;;768    #else
;;;769          return NULL;
;;;770    #endif
;;;771        }
;;;772      }
;;;773      else {
;;;774        if (count == 1) {
;;;775          vSemaphoreCreateBinary(sema);
;;;776          return sema;
;;;777        }
;;;778        else {
;;;779    #if (configUSE_COUNTING_SEMAPHORES == 1 )	
;;;780          return xSemaphoreCreateCounting(count, count);
;;;781    #else
;;;782          return NULL;
;;;783    #endif    
;;;784        }
;;;785      }
;;;786    #elif ( configSUPPORT_STATIC_ALLOCATION == 1 ) // configSUPPORT_DYNAMIC_ALLOCATION == 0
;;;787      if(count == 1) {
;;;788        return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
;;;789      }
;;;790      else
;;;791      {
;;;792    #if (configUSE_COUNTING_SEMAPHORES == 1 )
;;;793          return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
;;;794    #else
;;;795          return NULL;
;;;796    #endif    
;;;797      }
;;;798    #else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
;;;799      osSemaphoreId sema;
;;;800     
;;;801      if (count == 1) {
000002  2901              CMP      r1,#1
000004  d001              BEQ      |L34.10|
;;;802        vSemaphoreCreateBinary(sema);
;;;803        return sema;
;;;804      }
;;;805      else {
;;;806    #if (configUSE_COUNTING_SEMAPHORES == 1 )	
;;;807        return xSemaphoreCreateCounting(count, count);
;;;808    #else
;;;809        return NULL;
000006  2000              MOVS     r0,#0
;;;810    #endif
;;;811      }
;;;812    #endif
;;;813    }
000008  bd10              POP      {r4,pc}
                  |L34.10|
00000a  2203              MOVS     r2,#3                 ;802
00000c  2100              MOVS     r1,#0                 ;802
00000e  2001              MOVS     r0,#1                 ;802
000010  f7fffffe          BL       xQueueGenericCreate
000014  4604              MOV      r4,r0                 ;802
000016  b12c              CBZ      r4,|L34.36|
000018  2300              MOVS     r3,#0                 ;802
00001a  461a              MOV      r2,r3                 ;802
00001c  4619              MOV      r1,r3                 ;802
00001e  4620              MOV      r0,r4                 ;802
000020  f7fffffe          BL       xQueueGenericSend
                  |L34.36|
000024  4620              MOV      r0,r4                 ;803
000026  bd10              POP      {r4,pc}
;;;814    
                          ENDP


                          AREA ||i.osSemaphoreDelete||, CODE, READONLY, ALIGN=1

                  osSemaphoreDelete PROC
;;;888    */
;;;889    osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
000000  b510              PUSH     {r4,lr}
;;;890    {
000002  4604              MOV      r4,r0
;;;891      if (inHandlerMode()) {
000004  f7fffffe          BL       inHandlerMode
000008  b108              CBZ      r0,|L35.14|
;;;892        return osErrorISR;
00000a  2082              MOVS     r0,#0x82
;;;893      }
;;;894    
;;;895      vSemaphoreDelete(semaphore_id);
;;;896    
;;;897      return osOK; 
;;;898    }
00000c  bd10              POP      {r4,pc}
                  |L35.14|
00000e  4620              MOV      r0,r4                 ;895
000010  f7fffffe          BL       vQueueDelete
000014  2000              MOVS     r0,#0                 ;897
000016  bd10              POP      {r4,pc}
;;;899    
                          ENDP


                          AREA ||i.osSemaphoreGetCount||, CODE, READONLY, ALIGN=1

                  osSemaphoreGetCount PROC
;;;1769   */
;;;1770   uint32_t osSemaphoreGetCount(osSemaphoreId semaphore_id)
000000  f7ffbffe          B.W      uxQueueMessagesWaiting
;;;1771   {
;;;1772     return uxSemaphoreGetCount(semaphore_id);
;;;1773   }
                          ENDP


                          AREA ||i.osSemaphoreRelease||, CODE, READONLY, ALIGN=2

                  osSemaphoreRelease PROC
;;;861    */
;;;862    osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
000000  b538              PUSH     {r3-r5,lr}
;;;863    {
000002  4605              MOV      r5,r0
;;;864      osStatus result = osOK;
000004  2400              MOVS     r4,#0
;;;865      portBASE_TYPE taskWoken = pdFALSE;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;866      
;;;867      
;;;868      if (inHandlerMode()) {
00000a  f7fffffe          BL       inHandlerMode
00000e  b190              CBZ      r0,|L37.54|
;;;869        if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
000010  4669              MOV      r1,sp
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       xQueueGiveFromISR
000018  2801              CMP      r0,#1
00001a  d001              BEQ      |L37.32|
;;;870          return osErrorOS;
00001c  20ff              MOVS     r0,#0xff
;;;871        }
;;;872        portEND_SWITCHING_ISR(taskWoken);
;;;873      }
;;;874      else {
;;;875        if (xSemaphoreGive(semaphore_id) != pdTRUE) {
;;;876          result = osErrorOS;
;;;877        }
;;;878      }
;;;879      
;;;880      return result;
;;;881    }
00001e  bd38              POP      {r3-r5,pc}
                  |L37.32|
000020  9800              LDR      r0,[sp,#0]            ;872
000022  b188              CBZ      r0,|L37.72|
000024  4909              LDR      r1,|L37.76|
000026  f04f5080          MOV      r0,#0x10000000        ;872
00002a  6008              STR      r0,[r1,#0]            ;872
00002c  f3bf8f4f          DSB                            ;872
000030  f3bf8f6f          ISB                            ;872
000034  e008              B        |L37.72|
                  |L37.54|
000036  2300              MOVS     r3,#0                 ;875
000038  461a              MOV      r2,r3                 ;875
00003a  4619              MOV      r1,r3                 ;875
00003c  4628              MOV      r0,r5                 ;875
00003e  f7fffffe          BL       xQueueGenericSend
000042  2801              CMP      r0,#1                 ;875
000044  d000              BEQ      |L37.72|
000046  24ff              MOVS     r4,#0xff              ;876
                  |L37.72|
000048  4620              MOV      r0,r4                 ;880
00004a  bd38              POP      {r3-r5,pc}
;;;882    
                          ENDP

                  |L37.76|
                          DCD      0xe000ed04

                          AREA ||i.osSemaphoreWait||, CODE, READONLY, ALIGN=2

                  osSemaphoreWait PROC
;;;821    */
;;;822    int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
000000  b538              PUSH     {r3-r5,lr}
;;;823    {
000002  4605              MOV      r5,r0
;;;824      TickType_t ticks;
;;;825      portBASE_TYPE taskWoken = pdFALSE;  
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;826      
;;;827      
;;;828      if (semaphore_id == NULL) {
000008  2d00              CMP      r5,#0
00000a  d010              BEQ      |L38.46|
;;;829        return osErrorParameter;
;;;830      }
;;;831      
;;;832      ticks = 0;
00000c  2400              MOVS     r4,#0
;;;833      if (millisec == osWaitForever) {
00000e  1c4a              ADDS     r2,r1,#1
000010  d00f              BEQ      |L38.50|
;;;834        ticks = portMAX_DELAY;
;;;835      }
;;;836      else if (millisec != 0) {
000012  b101              CBZ      r1,|L38.22|
;;;837        ticks = millisec / portTICK_PERIOD_MS;
000014  460c              MOV      r4,r1
                  |L38.22|
;;;838        if (ticks == 0) {
;;;839          ticks = 1;
;;;840        }
;;;841      }
;;;842      
;;;843      if (inHandlerMode()) {
000016  f7fffffe          BL       inHandlerMode
00001a  b1c0              CBZ      r0,|L38.78|
;;;844        if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
00001c  466a              MOV      r2,sp
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       xQueueReceiveFromISR
000026  2801              CMP      r0,#1
000028  d006              BEQ      |L38.56|
;;;845          return osErrorOS;
00002a  20ff              MOVS     r0,#0xff
;;;846        }
;;;847    	portEND_SWITCHING_ISR(taskWoken);
;;;848      }  
;;;849      else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
;;;850        return osErrorOS;
;;;851      }
;;;852      
;;;853      return osOK;
;;;854    }
00002c  bd38              POP      {r3-r5,pc}
                  |L38.46|
00002e  2080              MOVS     r0,#0x80              ;829
000030  bd38              POP      {r3-r5,pc}
                  |L38.50|
000032  f04f34ff          MOV      r4,#0xffffffff        ;834
000036  e7ee              B        |L38.22|
                  |L38.56|
000038  9800              LDR      r0,[sp,#0]            ;847
00003a  b190              CBZ      r0,|L38.98|
00003c  490a              LDR      r1,|L38.104|
00003e  f04f5080          MOV      r0,#0x10000000        ;847
000042  6008              STR      r0,[r1,#0]            ;847
000044  f3bf8f4f          DSB                            ;847
000048  f3bf8f6f          ISB                            ;847
00004c  e009              B        |L38.98|
                  |L38.78|
00004e  2300              MOVS     r3,#0                 ;849
000050  4622              MOV      r2,r4                 ;849
000052  4619              MOV      r1,r3                 ;849
000054  4628              MOV      r0,r5                 ;849
000056  f7fffffe          BL       xQueueGenericReceive
00005a  2801              CMP      r0,#1                 ;849
00005c  d001              BEQ      |L38.98|
00005e  20ff              MOVS     r0,#0xff              ;850
000060  bd38              POP      {r3-r5,pc}
                  |L38.98|
000062  2000              MOVS     r0,#0                 ;853
000064  bd38              POP      {r3-r5,pc}
;;;855    
                          ENDP

000066  0000              DCW      0x0000
                  |L38.104|
                          DCD      0xe000ed04

                          AREA ||i.osSignalSet||, CODE, READONLY, ALIGN=2

                  osSignalSet PROC
;;;544    */
;;;545    int32_t osSignalSet (osThreadId thread_id, int32_t signal)
000000  b5fe              PUSH     {r1-r7,lr}
;;;546    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;547    #if( configUSE_TASK_NOTIFICATIONS == 1 )	
;;;548      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;549      uint32_t ulPreviousNotificationValue = 0;
00000a  9001              STR      r0,[sp,#4]
;;;550      
;;;551      if (inHandlerMode())
00000c  f7fffffe          BL       inHandlerMode
;;;552      {
;;;553        if(xTaskGenericNotifyFromISR( thread_id , (uint32_t)signal, eSetBits, &ulPreviousNotificationValue, &xHigherPriorityTaskWoken ) != pdPASS )
;;;554          return 0x80000000;
000010  f04f4400          MOV      r4,#0x80000000
000014  b1b0              CBZ      r0,|L39.68|
000016  a802              ADD      r0,sp,#8              ;553
000018  9000              STR      r0,[sp,#0]            ;553
00001a  ab01              ADD      r3,sp,#4              ;553
00001c  2201              MOVS     r2,#1                 ;553
00001e  4631              MOV      r1,r6                 ;553
000020  4628              MOV      r0,r5                 ;553
000022  f7fffffe          BL       xTaskGenericNotifyFromISR
000026  2801              CMP      r0,#1                 ;553
000028  d001              BEQ      |L39.46|
00002a  4620              MOV      r0,r4
;;;555        
;;;556        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
;;;557      }  
;;;558      else if(xTaskGenericNotify( thread_id , (uint32_t)signal, eSetBits, &ulPreviousNotificationValue) != pdPASS )
;;;559        return 0x80000000;
;;;560      
;;;561      return ulPreviousNotificationValue;
;;;562    #else
;;;563      (void) thread_id;
;;;564      (void) signal;
;;;565    
;;;566      return 0x80000000; /* Task Notification not supported */ 	
;;;567    #endif
;;;568    }
00002c  bdfe              POP      {r1-r7,pc}
                  |L39.46|
00002e  9802              LDR      r0,[sp,#8]            ;556
000030  b190              CBZ      r0,|L39.88|
000032  490a              LDR      r1,|L39.92|
000034  f04f5080          MOV      r0,#0x10000000        ;556
000038  6008              STR      r0,[r1,#0]            ;556
00003a  f3bf8f4f          DSB                            ;556
00003e  f3bf8f6f          ISB                            ;556
000042  e009              B        |L39.88|
                  |L39.68|
000044  ab01              ADD      r3,sp,#4              ;558
000046  2201              MOVS     r2,#1                 ;558
000048  4631              MOV      r1,r6                 ;558
00004a  4628              MOV      r0,r5                 ;558
00004c  f7fffffe          BL       xTaskGenericNotify
000050  2801              CMP      r0,#1                 ;558
000052  d001              BEQ      |L39.88|
000054  4620              MOV      r0,r4                 ;559
000056  bdfe              POP      {r1-r7,pc}
                  |L39.88|
000058  9801              LDR      r0,[sp,#4]            ;561
00005a  bdfe              POP      {r1-r7,pc}
;;;569    
                          ENDP

                  |L39.92|
                          DCD      0xe000ed04

                          AREA ||i.osSignalWait||, CODE, READONLY, ALIGN=1

                  osSignalWait PROC
;;;585    */
;;;586    osEvent osSignalWait (int32_t signals, uint32_t millisec)
000000  b5fe              PUSH     {r1-r7,lr}
;;;587    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
;;;588      osEvent ret;
;;;589    
;;;590    #if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;591    	
;;;592      TickType_t ticks;
;;;593    
;;;594      ret.value.signals = 0;  
000006  2600              MOVS     r6,#0
000008  9601              STR      r6,[sp,#4]
;;;595      ticks = 0;
00000a  2400              MOVS     r4,#0
;;;596      if (millisec == osWaitForever) {
00000c  1c53              ADDS     r3,r2,#1
00000e  d007              BEQ      |L40.32|
;;;597        ticks = portMAX_DELAY;
;;;598      }
;;;599      else if (millisec != 0) {
000010  b102              CBZ      r2,|L40.20|
;;;600        ticks = millisec / portTICK_PERIOD_MS;
000012  4614              MOV      r4,r2
                  |L40.20|
;;;601        if (ticks == 0) {
;;;602          ticks = 1;
;;;603        }
;;;604      }  
;;;605      
;;;606      if (inHandlerMode())
000014  f7fffffe          BL       inHandlerMode
000018  b128              CBZ      r0,|L40.38|
;;;607      {
;;;608        ret.status = osErrorISR;  /*Not allowed in ISR*/
00001a  2082              MOVS     r0,#0x82
00001c  9000              STR      r0,[sp,#0]
00001e  e018              B        |L40.82|
                  |L40.32|
000020  f04f34ff          MOV      r4,#0xffffffff        ;597
000024  e7f6              B        |L40.20|
                  |L40.38|
;;;609      }
;;;610      else
;;;611      {
;;;612        if(xTaskNotifyWait( 0,(uint32_t) signals, (uint32_t *)&ret.value.signals, ticks) != pdTRUE)
000026  4623              MOV      r3,r4
000028  aa01              ADD      r2,sp,#4
00002a  4639              MOV      r1,r7
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       xTaskNotifyWait
000032  2801              CMP      r0,#1
000034  d005              BEQ      |L40.66|
;;;613        {
;;;614          if(ticks == 0)  ret.status = osOK;
000036  b114              CBZ      r4,|L40.62|
;;;615          else  ret.status = osEventTimeout;
000038  2040              MOVS     r0,#0x40
00003a  9000              STR      r0,[sp,#0]
00003c  e009              B        |L40.82|
                  |L40.62|
00003e  9600              STR      r6,[sp,#0]            ;614
000040  e007              B        |L40.82|
                  |L40.66|
;;;616        }
;;;617        else if(ret.value.signals < 0)
000042  9801              LDR      r0,[sp,#4]
000044  2800              CMP      r0,#0
000046  da02              BGE      |L40.78|
;;;618        {
;;;619          ret.status =  osErrorValue;     
000048  2086              MOVS     r0,#0x86
00004a  9000              STR      r0,[sp,#0]
00004c  e001              B        |L40.82|
                  |L40.78|
;;;620        }
;;;621        else  ret.status =  osEventSignal;
00004e  2008              MOVS     r0,#8
000050  9000              STR      r0,[sp,#0]
                  |L40.82|
;;;622      }
;;;623    #else
;;;624      (void) signals;
;;;625      (void) millisec;
;;;626    	
;;;627      ret.status =  osErrorOS;	/* Task Notification not supported */
;;;628    #endif
;;;629      
;;;630      return ret;
000052  e89d0007          LDM      sp,{r0-r2}
000056  c507              STM      r5!,{r0-r2}
;;;631    }
000058  bdfe              POP      {r1-r7,pc}
;;;632    
                          ENDP


                          AREA ||i.osSystickHandler||, CODE, READONLY, ALIGN=1

                  osSystickHandler PROC
;;;1407   */
;;;1408   void osSystickHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1409   {
;;;1410   
;;;1411   #if (INCLUDE_xTaskGetSchedulerState  == 1 )
;;;1412     if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d003              BEQ      |L41.18|
;;;1413     {
;;;1414   #endif  /* INCLUDE_xTaskGetSchedulerState */  
;;;1415       xPortSysTickHandler();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      xPortSysTickHandler
                  |L41.18|
;;;1416   #if (INCLUDE_xTaskGetSchedulerState  == 1 )
;;;1417     }
;;;1418   #endif  /* INCLUDE_xTaskGetSchedulerState */  
;;;1419   }
000012  bd10              POP      {r4,pc}
;;;1420   
                          ENDP


                          AREA ||i.osThreadCreate||, CODE, READONLY, ALIGN=1

                  osThreadCreate PROC
;;;244    */
;;;245    osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
000000  b53e              PUSH     {r1-r5,lr}
;;;246    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;247      TaskHandle_t handle;
;;;248      
;;;249    #if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;250      if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
;;;251        handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
;;;252                  thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
;;;253                  thread_def->buffer, thread_def->controlblock);
;;;254      }
;;;255      else {
;;;256        if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
;;;257                  thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
;;;258                  &handle) != pdPASS)  {
;;;259          return NULL;
;;;260        } 
;;;261      }
;;;262    #elif( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;263    
;;;264        handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
;;;265                  thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
;;;266                  thread_def->buffer, thread_def->controlblock);
;;;267    #else
;;;268      if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
000006  f9b40008          LDRSH    r0,[r4,#8]
00000a  f7fffffe          BL       makeFreeRtosPriority
00000e  a902              ADD      r1,sp,#8
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  8a20              LDRH     r0,[r4,#0x10]
000016  462b              MOV      r3,r5
000018  b282              UXTH     r2,r0
00001a  e9d41000          LDRD     r1,r0,[r4,#0]
00001e  f7fffffe          BL       xTaskCreate
000022  2801              CMP      r0,#1
000024  d001              BEQ      |L42.42|
;;;269                       thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
;;;270                       &handle) != pdPASS)  {
;;;271        return NULL;
000026  2000              MOVS     r0,#0
;;;272      }     
;;;273    #endif
;;;274      
;;;275      return handle;
;;;276    }
000028  bd3e              POP      {r1-r5,pc}
                  |L42.42|
00002a  9802              LDR      r0,[sp,#8]            ;275
00002c  bd3e              POP      {r1-r5,pc}
;;;277    
                          ENDP


                          AREA ||i.osThreadGetId||, CODE, READONLY, ALIGN=1

                  osThreadGetId PROC
;;;282    */
;;;283    osThreadId osThreadGetId (void)
000000  f7ffbffe          B.W      xTaskGetCurrentTaskHandle
;;;284    {
;;;285    #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
;;;286      return xTaskGetCurrentTaskHandle();
;;;287    #else
;;;288    	return NULL;
;;;289    #endif
;;;290    }
;;;291    
                          ENDP


                          AREA ||i.osThreadGetPriority||, CODE, READONLY, ALIGN=1

                  osThreadGetPriority PROC
;;;342    */
;;;343    osPriority osThreadGetPriority (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345    #if (INCLUDE_uxTaskPriorityGet == 1)
;;;346      if (inHandlerMode())
000004  f7fffffe          BL       inHandlerMode
000008  b130              CBZ      r0,|L44.24|
;;;347      {
;;;348        return makeCmsisPriority(uxTaskPriorityGetFromISR(thread_id));  
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       uxTaskPriorityGetFromISR
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      makeCmsisPriority
                  |L44.24|
;;;349      }
;;;350      else
;;;351      {  
;;;352        return makeCmsisPriority(uxTaskPriorityGet(thread_id));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       uxTaskPriorityGet
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      makeCmsisPriority
;;;353      }
;;;354    #else
;;;355      return osPriorityError;
;;;356    #endif
;;;357    }
;;;358    
                          ENDP


                          AREA ||i.osThreadList||, CODE, READONLY, ALIGN=1

                  osThreadList PROC
;;;1586   */
;;;1587   osStatus osThreadList (uint8_t *buffer)
000000  2000              MOVS     r0,#0
;;;1588   {
;;;1589   #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
;;;1590     vTaskList((char *)buffer);
;;;1591   #endif
;;;1592     return osOK;
;;;1593   }
000002  4770              BX       lr
;;;1594   
                          ENDP


                          AREA ||i.osThreadResume||, CODE, READONLY, ALIGN=2

                  osThreadResume PROC
;;;1493   */
;;;1494   osStatus osThreadResume (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;1495   {
000002  4604              MOV      r4,r0
;;;1496   #if (INCLUDE_vTaskSuspend == 1)  
;;;1497     if(inHandlerMode())
000004  f7fffffe          BL       inHandlerMode
000008  b160              CBZ      r0,|L46.36|
;;;1498     {
;;;1499       if (xTaskResumeFromISR(thread_id) == pdTRUE)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       xTaskResumeFromISR
000010  2801              CMP      r0,#1
000012  d10a              BNE      |L46.42|
;;;1500       {
;;;1501         portYIELD_FROM_ISR(pdTRUE);
000014  4906              LDR      r1,|L46.48|
000016  0700              LSLS     r0,r0,#28
000018  6008              STR      r0,[r1,#0]
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  e002              B        |L46.42|
                  |L46.36|
;;;1502       }
;;;1503     }
;;;1504     else
;;;1505     {
;;;1506       vTaskResume(thread_id);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       vTaskResume
                  |L46.42|
;;;1507     }
;;;1508     return osOK;
00002a  2000              MOVS     r0,#0
;;;1509   #else
;;;1510     return osErrorResource;
;;;1511   #endif
;;;1512   }
00002c  bd10              POP      {r4,pc}
;;;1513   
                          ENDP

00002e  0000              DCW      0x0000
                  |L46.48|
                          DCD      0xe000ed04

                          AREA ||i.osThreadResumeAll||, CODE, READONLY, ALIGN=1

                  osThreadResumeAll PROC
;;;1528   */
;;;1529   osStatus osThreadResumeAll (void)
000000  b510              PUSH     {r4,lr}
;;;1530   {
;;;1531     if (xTaskResumeAll() == pdTRUE)
000002  f7fffffe          BL       xTaskResumeAll
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L47.14|
;;;1532       return osOK;
;;;1533     else
;;;1534       return osErrorOS;
00000a  20ff              MOVS     r0,#0xff
;;;1535     
;;;1536   }
00000c  bd10              POP      {r4,pc}
                  |L47.14|
00000e  2000              MOVS     r0,#0                 ;1532
000010  bd10              POP      {r4,pc}
;;;1537   
                          ENDP


                          AREA ||i.osThreadSetPriority||, CODE, READONLY, ALIGN=1

                  osThreadSetPriority PROC
;;;326    */
;;;327    osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority)
000000  b510              PUSH     {r4,lr}
;;;328    {
000002  4604              MOV      r4,r0
000004  4608              MOV      r0,r1
;;;329    #if (INCLUDE_vTaskPrioritySet == 1)
;;;330      vTaskPrioritySet(thread_id, makeFreeRtosPriority(priority));
000006  f7fffffe          BL       makeFreeRtosPriority
00000a  4601              MOV      r1,r0
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       vTaskPrioritySet
;;;331      return osOK;
000012  2000              MOVS     r0,#0
;;;332    #else
;;;333      return osErrorOS;
;;;334    #endif
;;;335    }
000014  bd10              POP      {r4,pc}
;;;336    
                          ENDP


                          AREA ||i.osThreadSuspend||, CODE, READONLY, ALIGN=1

                  osThreadSuspend PROC
;;;1477   */
;;;1478   osStatus osThreadSuspend (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;1479   {
;;;1480   #if (INCLUDE_vTaskSuspend == 1)
;;;1481       vTaskSuspend(thread_id);
000002  f7fffffe          BL       vTaskSuspend
;;;1482     
;;;1483     return osOK;
000006  2000              MOVS     r0,#0
;;;1484   #else
;;;1485     return osErrorResource;
;;;1486   #endif
;;;1487   }
000008  bd10              POP      {r4,pc}
;;;1488   
                          ENDP


                          AREA ||i.osThreadSuspendAll||, CODE, READONLY, ALIGN=1

                  osThreadSuspendAll PROC
;;;1517   */
;;;1518   osStatus osThreadSuspendAll (void)
000000  b510              PUSH     {r4,lr}
;;;1519   {
;;;1520     vTaskSuspendAll();
000002  f7fffffe          BL       vTaskSuspendAll
;;;1521     
;;;1522     return osOK;
000006  2000              MOVS     r0,#0
;;;1523   }
000008  bd10              POP      {r4,pc}
;;;1524   
                          ENDP


                          AREA ||i.osThreadTerminate||, CODE, READONLY, ALIGN=1

                  osThreadTerminate PROC
;;;297    */
;;;298    osStatus osThreadTerminate (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300    #if (INCLUDE_vTaskDelete == 1)
;;;301      vTaskDelete(thread_id);
000002  f7fffffe          BL       vTaskDelete
;;;302      return osOK;
000006  2000              MOVS     r0,#0
;;;303    #else
;;;304      return osErrorOS;
;;;305    #endif
;;;306    }
000008  bd10              POP      {r4,pc}
;;;307    
                          ENDP


                          AREA ||i.osThreadYield||, CODE, READONLY, ALIGN=2

                  osThreadYield PROC
;;;312    */
;;;313    osStatus osThreadYield (void)
000000  4904              LDR      r1,|L52.20|
;;;314    {
;;;315      taskYIELD();
000002  f04f5080          MOV      r0,#0x10000000
000006  6008              STR      r0,[r1,#0]
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
;;;316      
;;;317      return osOK;
000010  2000              MOVS     r0,#0
;;;318    }
000012  4770              BX       lr
;;;319    
                          ENDP

                  |L52.20|
                          DCD      0xe000ed04

                          AREA ||i.osTimerCreate||, CODE, READONLY, ALIGN=1

                  osTimerCreate PROC
;;;399    */
;;;400    osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
000000  2000              MOVS     r0,#0
;;;401    {
;;;402    #if (configUSE_TIMERS == 1)
;;;403    
;;;404    #if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) 
;;;405      if(timer_def->controlblock != NULL) {
;;;406        return xTimerCreateStatic((const char *)"",
;;;407                          1, // period should be filled when starting the Timer using osTimerStart
;;;408                          (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
;;;409                          (void *) argument,
;;;410                          (TaskFunction_t)timer_def->ptimer,
;;;411                          (StaticTimer_t *)timer_def->controlblock);
;;;412      }
;;;413      else {
;;;414        return xTimerCreate((const char *)"",
;;;415                          1, // period should be filled when starting the Timer using osTimerStart
;;;416                          (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
;;;417                          (void *) argument,
;;;418                          (TaskFunction_t)timer_def->ptimer);
;;;419     }
;;;420    #elif( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;421      return xTimerCreateStatic((const char *)"",
;;;422                          1, // period should be filled when starting the Timer using osTimerStart
;;;423                          (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
;;;424                          (void *) argument,
;;;425                          (TaskFunction_t)timer_def->ptimer,
;;;426                          (StaticTimer_t *)timer_def->controlblock);  
;;;427    #else
;;;428      return xTimerCreate((const char *)"",
;;;429                          1, // period should be filled when starting the Timer using osTimerStart
;;;430                          (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
;;;431                          (void *) argument,
;;;432                          (TaskFunction_t)timer_def->ptimer);
;;;433    #endif
;;;434    
;;;435    #else 
;;;436    	return NULL;
;;;437    #endif
;;;438    }
000002  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.osTimerDelete||, CODE, READONLY, ALIGN=1

                  osTimerDelete PROC
;;;514    */
;;;515    osStatus osTimerDelete (osTimerId timer_id)
000000  20ff              MOVS     r0,#0xff
;;;516    {
;;;517    osStatus result = osOK;
;;;518    
;;;519    #if (configUSE_TIMERS == 1)
;;;520    
;;;521       if (inHandlerMode()) {
;;;522         return osErrorISR;
;;;523      }
;;;524      else { 
;;;525        if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {
;;;526          result = osErrorOS;
;;;527        }
;;;528      } 
;;;529        
;;;530    #else 
;;;531      result = osErrorOS;
;;;532    #endif 
;;;533     
;;;534      return result;
;;;535    }
000002  4770              BX       lr
;;;536    
                          ENDP


                          AREA ||i.osTimerStart||, CODE, READONLY, ALIGN=1

                  osTimerStart PROC
;;;446    */
;;;447    osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
000000  20ff              MOVS     r0,#0xff
;;;448    {
;;;449      osStatus result = osOK;
;;;450    #if (configUSE_TIMERS == 1)  
;;;451      portBASE_TYPE taskWoken = pdFALSE;
;;;452      TickType_t ticks = millisec / portTICK_PERIOD_MS;
;;;453    
;;;454      if (ticks == 0)
;;;455        ticks = 1;
;;;456        
;;;457      if (inHandlerMode()) 
;;;458      {
;;;459        if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
;;;460        {
;;;461          result = osErrorOS;
;;;462        }
;;;463        else
;;;464        {
;;;465          portEND_SWITCHING_ISR(taskWoken);     
;;;466        }
;;;467      }
;;;468      else 
;;;469      {
;;;470        if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
;;;471          result = osErrorOS;
;;;472      }
;;;473    
;;;474    #else 
;;;475      result = osErrorOS;
;;;476    #endif
;;;477      return result;
;;;478    }
000002  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.osTimerStop||, CODE, READONLY, ALIGN=1

                  osTimerStop PROC
;;;485    */
;;;486    osStatus osTimerStop (osTimerId timer_id)
000000  20ff              MOVS     r0,#0xff
;;;487    {
;;;488      osStatus result = osOK;
;;;489    #if (configUSE_TIMERS == 1)  
;;;490      portBASE_TYPE taskWoken = pdFALSE;
;;;491    
;;;492      if (inHandlerMode()) {
;;;493        if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
;;;494          return osErrorOS;
;;;495        }
;;;496        portEND_SWITCHING_ISR(taskWoken);
;;;497      }
;;;498      else {
;;;499        if (xTimerStop(timer_id, 0) != pdPASS) {
;;;500          result = osErrorOS;
;;;501        }
;;;502      }
;;;503    #else 
;;;504      result = osErrorOS;
;;;505    #endif 
;;;506      return result;
;;;507    }
000002  4770              BX       lr
;;;508    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_cmsis_os_c_9292335d____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___10_cmsis_os_c_9292335d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_cmsis_os_c_9292335d____REVSH|
#line 402
|__asm___10_cmsis_os_c_9292335d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
