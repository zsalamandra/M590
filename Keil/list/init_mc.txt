; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -ogsm_stm32f103\init_mc.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\init_mc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS -IE:\MC\2.STM32\STMProjects\GSM\M590\Project\Keil\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=gsm_stm32f103\init_mc.crf ..\Src\init_mc.c]
                          THUMB

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1453   {
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1455   }
000014  4770              BX       lr
;;;1456   
                          ENDP


                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=2

                  SetSysClock PROC
;;;61     
;;;62     static void SetSysClock(void){
000000  b50c              PUSH     {r2,r3,lr}
;;;63     	
;;;64     	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;65     	
;;;66     	RCC->CR &= (~(uint32_t)RCC_CR_HSION);
000008  4824              LDR      r0,|L2.156|
00000a  6801              LDR      r1,[r0,#0]
00000c  f0210101          BIC      r1,r1,#1
000010  6001              STR      r1,[r0,#0]
;;;67     	/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;68     	/* Enable HSE */    
;;;69     	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000012  6801              LDR      r1,[r0,#0]
000014  f4413180          ORR      r1,r1,#0x10000
000018  6001              STR      r1,[r0,#0]
                  |L2.26|
;;;70     	
;;;71     	/* Wait till HSE is ready and if Time out is reached exit */
;;;72     	do
;;;73     	{
;;;74     		HSEStatus = RCC->CR & RCC_CR_HSERDY;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4013100          AND      r1,r1,#0x20000
000020  9100              STR      r1,[sp,#0]
;;;75     		StartUpCounter++;  
000022  9901              LDR      r1,[sp,#4]
000024  1c49              ADDS     r1,r1,#1
000026  9101              STR      r1,[sp,#4]
;;;76     	} while((HSEStatus == 0) && (StartUpCounter != (uint32_t)100));
000028  9900              LDR      r1,[sp,#0]
00002a  b911              CBNZ     r1,|L2.50|
00002c  9901              LDR      r1,[sp,#4]
00002e  2964              CMP      r1,#0x64
000030  d1f3              BNE      |L2.26|
                  |L2.50|
;;;77     
;;;78     	if (RCC->CR & RCC_CR_HSERDY)
000032  6801              LDR      r1,[r0,#0]
000034  0389              LSLS     r1,r1,#14
000036  d530              BPL      |L2.154|
;;;79     	{
;;;80     		/* Enable Prefetch Buffer */
;;;81     		FLASH->ACR |= FLASH_ACR_PRFTBE;
000038  4919              LDR      r1,|L2.160|
00003a  680a              LDR      r2,[r1,#0]
00003c  f0420210          ORR      r2,r2,#0x10
000040  600a              STR      r2,[r1,#0]
;;;82     
;;;83     		/* Flash 2 wait state */
;;;84     		FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000042  680a              LDR      r2,[r1,#0]
000044  f0220207          BIC      r2,r2,#7
000048  600a              STR      r2,[r1,#0]
;;;85     		FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
00004a  680a              LDR      r2,[r1,#0]
00004c  f0420204          ORR      r2,r2,#4
000050  600a              STR      r2,[r1,#0]
;;;86     
;;;87     	 
;;;88     		/* 	HPRE(AHB prescaler) Ч значение этих битов определ€ет коэффициент 
;;;89     			делени€ тактовой частоты дл€ AHB. 
;;;90     			RCC_CFGR_HPRE_DIV1 = 0 (делитель не используетс€)
;;;91     		*/
;;;92     		RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
000052  6841              LDR      r1,[r0,#4]
000054  6041              STR      r1,[r0,#4]
;;;93     		  
;;;94     		/* 	PPRE2(APB high-speed prescaler (APB2)) Ч значение этих битов 
;;;95     			определ€ет коэффициент делени€ тактовой частоты дл€ APB2. */
;;;96     		RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000056  6841              LDR      r1,[r0,#4]
000058  6041              STR      r1,[r0,#4]
;;;97     		
;;;98     		/* 	PPRE1(APB low-speed prescaler (APB1)) Ч значение этих битов 
;;;99     			определ€ет коэффициент делени€ тактовой частоты дл€ APB1. */
;;;100    		RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;	
00005a  6841              LDR      r1,[r0,#4]
00005c  f4416180          ORR      r1,r1,#0x400
000060  6041              STR      r1,[r0,#4]
;;;101    		
;;;102    		
;;;103    		/* 	сброс битов RCC_CFGR_PLLSRC, RCC_CFGR_PLLXTPRE, RCC_CFGR_PLLMULL	  */
;;;104    
;;;105    		/* 	PLLSRC(PLL entry clock source) Ч значение этого бита определ€ет с 
;;;106    			какого источника будет подан сигнал на вход PLL.(
;;;107    			0 Ц источник HSI/2, 
;;;108    			1 Ц источник HSE)
;;;109    		
;;;110    			PLLXTPRE(HSE divider for PLL entry) Ч значение этого бита 
;;;111    			определ€ет будет ли HSE поделен на два, перед подачей на вход PLL. 
;;;112    			”станавливать его нужно при отключенной PLL.
;;;113    			
;;;114    			PLLMUL(PLL multiplication factor) Ч значение этих битов определ€ет 
;;;115    			коэффициент умножени€ PLL.
;;;116    			
;;;117    			ADCPRE(ADC prescaler) Ч значение этих битов определ€ет коэффициент 
;;;118    			делени€ тактовой частоты дл€ ј÷ѕ.
;;;119    		*/
;;;120    		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000062  6841              LDR      r1,[r0,#4]
000064  f421117c          BIC      r1,r1,#0x3f0000
000068  6041              STR      r1,[r0,#4]
;;;121    											RCC_CFGR_PLLMULL));
;;;122    		
;;;123    		/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */											
;;;124    		RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL9);	
00006a  6841              LDR      r1,[r0,#4]
00006c  f44111e8          ORR      r1,r1,#0x1d0000
000070  6041              STR      r1,[r0,#4]
;;;125    		
;;;126    		/* Enable PLL */
;;;127    		RCC->CR |= RCC_CR_PLLON;
000072  6801              LDR      r1,[r0,#0]
000074  f0417180          ORR      r1,r1,#0x1000000
000078  6001              STR      r1,[r0,#0]
                  |L2.122|
;;;128    		
;;;129    		/* Wait till PLL is ready */
;;;130    		while((RCC->CR & RCC_CR_PLLRDY) == 0)
00007a  6801              LDR      r1,[r0,#0]
00007c  0189              LSLS     r1,r1,#6
00007e  d5fc              BPL      |L2.122|
;;;131    		{
;;;132    		}
;;;133    		
;;;134    		/* источником тактирвани€  */
;;;135    		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
000080  6841              LDR      r1,[r0,#4]
000082  f0210103          BIC      r1,r1,#3
000086  6041              STR      r1,[r0,#4]
;;;136    		RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
000088  6841              LDR      r1,[r0,#4]
00008a  f0410102          ORR      r1,r1,#2
00008e  6041              STR      r1,[r0,#4]
                  |L2.144|
;;;137    		
;;;138    		/* Wait till PLL is used as system clock source */
;;;139    		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
000090  6841              LDR      r1,[r0,#4]
000092  f3c10181          UBFX     r1,r1,#2,#2
000096  2902              CMP      r1,#2
000098  d1fa              BNE      |L2.144|
                  |L2.154|
;;;140    		{
;;;141    		}		
;;;142    	}		
;;;143    }
00009a  bd0c              POP      {r2,r3,pc}
;;;144    	
                          ENDP

                  |L2.156|
                          DCD      0x40021000
                  |L2.160|
                          DCD      0x40022000

                          AREA ||i.initNVIC||, CODE, READONLY, ALIGN=2

                  initNVIC PROC
;;;47     /*********************** NVIC INIT  *******************************************/
;;;48     static void initNVIC(void){
000000  b510              PUSH     {r4,lr}
000002  4905              LDR      r1,|L3.24|
000004  2050              MOVS     r0,#0x50
000006  7008              STRB     r0,[r1,#0]
;;;49         
;;;50         /* RCC_IRQn interrupt configuration */
;;;51         NVIC_SetPriority(RCC_IRQn, 5);  
;;;52         NVIC_EnableIRQ(RCC_IRQn);
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       NVIC_EnableIRQ
;;;53         
;;;54         /* TIM4_IRQn interrupt configuration */
;;;55         NVIC_EnableIRQ(TIM4_IRQn);    
00000e  e8bd4010          POP      {r4,lr}
000012  201e              MOVS     r0,#0x1e
000014  f7ffbffe          B.W      NVIC_EnableIRQ
;;;56     }
;;;57     
                          ENDP

                  |L3.24|
                          DCD      0xe000e405

                          AREA ||i.initTim2BaseMode||, CODE, READONLY, ALIGN=2

                  initTim2BaseMode PROC
;;;29     
;;;30     static void initTim2BaseMode(void){
000000  480a              LDR      r0,|L4.44|
;;;31     	
;;;32     	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; 
000002  69c1              LDR      r1,[r0,#0x1c]
000004  f0410101          ORR      r1,r1,#1
000008  61c1              STR      r1,[r0,#0x1c]
;;;33     	
;;;34         TIM2->PSC = 36000-1;//частота 1Khz
00000a  0480              LSLS     r0,r0,#18
00000c  f648419f          MOV      r1,#0x8c9f
000010  6281              STR      r1,[r0,#0x28]
;;;35     	TIM2->ARR = 2000-1;
000012  f24071cf          MOV      r1,#0x7cf
000016  62c1              STR      r1,[r0,#0x2c]
;;;36     
;;;37         //TIM4->CCER |= TIM_CCER_CC4P;//выбираем захват по заднему фронту
;;;38         //TIM4->CCER |= TIM_CCER_CC4E;//включаем режим захвата дл€ 4-го канала         
;;;39     
;;;40         //TIM4->DIER |= TIM_DIER_CC4DE;//разрешаем формировать запрос к DMA
;;;41         TIM2->DIER |= TIM_DIER_UIE; //разрешаем прерывание по захвату
000018  68c1              LDR      r1,[r0,#0xc]
00001a  f0410101          ORR      r1,r1,#1
00001e  60c1              STR      r1,[r0,#0xc]
;;;42     
;;;43         TIM2->CR1 |= TIM_CR1_CEN; //включаем счЄтчик
000020  6801              LDR      r1,[r0,#0]
000022  f0410101          ORR      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
;;;44     }
000028  4770              BX       lr
;;;45     
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40021000

                          AREA ||i.initTim4CaptureMode||, CODE, READONLY, ALIGN=2

                  initTim4CaptureMode PROC
;;;8      
;;;9      static void initTim4CaptureMode(void){
000000  4813              LDR      r0,|L5.80|
;;;10       
;;;11     	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN; 
000002  69c1              LDR      r1,[r0,#0x1c]
000004  f0410104          ORR      r1,r1,#4
000008  61c1              STR      r1,[r0,#0x1c]
;;;12     	
;;;13         TIM4->PSC = 72000-1;//частота 1Khz
00000a  4913              LDR      r1,|L5.88|
00000c  4811              LDR      r0,|L5.84|
00000e  6008              STR      r0,[r1,#0]
;;;14     
;;;15         //выбираем TI4 дл€ TIM5_CH4
;;;16         TIM4->CCMR2 |= TIM_CCMR2_CC4S_0;
000010  4811              LDR      r0,|L5.88|
000012  380c              SUBS     r0,r0,#0xc
000014  6801              LDR      r1,[r0,#0]
000016  f4417180          ORR      r1,r1,#0x100
00001a  6001              STR      r1,[r0,#0]
;;;17         //не фильтруем и делитель не используем
;;;18         TIM4->CCMR2 &= ~(TIM_CCMR2_IC4F | TIM_CCMR2_IC4PSC);
00001c  6801              LDR      r1,[r0,#0]
00001e  f421417c          BIC      r1,r1,#0xfc00
000022  6001              STR      r1,[r0,#0]
;;;19     
;;;20         TIM4->CCER |= TIM_CCER_CC4P;//выбираем захват по заднему фронту
000024  1d00              ADDS     r0,r0,#4
000026  6801              LDR      r1,[r0,#0]
000028  f4415100          ORR      r1,r1,#0x2000
00002c  6001              STR      r1,[r0,#0]
;;;21         TIM4->CCER |= TIM_CCER_CC4E;//включаем режим захвата дл€ 4-го канала         
00002e  6801              LDR      r1,[r0,#0]
000030  f4415180          ORR      r1,r1,#0x1000
000034  6001              STR      r1,[r0,#0]
;;;22     
;;;23         //TIM4->DIER |= TIM_DIER_CC4DE;//разрешаем формировать запрос к DMA
;;;24         TIM4->DIER |= TIM_DIER_CC4IE; //разрешаем прерывание по захвату
000036  4808              LDR      r0,|L5.88|
000038  381c              SUBS     r0,r0,#0x1c
00003a  6801              LDR      r1,[r0,#0]
00003c  f0410110          ORR      r1,r1,#0x10
000040  6001              STR      r1,[r0,#0]
;;;25     
;;;26         TIM4->CR1 |= TIM_CR1_CEN; //включаем счЄтчик
000042  4805              LDR      r0,|L5.88|
000044  3828              SUBS     r0,r0,#0x28
000046  6801              LDR      r1,[r0,#0]
000048  f0410101          ORR      r1,r1,#1
00004c  6001              STR      r1,[r0,#0]
;;;27     }
00004e  4770              BX       lr
;;;28     
                          ENDP

                  |L5.80|
                          DCD      0x40021000
                  |L5.84|
                          DCD      0x0001193f
                  |L5.88|
                          DCD      0x40000828

                          AREA ||i.init_mc||, CODE, READONLY, ALIGN=2

                  init_mc PROC
;;;146    
;;;147    void init_mc(void){
000000  b510              PUSH     {r4,lr}
;;;148        
;;;149    	SetSysClock();
000002  f7fffffe          BL       SetSysClock
;;;150        // включение тактировани€ альтернативных функций
;;;151    	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
000006  480a              LDR      r0,|L6.48|
000008  6981              LDR      r1,[r0,#0x18]
00000a  f0410101          ORR      r1,r1,#1
00000e  6181              STR      r1,[r0,#0x18]
;;;152        // отключение режима отладки JTUG
;;;153    	AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE;      
000010  4808              LDR      r0,|L6.52|
000012  6841              LDR      r1,[r0,#4]
000014  f0417100          ORR      r1,r1,#0x2000000
000018  6041              STR      r1,[r0,#4]
;;;154        
;;;155        initTim4CaptureMode();
00001a  f7fffffe          BL       initTim4CaptureMode
;;;156    	initTim2BaseMode();
00001e  f7fffffe          BL       initTim2BaseMode
;;;157        initNVIC();
000022  f7fffffe          BL       initNVIC
;;;158        init_gpio();
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      init_gpio
;;;159        
;;;160    }
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40021000
                  |L6.52|
                          DCD      0x40010000

;*** Start embedded assembler ***

#line 1 "..\\Src\\init_mc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_init_mc_c_init_mc____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___9_init_mc_c_init_mc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_init_mc_c_init_mc____REVSH|
#line 402
|__asm___9_init_mc_c_init_mc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_init_mc_c_init_mc____RRX|
#line 587
|__asm___9_init_mc_c_init_mc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
