; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -ogsm_stm32f103\stm32f1xx_hal_tim_ex.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\stm32f1xx_hal_tim_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS -IE:\MC\2.STM32\STMProjects\GSM\M590\Project\Keil\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=gsm_stm32f103\stm32f1xx_hal_tim_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1743     */
;;;1744   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1745   {
;;;1746     /* Prevent unused argument(s) compilation warning */
;;;1747     UNUSED(htim);
;;;1748     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1749               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1750      */
;;;1751   }
;;;1752   
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutationCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutationCallback PROC
;;;1729     */
;;;1730   __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1731   {
;;;1732     /* Prevent unused argument(s) compilation warning */
;;;1733     UNUSED(htim);
;;;1734     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1735               the HAL_TIMEx_CommutationCallback could be implemented in the user file
;;;1736      */
;;;1737   }
;;;1738   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1625     */
;;;1626   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
000000  b510              PUSH     {r4,lr}
;;;1627                                                   TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
;;;1628   {
;;;1629     uint32_t tmpbdtr = 0U;
;;;1630   
;;;1631     /* Check the parameters */
;;;1632     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1633     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1634     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1635     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1636     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1637     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1638     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1639     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1640   
;;;1641     /* Process Locked */
;;;1642     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d025              BEQ      |L3.86|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;1643   
;;;1644     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1645        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1646     
;;;1647     /* Set the BDTR bits */
;;;1648     MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
000010  68ca              LDR      r2,[r1,#0xc]
000012  2300              MOVS     r3,#0
;;;1649     MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
000014  688c              LDR      r4,[r1,#8]
000016  f4227240          BIC      r2,r2,#0x300
00001a  4322              ORRS     r2,r2,r4
;;;1650     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
00001c  684c              LDR      r4,[r1,#4]
00001e  f4226280          BIC      r2,r2,#0x400
000022  4322              ORRS     r2,r2,r4
;;;1651     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
000024  680c              LDR      r4,[r1,#0]
000026  f4226200          BIC      r2,r2,#0x800
00002a  4322              ORRS     r2,r2,r4
;;;1652     MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
00002c  690c              LDR      r4,[r1,#0x10]
00002e  f4225280          BIC      r2,r2,#0x1000
000032  4322              ORRS     r2,r2,r4
;;;1653     MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
000034  694c              LDR      r4,[r1,#0x14]
000036  f4225200          BIC      r2,r2,#0x2000
00003a  4322              ORRS     r2,r2,r4
;;;1654     MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
00003c  6989              LDR      r1,[r1,#0x18]
00003e  f4224280          BIC      r2,r2,#0x4000
000042  430a              ORRS     r2,r2,r1
;;;1655     MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
000044  f4224200          BIC      r2,r2,#0x8000
000048  430a              ORRS     r2,r2,r1
;;;1656     
;;;1657     /* Set TIMx_BDTR */
;;;1658     htim->Instance->BDTR = tmpbdtr;
00004a  6801              LDR      r1,[r0,#0]
00004c  644a              STR      r2,[r1,#0x44]
;;;1659     
;;;1660     __HAL_UNLOCK(htim);
00004e  f880303c          STRB     r3,[r0,#0x3c]
;;;1661   
;;;1662     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;1663   }
000054  bd10              POP      {r4,pc}
                  |L3.86|
000056  2002              MOVS     r0,#2                 ;1642
000058  bd10              POP      {r4,pc}
;;;1664   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent PROC
;;;1479     */
;;;1480   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1481   {
;;;1482     /* Check the parameters */
;;;1483     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1484     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1485   
;;;1486     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L4.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L4.36|
;;;1487   
;;;1488     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L4.36|
;;;1489         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L4.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L4.36|
00001e  e00a              B        |L4.54|
                  |L4.32|
000020  2002              MOVS     r0,#2                 ;1486
;;;1490     {
;;;1491       /* Select the Input trigger */
;;;1492       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1493       htim->Instance->SMCR |= InputTrigger;
;;;1494     }
;;;1495   
;;;1496     /* Select the Capture Compare preload feature */
;;;1497     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1498     /* Select the Commutation event source */
;;;1499     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1500     htim->Instance->CR2 |= CommutationSource;
;;;1501   
;;;1502     __HAL_UNLOCK(htim);
;;;1503   
;;;1504     return HAL_OK;
;;;1505   }
000022  bd10              POP      {r4,pc}
                  |L4.36|
000024  6803              LDR      r3,[r0,#0]            ;1492
000026  689c              LDR      r4,[r3,#8]            ;1492
000028  f0240470          BIC      r4,r4,#0x70           ;1492
00002c  609c              STR      r4,[r3,#8]            ;1492
00002e  6803              LDR      r3,[r0,#0]            ;1493
000030  689c              LDR      r4,[r3,#8]            ;1493
000032  430c              ORRS     r4,r4,r1              ;1493
000034  609c              STR      r4,[r3,#8]            ;1493
                  |L4.54|
000036  6801              LDR      r1,[r0,#0]            ;1497
000038  684b              LDR      r3,[r1,#4]            ;1497
00003a  f0430301          ORR      r3,r3,#1              ;1497
00003e  604b              STR      r3,[r1,#4]            ;1497
000040  6801              LDR      r1,[r0,#0]            ;1499
000042  684b              LDR      r3,[r1,#4]            ;1499
000044  f0230304          BIC      r3,r3,#4              ;1499
000048  604b              STR      r3,[r1,#4]            ;1499
00004a  6801              LDR      r1,[r0,#0]            ;1500
00004c  684b              LDR      r3,[r1,#4]            ;1500
00004e  4313              ORRS     r3,r3,r2              ;1500
000050  604b              STR      r3,[r1,#4]            ;1500
000052  2100              MOVS     r1,#0                 ;1502
000054  f880103c          STRB     r1,[r0,#0x3c]         ;1502
000058  2000              MOVS     r0,#0                 ;1504
00005a  bd10              POP      {r4,pc}
;;;1506   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutationEvent_DMA PROC
;;;1581     */
;;;1582   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1583   {
;;;1584     /* Check the parameters */
;;;1585     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1586     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1587   
;;;1588     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L5.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L5.36|
;;;1589   
;;;1590     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L5.36|
;;;1591         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L5.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L5.36|
00001e  e00a              B        |L5.54|
                  |L5.32|
000020  2002              MOVS     r0,#2                 ;1588
;;;1592     {
;;;1593       /* Select the Input trigger */
;;;1594       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1595       htim->Instance->SMCR |= InputTrigger;
;;;1596     }
;;;1597   
;;;1598     /* Select the Capture Compare preload feature */
;;;1599     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1600     /* Select the Commutation event source */
;;;1601     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1602     htim->Instance->CR2 |= CommutationSource;
;;;1603   
;;;1604     /* Enable the Commutation DMA Request */
;;;1605     /* Set the DMA Commutation Callback */
;;;1606     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;1607     /* Set the DMA error callback */
;;;1608     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
;;;1609   
;;;1610     /* Enable the Commutation DMA Request */
;;;1611     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1612   
;;;1613     __HAL_UNLOCK(htim);
;;;1614   
;;;1615     return HAL_OK;
;;;1616   }
000022  bd10              POP      {r4,pc}
                  |L5.36|
000024  6803              LDR      r3,[r0,#0]            ;1594
000026  689c              LDR      r4,[r3,#8]            ;1594
000028  f0240470          BIC      r4,r4,#0x70           ;1594
00002c  609c              STR      r4,[r3,#8]            ;1594
00002e  6803              LDR      r3,[r0,#0]            ;1595
000030  689c              LDR      r4,[r3,#8]            ;1595
000032  430c              ORRS     r4,r4,r1              ;1595
000034  609c              STR      r4,[r3,#8]            ;1595
                  |L5.54|
000036  6801              LDR      r1,[r0,#0]            ;1599
000038  684b              LDR      r3,[r1,#4]            ;1599
00003a  f0430301          ORR      r3,r3,#1              ;1599
00003e  604b              STR      r3,[r1,#4]            ;1599
000040  6801              LDR      r1,[r0,#0]            ;1601
000042  684b              LDR      r3,[r1,#4]            ;1601
000044  f0230304          BIC      r3,r3,#4              ;1601
000048  604b              STR      r3,[r1,#4]            ;1601
00004a  6801              LDR      r1,[r0,#0]            ;1602
00004c  684b              LDR      r3,[r1,#4]            ;1602
00004e  4313              ORRS     r3,r3,r2              ;1602
000050  604b              STR      r3,[r1,#4]            ;1602
000052  6b42              LDR      r2,[r0,#0x34]         ;1606
000054  4907              LDR      r1,|L5.116|
000056  6291              STR      r1,[r2,#0x28]         ;1606
000058  6b42              LDR      r2,[r0,#0x34]         ;1608
00005a  4907              LDR      r1,|L5.120|
00005c  6311              STR      r1,[r2,#0x30]         ;1608
00005e  6801              LDR      r1,[r0,#0]            ;1611
000060  68ca              LDR      r2,[r1,#0xc]          ;1611
000062  f4425200          ORR      r2,r2,#0x2000         ;1611
000066  60ca              STR      r2,[r1,#0xc]          ;1611
000068  2100              MOVS     r1,#0                 ;1613
00006a  f880103c          STRB     r1,[r0,#0x3c]         ;1613
00006e  2000              MOVS     r0,#0                 ;1615
000070  bd10              POP      {r4,pc}
;;;1617   
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      TIMEx_DMACommutationCplt
                  |L5.120|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent_IT PROC
;;;1528     */
;;;1529   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1530   {
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1533     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1534   
;;;1535     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L6.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L6.36|
;;;1536   
;;;1537     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L6.36|
;;;1538         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L6.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L6.36|
00001e  e00a              B        |L6.54|
                  |L6.32|
000020  2002              MOVS     r0,#2                 ;1535
;;;1539     {
;;;1540       /* Select the Input trigger */
;;;1541       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1542       htim->Instance->SMCR |= InputTrigger;
;;;1543     }
;;;1544   
;;;1545     /* Select the Capture Compare preload feature */
;;;1546     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1547     /* Select the Commutation event source */
;;;1548     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1549     htim->Instance->CR2 |= CommutationSource;
;;;1550   
;;;1551     /* Enable the Commutation Interrupt Request */
;;;1552     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1553   
;;;1554     __HAL_UNLOCK(htim);
;;;1555   
;;;1556     return HAL_OK;
;;;1557   }
000022  bd10              POP      {r4,pc}
                  |L6.36|
000024  6803              LDR      r3,[r0,#0]            ;1541
000026  689c              LDR      r4,[r3,#8]            ;1541
000028  f0240470          BIC      r4,r4,#0x70           ;1541
00002c  609c              STR      r4,[r3,#8]            ;1541
00002e  6803              LDR      r3,[r0,#0]            ;1542
000030  689c              LDR      r4,[r3,#8]            ;1542
000032  430c              ORRS     r4,r4,r1              ;1542
000034  609c              STR      r4,[r3,#8]            ;1542
                  |L6.54|
000036  6801              LDR      r1,[r0,#0]            ;1546
000038  684b              LDR      r3,[r1,#4]            ;1546
00003a  f0430301          ORR      r3,r3,#1              ;1546
00003e  604b              STR      r3,[r1,#4]            ;1546
000040  6801              LDR      r1,[r0,#0]            ;1548
000042  684b              LDR      r3,[r1,#4]            ;1548
000044  f0230304          BIC      r3,r3,#4              ;1548
000048  604b              STR      r3,[r1,#4]            ;1548
00004a  6801              LDR      r1,[r0,#0]            ;1549
00004c  684b              LDR      r3,[r1,#4]            ;1549
00004e  4313              ORRS     r3,r3,r2              ;1549
000050  604b              STR      r3,[r1,#4]            ;1549
000052  6801              LDR      r1,[r0,#0]            ;1552
000054  68ca              LDR      r2,[r1,#0xc]          ;1552
000056  f0420220          ORR      r2,r2,#0x20           ;1552
00005a  60ca              STR      r2,[r1,#0xc]          ;1552
00005c  2100              MOVS     r1,#0                 ;1554
00005e  f880103c          STRB     r1,[r0,#0x3c]         ;1554
000062  2000              MOVS     r0,#0                 ;1556
000064  bd10              POP      {r4,pc}
;;;1558   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;245      */
;;;246    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248      /* Check the parameters */
;;;249      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;250    
;;;251      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;252    
;;;253      /* Disable the TIM Peripheral Clock */
;;;254      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L7.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L7.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L7.38|
;;;255    
;;;256      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;257      HAL_TIMEx_HallSensor_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;258    
;;;259      /* Change TIM state */
;;;260      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;261    
;;;262      /* Release Lock */
;;;263      __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;264    
;;;265      return HAL_OK;
;;;266    }
000034  bd10              POP      {r4,pc}
;;;267    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;1794     */
;;;1795   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;1796   {
;;;1797     return htim->State;
;;;1798   }
000004  4770              BX       lr
;;;1799   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Init PROC
;;;166      */
;;;167    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;169      TIM_OC_InitTypeDef OC_Config;
;;;170    
;;;171      /* Check the TIM handle allocation */
;;;172      if(htim == NULL)
000008  2c00              CMP      r4,#0
00000a  d004              BEQ      |L9.22|
;;;173      {
;;;174        return HAL_ERROR;
;;;175      }
;;;176    
;;;177      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;178      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;179      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;180      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;181      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;182      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;183      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;184    
;;;185      if(htim->State == HAL_TIM_STATE_RESET)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2600              MOVS     r6,#0
000012  b118              CBZ      r0,|L9.28|
000014  e007              B        |L9.38|
                  |L9.22|
000016  2001              MOVS     r0,#1                 ;174
                  |L9.24|
;;;186      {
;;;187        /* Allocate lock resource and initialize it */
;;;188        htim->Lock = HAL_UNLOCKED;
;;;189        
;;;190        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;191        HAL_TIMEx_HallSensor_MspInit(htim);
;;;192      }
;;;193    
;;;194      /* Set the TIM state */
;;;195      htim->State= HAL_TIM_STATE_BUSY;
;;;196    
;;;197      /* Configure the Time base in the Encoder Mode */
;;;198      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;199    
;;;200      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;201      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;202    
;;;203      /* Reset the IC1PSC Bits */
;;;204      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;205      /* Set the IC1PSC value */
;;;206      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;207    
;;;208      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;209      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;210    
;;;211      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;212      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;213      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;214    
;;;215      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
;;;216      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;217      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;218    
;;;219      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;220      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;221      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;222      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;223      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;224      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;225      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;226      OC_Config.Pulse = sConfig->Commutation_Delay;
;;;227    
;;;228      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;229    
;;;230      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;231        register to 101 */
;;;232      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;233      htim->Instance->CR2 |= TIM_TRGO_OC2REF;
;;;234    
;;;235      /* Initialize the TIM state*/
;;;236      htim->State= HAL_TIM_STATE_READY;
;;;237    
;;;238      return HAL_OK;
;;;239    }
000018  b008              ADD      sp,sp,#0x20
00001a  bd70              POP      {r4-r6,pc}
                  |L9.28|
00001c  f884603c          STRB     r6,[r4,#0x3c]         ;188
000020  4620              MOV      r0,r4                 ;191
000022  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
                  |L9.38|
000026  2002              MOVS     r0,#2                 ;195
000028  f884003d          STRB     r0,[r4,#0x3d]         ;195
00002c  1d21              ADDS     r1,r4,#4              ;198
00002e  6820              LDR      r0,[r4,#0]            ;198
000030  f7fffffe          BL       TIM_Base_SetConfig
000034  68ab              LDR      r3,[r5,#8]            ;201
000036  6829              LDR      r1,[r5,#0]            ;201
000038  2203              MOVS     r2,#3                 ;201
00003a  6820              LDR      r0,[r4,#0]            ;201
00003c  f7fffffe          BL       TIM_TI1_SetConfig
000040  6820              LDR      r0,[r4,#0]            ;204
000042  6981              LDR      r1,[r0,#0x18]         ;204
000044  f021010c          BIC      r1,r1,#0xc            ;204
000048  6181              STR      r1,[r0,#0x18]         ;204
00004a  6820              LDR      r0,[r4,#0]            ;206
00004c  6981              LDR      r1,[r0,#0x18]         ;206
00004e  686a              LDR      r2,[r5,#4]            ;206
000050  4311              ORRS     r1,r1,r2              ;206
000052  6181              STR      r1,[r0,#0x18]         ;206
000054  6820              LDR      r0,[r4,#0]            ;209
000056  6841              LDR      r1,[r0,#4]            ;209
000058  f0410180          ORR      r1,r1,#0x80           ;209
00005c  6041              STR      r1,[r0,#4]            ;209
00005e  6820              LDR      r0,[r4,#0]            ;212
000060  6881              LDR      r1,[r0,#8]            ;212
000062  f0210170          BIC      r1,r1,#0x70           ;212
000066  6081              STR      r1,[r0,#8]            ;212
000068  6820              LDR      r0,[r4,#0]            ;213
00006a  6881              LDR      r1,[r0,#8]            ;213
00006c  f0410140          ORR      r1,r1,#0x40           ;213
000070  6081              STR      r1,[r0,#8]            ;213
000072  6820              LDR      r0,[r4,#0]            ;216
000074  6881              LDR      r1,[r0,#8]            ;216
000076  f0210107          BIC      r1,r1,#7              ;216
00007a  6081              STR      r1,[r0,#8]            ;216
00007c  6820              LDR      r0,[r4,#0]            ;217
00007e  6881              LDR      r1,[r0,#8]            ;217
000080  f0410104          ORR      r1,r1,#4              ;217
000084  6081              STR      r1,[r0,#8]            ;217
000086  9605              STR      r6,[sp,#0x14]         ;220
000088  9606              STR      r6,[sp,#0x18]         ;221
00008a  2070              MOVS     r0,#0x70              ;222
00008c  9001              STR      r0,[sp,#4]            ;222
00008e  9607              STR      r6,[sp,#0x1c]         ;223
000090  9604              STR      r6,[sp,#0x10]         ;224
000092  9603              STR      r6,[sp,#0xc]          ;225
000094  68e8              LDR      r0,[r5,#0xc]          ;226
000096  9002              STR      r0,[sp,#8]            ;226
000098  a901              ADD      r1,sp,#4              ;228
00009a  6820              LDR      r0,[r4,#0]            ;228
00009c  f7fffffe          BL       TIM_OC2_SetConfig
0000a0  6820              LDR      r0,[r4,#0]            ;232
0000a2  6841              LDR      r1,[r0,#4]            ;232
0000a4  f0210170          BIC      r1,r1,#0x70           ;232
0000a8  6041              STR      r1,[r0,#4]            ;232
0000aa  6820              LDR      r0,[r4,#0]            ;233
0000ac  6841              LDR      r1,[r0,#4]            ;233
0000ae  f0410150          ORR      r1,r1,#0x50           ;233
0000b2  6041              STR      r1,[r0,#4]            ;233
0000b4  2001              MOVS     r0,#1                 ;236
0000b6  f884003d          STRB     r0,[r4,#0x3d]         ;236
0000ba  2000              MOVS     r0,#0                 ;238
0000bc  e7ac              B        |L9.24|
;;;240    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;286      */
;;;287    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;288    {
;;;289      /* Prevent unused argument(s) compilation warning */
;;;290      UNUSED(htim);
;;;291      /* NOTE : This function Should not be modified, when the callback is needed,
;;;292                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;293       */
;;;294    }
;;;295    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;272      */
;;;273    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(htim);
;;;277      /* NOTE : This function Should not be modified, when the callback is needed,
;;;278                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;279       */
;;;280    }
;;;281    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;300      */
;;;301    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;302    {
000002  4604              MOV      r4,r0
;;;303      /* Check the parameters */
;;;304      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;305    
;;;306      /* Enable the Input Capture channel 1
;;;307        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;308      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;309    
;;;310      /* Enable the Peripheral */
;;;311      __HAL_TIM_ENABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0410101          ORR      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;312    
;;;313      /* Return function status */
;;;314      return HAL_OK;
000018  2000              MOVS     r0,#0
;;;315    }
00001a  bd10              POP      {r4,pc}
;;;316    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;392      */
;;;393    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;394    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;395      /* Check the parameters */
;;;396      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;397    
;;;398       if((htim->State == HAL_TIM_STATE_BUSY))
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2802              CMP      r0,#2
00000e  d004              BEQ      |L13.26|
;;;399      {
;;;400         return HAL_BUSY;
;;;401      }
;;;402      else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L13.30|
000018  e008              B        |L13.44|
                  |L13.26|
00001a  2002              MOVS     r0,#2                 ;400
;;;403      {
;;;404        if(((uint32_t)pData == 0U) && (Length > 0U))
;;;405        {
;;;406          return HAL_ERROR;
;;;407        }
;;;408        else
;;;409        {
;;;410          htim->State = HAL_TIM_STATE_BUSY;
;;;411        }
;;;412      }
;;;413      /* Enable the Input Capture channel 1
;;;414        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;415      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;416    
;;;417      /* Set the DMA Input Capture 1 Callback */
;;;418      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;419      /* Set the DMA error callback */
;;;420      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;421    
;;;422      /* Enable the DMA channel for Capture 1*/
;;;423      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;424    
;;;425      /* Enable the capture compare 1 Interrupt */
;;;426      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;427    
;;;428      /* Enable the Peripheral */
;;;429      __HAL_TIM_ENABLE(htim);
;;;430    
;;;431      /* Return function status */
;;;432      return HAL_OK;
;;;433    }
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  b916              CBNZ     r6,|L13.38|
000020  b10d              CBZ      r5,|L13.38|
000022  2001              MOVS     r0,#1                 ;406
000024  bd70              POP      {r4-r6,pc}
                  |L13.38|
000026  2002              MOVS     r0,#2                 ;410
000028  f884003d          STRB     r0,[r4,#0x3d]         ;410
                  |L13.44|
00002c  2201              MOVS     r2,#1                 ;415
00002e  2100              MOVS     r1,#0                 ;415
000030  6820              LDR      r0,[r4,#0]            ;415
000032  f7fffffe          BL       TIM_CCxChannelCmd
000036  6a61              LDR      r1,[r4,#0x24]         ;418
000038  480b              LDR      r0,|L13.104|
00003a  6288              STR      r0,[r1,#0x28]         ;418
00003c  6a61              LDR      r1,[r4,#0x24]         ;420
00003e  480b              LDR      r0,|L13.108|
000040  6308              STR      r0,[r1,#0x30]         ;420
000042  6821              LDR      r1,[r4,#0]            ;423
000044  462b              MOV      r3,r5                 ;423
000046  3134              ADDS     r1,r1,#0x34           ;423
000048  4632              MOV      r2,r6                 ;423
00004a  6a60              LDR      r0,[r4,#0x24]         ;423
00004c  f7fffffe          BL       HAL_DMA_Start_IT
000050  6820              LDR      r0,[r4,#0]            ;426
000052  68c1              LDR      r1,[r0,#0xc]          ;426
000054  f4417100          ORR      r1,r1,#0x200          ;426
000058  60c1              STR      r1,[r0,#0xc]          ;426
00005a  6820              LDR      r0,[r4,#0]            ;429
00005c  6801              LDR      r1,[r0,#0]            ;429
00005e  f0410101          ORR      r1,r1,#1              ;429
000062  6001              STR      r1,[r0,#0]            ;429
000064  2000              MOVS     r0,#0                 ;432
000066  bd70              POP      {r4-r6,pc}
;;;434    
                          ENDP

                  |L13.104|
                          DCD      TIM_DMACaptureCplt
                  |L13.108|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;342      */
;;;343    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345      /* Check the parameters */
;;;346      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;347    
;;;348      /* Enable the capture compare Interrupts 1 event */
;;;349      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;350    
;;;351      /* Enable the Input Capture channel 1
;;;352        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;353      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;354    
;;;355      /* Enable the Peripheral */
;;;356      __HAL_TIM_ENABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410101          ORR      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
;;;357    
;;;358      /* Return function status */
;;;359      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;360    }
000024  bd10              POP      {r4,pc}
;;;361    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;321      */
;;;322    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;323    {
000002  4604              MOV      r4,r0
;;;324      /* Check the parameters */
;;;325      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;326    
;;;327      /* Disable the Input Capture channel 1
;;;328        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;329      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;330    
;;;331      /* Disable the Peripheral */
;;;332      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  f2411211          MOV      r2,#0x1111
000016  4211              TST      r1,r2
000018  d107              BNE      |L15.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L15.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L15.42|
;;;333    
;;;334      /* Return function status */
;;;335      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;336    }
00002c  bd10              POP      {r4,pc}
;;;337    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;439      */
;;;440    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;441    {
000002  4604              MOV      r4,r0
;;;442      /* Check the parameters */
;;;443      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;444    
;;;445      /* Disable the Input Capture channel 1
;;;446        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;447      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;448    
;;;449    
;;;450      /* Disable the capture compare Interrupts 1 event */
;;;451      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4217100          BIC      r1,r1,#0x200
000016  60c1              STR      r1,[r0,#0xc]
;;;452    
;;;453      /* Disable the Peripheral */
;;;454      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L16.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L16.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L16.52|
;;;455    
;;;456      /* Return function status */
;;;457      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;458    }
000036  bd10              POP      {r4,pc}
;;;459    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;366      */
;;;367    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;368    {
000002  4604              MOV      r4,r0
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;371    
;;;372      /* Disable the Input Capture channel 1
;;;373        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;374      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;375    
;;;376      /* Disable the capture compare Interrupts event */
;;;377      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210102          BIC      r1,r1,#2
000016  60c1              STR      r1,[r0,#0xc]
;;;378    
;;;379      /* Disable the Peripheral */
;;;380      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L17.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L17.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L17.52|
;;;381    
;;;382      /* Return function status */
;;;383      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;384    }
000036  bd10              POP      {r4,pc}
;;;385    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1676     */
;;;1677   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;1678   {
;;;1679     /* Check the parameters */
;;;1680     assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
;;;1681     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1682     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1683   
;;;1684     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d020              BEQ      |L18.76|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
;;;1685   
;;;1686     htim->State = HAL_TIM_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  f880203d          STRB     r2,[r0,#0x3d]
;;;1687   
;;;1688     /* Reset the MMS Bits */
;;;1689     htim->Instance->CR2 &= ~TIM_CR2_MMS;
000016  6802              LDR      r2,[r0,#0]
000018  6854              LDR      r4,[r2,#4]
00001a  f0240470          BIC      r4,r4,#0x70
00001e  6054              STR      r4,[r2,#4]
;;;1690     /* Select the TRGO source */
;;;1691     htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
000020  6802              LDR      r2,[r0,#0]
000022  6854              LDR      r4,[r2,#4]
000024  680d              LDR      r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
000028  6054              STR      r4,[r2,#4]
;;;1692   
;;;1693     /* Reset the MSM Bit */
;;;1694     htim->Instance->SMCR &= ~TIM_SMCR_MSM;
00002a  6802              LDR      r2,[r0,#0]
00002c  6894              LDR      r4,[r2,#8]
00002e  f0240480          BIC      r4,r4,#0x80
000032  6094              STR      r4,[r2,#8]
;;;1695     /* Set or Reset the MSM Bit */
;;;1696     htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
000034  6802              LDR      r2,[r0,#0]
000036  6894              LDR      r4,[r2,#8]
000038  6849              LDR      r1,[r1,#4]
00003a  430c              ORRS     r4,r4,r1
00003c  6094              STR      r4,[r2,#8]
;;;1697   
;;;1698     htim->State = HAL_TIM_STATE_READY;
00003e  f880303d          STRB     r3,[r0,#0x3d]
;;;1699   
;;;1700     __HAL_UNLOCK(htim);
000042  2100              MOVS     r1,#0
000044  f880103c          STRB     r1,[r0,#0x3c]
;;;1701   
;;;1702     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;1703   }
00004a  bd30              POP      {r4,r5,pc}
                  |L18.76|
00004c  2002              MOVS     r0,#2                 ;1684
00004e  bd30              POP      {r4,r5,pc}
;;;1704   
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;499      */
;;;500    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;501    {
000002  4604              MOV      r4,r0
;;;502      /* Check the parameters */
;;;503      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;504    
;;;505      /* Enable the Capture compare channel N */
;;;506      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  2204              MOVS     r2,#4
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;507    
;;;508      /* Enable the Main Ouput */
;;;509      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;510    
;;;511      /* Enable the Peripheral */
;;;512      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;513    
;;;514      /* Return function status */
;;;515      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;516    }
000022  bd10              POP      {r4,pc}
;;;517    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;701      */
;;;702    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;703    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  4611              MOV      r1,r2
;;;704      /* Check the parameters */
;;;705      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;706    
;;;707      if((htim->State == HAL_TIM_STATE_BUSY))
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2802              CMP      r0,#2
00000e  d004              BEQ      |L20.26|
;;;708      {
;;;709         return HAL_BUSY;
;;;710      }
;;;711      else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L20.30|
000018  e008              B        |L20.44|
                  |L20.26|
00001a  2002              MOVS     r0,#2                 ;709
;;;712      {
;;;713        if(((uint32_t)pData == 0U) && (Length > 0U))
;;;714        {
;;;715          return HAL_ERROR;
;;;716        }
;;;717        else
;;;718        {
;;;719          htim->State = HAL_TIM_STATE_BUSY;
;;;720        }
;;;721      }
;;;722      switch (Channel)
;;;723      {
;;;724        case TIM_CHANNEL_1:
;;;725        {
;;;726          /* Set the DMA Period elapsed callback */
;;;727          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;728    
;;;729          /* Set the DMA error callback */
;;;730          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;731    
;;;732          /* Enable the DMA channel */
;;;733          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;734    
;;;735          /* Enable the TIM Output Compare DMA request */
;;;736          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;737        }
;;;738        break;
;;;739    
;;;740        case TIM_CHANNEL_2:
;;;741        {
;;;742          /* Set the DMA Period elapsed callback */
;;;743          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;744    
;;;745          /* Set the DMA error callback */
;;;746          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;747    
;;;748          /* Enable the DMA channel */
;;;749          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;750    
;;;751          /* Enable the TIM Output Compare DMA request */
;;;752          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;753        }
;;;754        break;
;;;755    
;;;756        case TIM_CHANNEL_3:
;;;757    {
;;;758          /* Set the DMA Period elapsed callback */
;;;759          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;760    
;;;761          /* Set the DMA error callback */
;;;762          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;763    
;;;764          /* Enable the DMA channel */
;;;765          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;766    
;;;767          /* Enable the TIM Output Compare DMA request */
;;;768          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;769        }
;;;770        break;
;;;771    
;;;772        case TIM_CHANNEL_4:
;;;773        {
;;;774         /* Set the DMA Period elapsed callback */
;;;775          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;776    
;;;777          /* Set the DMA error callback */
;;;778          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;779    
;;;780          /* Enable the DMA channel */
;;;781          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;782    
;;;783          /* Enable the TIM Output Compare DMA request */
;;;784          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;785        }
;;;786        break;
;;;787    
;;;788        default:
;;;789        break;
;;;790      }
;;;791    
;;;792      /* Enable the Capture compare channel N */
;;;793      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;794    
;;;795      /* Enable the Main Ouput */
;;;796      __HAL_TIM_MOE_ENABLE(htim);
;;;797    
;;;798      /* Enable the Peripheral */
;;;799      __HAL_TIM_ENABLE(htim);
;;;800    
;;;801      /* Return function status */
;;;802      return HAL_OK;
;;;803    }
00001c  bd70              POP      {r4-r6,pc}
                  |L20.30|
00001e  b911              CBNZ     r1,|L20.38|
000020  b10b              CBZ      r3,|L20.38|
000022  2001              MOVS     r0,#1                 ;715
000024  bd70              POP      {r4-r6,pc}
                  |L20.38|
000026  2002              MOVS     r0,#2                 ;719
000028  f884003d          STRB     r0,[r4,#0x3d]         ;719
                  |L20.44|
00002c  482a              LDR      r0,|L20.216|
00002e  4a2b              LDR      r2,|L20.220|
000030  b135              CBZ      r5,|L20.64|
000032  2d04              CMP      r5,#4                 ;722
000034  d013              BEQ      |L20.94|
000036  2d08              CMP      r5,#8                 ;722
000038  d020              BEQ      |L20.124|
00003a  2d0c              CMP      r5,#0xc               ;722
00003c  d13b              BNE      |L20.182|
00003e  e02c              B        |L20.154|
                  |L20.64|
000040  6a66              LDR      r6,[r4,#0x24]         ;727
000042  62b0              STR      r0,[r6,#0x28]         ;727
000044  6a60              LDR      r0,[r4,#0x24]         ;730
000046  6302              STR      r2,[r0,#0x30]         ;730
000048  6822              LDR      r2,[r4,#0]            ;733
00004a  6a60              LDR      r0,[r4,#0x24]         ;733
00004c  3234              ADDS     r2,r2,#0x34           ;733
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;736
000054  68c1              LDR      r1,[r0,#0xc]          ;736
000056  f4417100          ORR      r1,r1,#0x200          ;736
00005a  60c1              STR      r1,[r0,#0xc]          ;736
00005c  e02b              B        |L20.182|
                  |L20.94|
00005e  6aa6              LDR      r6,[r4,#0x28]         ;743
000060  62b0              STR      r0,[r6,#0x28]         ;743
000062  6aa0              LDR      r0,[r4,#0x28]         ;746
000064  6302              STR      r2,[r0,#0x30]         ;746
000066  6822              LDR      r2,[r4,#0]            ;749
000068  6aa0              LDR      r0,[r4,#0x28]         ;749
00006a  3238              ADDS     r2,r2,#0x38           ;749
00006c  f7fffffe          BL       HAL_DMA_Start_IT
000070  6820              LDR      r0,[r4,#0]            ;752
000072  68c1              LDR      r1,[r0,#0xc]          ;752
000074  f4416180          ORR      r1,r1,#0x400          ;752
000078  60c1              STR      r1,[r0,#0xc]          ;752
00007a  e01c              B        |L20.182|
                  |L20.124|
00007c  6ae6              LDR      r6,[r4,#0x2c]         ;759
00007e  62b0              STR      r0,[r6,#0x28]         ;759
000080  6ae0              LDR      r0,[r4,#0x2c]         ;762
000082  6302              STR      r2,[r0,#0x30]         ;762
000084  6822              LDR      r2,[r4,#0]            ;765
000086  6ae0              LDR      r0,[r4,#0x2c]         ;765
000088  323c              ADDS     r2,r2,#0x3c           ;765
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  6820              LDR      r0,[r4,#0]            ;768
000090  68c1              LDR      r1,[r0,#0xc]          ;768
000092  f4416100          ORR      r1,r1,#0x800          ;768
000096  60c1              STR      r1,[r0,#0xc]          ;768
000098  e00d              B        |L20.182|
                  |L20.154|
00009a  6b26              LDR      r6,[r4,#0x30]         ;775
00009c  62b0              STR      r0,[r6,#0x28]         ;775
00009e  6b20              LDR      r0,[r4,#0x30]         ;778
0000a0  6302              STR      r2,[r0,#0x30]         ;778
0000a2  6822              LDR      r2,[r4,#0]            ;781
0000a4  6b20              LDR      r0,[r4,#0x30]         ;781
0000a6  3240              ADDS     r2,r2,#0x40           ;781
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  6820              LDR      r0,[r4,#0]            ;784
0000ae  68c1              LDR      r1,[r0,#0xc]          ;784
0000b0  f4415180          ORR      r1,r1,#0x1000         ;784
0000b4  60c1              STR      r1,[r0,#0xc]          ;784
                  |L20.182|
0000b6  2204              MOVS     r2,#4                 ;793
0000b8  4629              MOV      r1,r5                 ;793
0000ba  6820              LDR      r0,[r4,#0]            ;793
0000bc  f7fffffe          BL       TIM_CCxNChannelCmd
0000c0  6820              LDR      r0,[r4,#0]            ;796
0000c2  6c41              LDR      r1,[r0,#0x44]         ;796
0000c4  f4414100          ORR      r1,r1,#0x8000         ;796
0000c8  6441              STR      r1,[r0,#0x44]         ;796
0000ca  6820              LDR      r0,[r4,#0]            ;799
0000cc  6801              LDR      r1,[r0,#0]            ;799
0000ce  f0410101          ORR      r1,r1,#1              ;799
0000d2  6001              STR      r1,[r0,#0]            ;799
0000d4  2000              MOVS     r0,#0                 ;802
0000d6  bd70              POP      {r4-r6,pc}
;;;804    
                          ENDP

                  |L20.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L20.220|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;559      */
;;;560    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;561    {
000002  4604              MOV      r4,r0
;;;562      /* Check the parameters */
;;;563      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;564    
;;;565      switch (Channel)
000004  2900              CMP      r1,#0
;;;566      {
;;;567        case TIM_CHANNEL_1:
;;;568        {
;;;569          /* Enable the TIM Output Compare interrupt */
;;;570          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L21.24|
00000a  2904              CMP      r1,#4                 ;565
00000c  d009              BEQ      |L21.34|
00000e  2908              CMP      r1,#8                 ;565
000010  d00c              BEQ      |L21.44|
000012  290c              CMP      r1,#0xc               ;565
000014  d113              BNE      |L21.62|
000016  e00e              B        |L21.54|
                  |L21.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;571        }
;;;572        break;
000020  e00d              B        |L21.62|
                  |L21.34|
;;;573    
;;;574        case TIM_CHANNEL_2:
;;;575        {
;;;576          /* Enable the TIM Output Compare interrupt */
;;;577          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;578        }
;;;579        break;
00002a  e008              B        |L21.62|
                  |L21.44|
;;;580    
;;;581        case TIM_CHANNEL_3:
;;;582        {
;;;583          /* Enable the TIM Output Compare interrupt */
;;;584          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0400008          ORR      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;585        }
;;;586        break;
000034  e003              B        |L21.62|
                  |L21.54|
;;;587    
;;;588        case TIM_CHANNEL_4:
;;;589        {
;;;590          /* Enable the TIM Output Compare interrupt */
;;;591          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0400010          ORR      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L21.62|
;;;592        }
;;;593        break;
;;;594    
;;;595        default:
;;;596        break;
;;;597      }
;;;598    
;;;599      /* Enable the TIM Break interrupt */
;;;600      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
00003e  6820              LDR      r0,[r4,#0]
000040  68c2              LDR      r2,[r0,#0xc]
000042  f0420280          ORR      r2,r2,#0x80
000046  60c2              STR      r2,[r0,#0xc]
;;;601    
;;;602      /* Enable the Capture compare channel N */
;;;603      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000048  2204              MOVS     r2,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;604    
;;;605      /* Enable the Main Ouput */
;;;606      __HAL_TIM_MOE_ENABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6c41              LDR      r1,[r0,#0x44]
000054  f4414100          ORR      r1,r1,#0x8000
000058  6441              STR      r1,[r0,#0x44]
;;;607    
;;;608      /* Enable the Peripheral */
;;;609      __HAL_TIM_ENABLE(htim);
00005a  6820              LDR      r0,[r4,#0]
00005c  6801              LDR      r1,[r0,#0]
00005e  f0410101          ORR      r1,r1,#1
000062  6001              STR      r1,[r0,#0]
;;;610    
;;;611      /* Return function status */
;;;612      return HAL_OK;
000064  2000              MOVS     r0,#0
;;;613    }
000066  bd10              POP      {r4,pc}
;;;614    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;529      */
;;;530    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;531    {
000002  4604              MOV      r4,r0
;;;532      /* Check the parameters */
;;;533      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;534    
;;;535      /* Disable the Capture compare channel N */
;;;536      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  2200              MOVS     r2,#0
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;537    
;;;538      /* Disable the Main Ouput */
;;;539      __HAL_TIM_MOE_DISABLE(htim);
00000c  6821              LDR      r1,[r4,#0]
00000e  6a08              LDR      r0,[r1,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4210              TST      r0,r2
000016  f2404344          MOV      r3,#0x444
00001a  d106              BNE      |L22.42|
00001c  6a08              LDR      r0,[r1,#0x20]
00001e  4218              TST      r0,r3
000020  d103              BNE      |L22.42|
000022  6c48              LDR      r0,[r1,#0x44]
000024  f4204000          BIC      r0,r0,#0x8000
000028  6448              STR      r0,[r1,#0x44]
                  |L22.42|
;;;540    
;;;541      /* Disable the Peripheral */
;;;542      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  4211              TST      r1,r2
000030  d106              BNE      |L22.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4219              TST      r1,r3
000036  d103              BNE      |L22.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L22.64|
;;;543    
;;;544      /* Return function status */
;;;545      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;546    }
000042  bd10              POP      {r4,pc}
;;;547    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;816      */
;;;817    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;818    {
000002  4604              MOV      r4,r0
;;;819      /* Check the parameters */
;;;820      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;821    
;;;822      switch (Channel)
000004  2900              CMP      r1,#0
;;;823      {
;;;824        case TIM_CHANNEL_1:
;;;825        {
;;;826          /* Disable the TIM Output Compare DMA request */
;;;827          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L23.24|
00000a  2904              CMP      r1,#4                 ;822
00000c  d009              BEQ      |L23.34|
00000e  2908              CMP      r1,#8                 ;822
000010  d00c              BEQ      |L23.44|
000012  290c              CMP      r1,#0xc               ;822
000014  d113              BNE      |L23.62|
000016  e00e              B        |L23.54|
                  |L23.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  60d0              STR      r0,[r2,#0xc]
;;;828        }
;;;829        break;
000020  e00d              B        |L23.62|
                  |L23.34|
;;;830    
;;;831        case TIM_CHANNEL_2:
;;;832        {
;;;833          /* Disable the TIM Output Compare DMA request */
;;;834          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f4206080          BIC      r0,r0,#0x400
000028  60d0              STR      r0,[r2,#0xc]
;;;835        }
;;;836        break;
00002a  e008              B        |L23.62|
                  |L23.44|
;;;837    
;;;838        case TIM_CHANNEL_3:
;;;839        {
;;;840          /* Disable the TIM Output Compare DMA request */
;;;841          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f4206000          BIC      r0,r0,#0x800
000032  60d0              STR      r0,[r2,#0xc]
;;;842        }
;;;843        break;
000034  e003              B        |L23.62|
                  |L23.54|
;;;844    
;;;845        case TIM_CHANNEL_4:
;;;846        {
;;;847          /* Disable the TIM Output Compare interrupt */
;;;848          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f4205080          BIC      r0,r0,#0x1000
00003c  60d0              STR      r0,[r2,#0xc]
                  |L23.62|
;;;849        }
;;;850        break;
;;;851    
;;;852        default:
;;;853        break;
;;;854      }
;;;855    
;;;856      /* Disable the Capture compare channel N */
;;;857      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxNChannelCmd
;;;858    
;;;859      /* Disable the Main Ouput */
;;;860      __HAL_TIM_MOE_DISABLE(htim);
000046  6820              LDR      r0,[r4,#0]
000048  6a03              LDR      r3,[r0,#0x20]
00004a  f2411211          MOV      r2,#0x1111
00004e  4213              TST      r3,r2
000050  f2404144          MOV      r1,#0x444
000054  d106              BNE      |L23.100|
000056  6a03              LDR      r3,[r0,#0x20]
000058  420b              TST      r3,r1
00005a  d103              BNE      |L23.100|
00005c  6c43              LDR      r3,[r0,#0x44]
00005e  f4234300          BIC      r3,r3,#0x8000
000062  6443              STR      r3,[r0,#0x44]
                  |L23.100|
;;;861    
;;;862      /* Disable the Peripheral */
;;;863      __HAL_TIM_DISABLE(htim);
000064  6820              LDR      r0,[r4,#0]
000066  6a03              LDR      r3,[r0,#0x20]
000068  4213              TST      r3,r2
00006a  d106              BNE      |L23.122|
00006c  6a02              LDR      r2,[r0,#0x20]
00006e  420a              TST      r2,r1
000070  d103              BNE      |L23.122|
000072  6801              LDR      r1,[r0,#0]
000074  f0210101          BIC      r1,r1,#1
000078  6001              STR      r1,[r0,#0]
                  |L23.122|
;;;864    
;;;865      /* Change the htim state */
;;;866      htim->State = HAL_TIM_STATE_READY;
00007a  2001              MOVS     r0,#1
00007c  f884003d          STRB     r0,[r4,#0x3d]
;;;867    
;;;868      /* Return function status */
;;;869      return HAL_OK;
000080  2000              MOVS     r0,#0
;;;870    }
000082  bd10              POP      {r4,pc}
;;;871    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;626      */
;;;627    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;628    {
000002  4604              MOV      r4,r0
;;;629      uint32_t tmpccer = 0U;
;;;630    
;;;631      /* Check the parameters */
;;;632      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;633    
;;;634      switch (Channel)
000004  2900              CMP      r1,#0
;;;635      {
;;;636        case TIM_CHANNEL_1:
;;;637        {
;;;638          /* Disable the TIM Output Compare interrupt */
;;;639          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L24.24|
00000a  2904              CMP      r1,#4                 ;634
00000c  d009              BEQ      |L24.34|
00000e  2908              CMP      r1,#8                 ;634
000010  d00c              BEQ      |L24.44|
000012  290c              CMP      r1,#0xc               ;634
000014  d113              BNE      |L24.62|
000016  e00e              B        |L24.54|
                  |L24.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;640        }
;;;641        break;
000020  e00d              B        |L24.62|
                  |L24.34|
;;;642    
;;;643        case TIM_CHANNEL_2:
;;;644        {
;;;645          /* Disable the TIM Output Compare interrupt */
;;;646          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;647        }
;;;648        break;
00002a  e008              B        |L24.62|
                  |L24.44|
;;;649    
;;;650        case TIM_CHANNEL_3:
;;;651        {
;;;652          /* Disable the TIM Output Compare interrupt */
;;;653          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0200008          BIC      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;654        }
;;;655        break;
000034  e003              B        |L24.62|
                  |L24.54|
;;;656    
;;;657        case TIM_CHANNEL_4:
;;;658        {
;;;659          /* Disable the TIM Output Compare interrupt */
;;;660          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0200010          BIC      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L24.62|
;;;661        }
;;;662        break;
;;;663    
;;;664        default:
;;;665        break;
;;;666      }
;;;667    
;;;668      /* Disable the Capture compare channel N */
;;;669      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxNChannelCmd
;;;670    
;;;671      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;672      tmpccer = htim->Instance->CCER;
000046  6820              LDR      r0,[r4,#0]
000048  6a02              LDR      r2,[r0,#0x20]
;;;673      if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
00004a  f2404144          MOV      r1,#0x444
00004e  420a              TST      r2,r1
000050  d103              BNE      |L24.90|
;;;674      {
;;;675        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000052  68c2              LDR      r2,[r0,#0xc]
000054  f0220280          BIC      r2,r2,#0x80
000058  60c2              STR      r2,[r0,#0xc]
                  |L24.90|
;;;676      }
;;;677    
;;;678      /* Disable the Main Ouput */
;;;679      __HAL_TIM_MOE_DISABLE(htim);
00005a  6820              LDR      r0,[r4,#0]
00005c  6a03              LDR      r3,[r0,#0x20]
00005e  f2411211          MOV      r2,#0x1111
000062  4213              TST      r3,r2
000064  d106              BNE      |L24.116|
000066  6a03              LDR      r3,[r0,#0x20]
000068  420b              TST      r3,r1
00006a  d103              BNE      |L24.116|
00006c  6c43              LDR      r3,[r0,#0x44]
00006e  f4234300          BIC      r3,r3,#0x8000
000072  6443              STR      r3,[r0,#0x44]
                  |L24.116|
;;;680    
;;;681      /* Disable the Peripheral */
;;;682      __HAL_TIM_DISABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6a03              LDR      r3,[r0,#0x20]
000078  4213              TST      r3,r2
00007a  d106              BNE      |L24.138|
00007c  6a02              LDR      r2,[r0,#0x20]
00007e  420a              TST      r2,r1
000080  d103              BNE      |L24.138|
000082  6801              LDR      r1,[r0,#0]
000084  f0210101          BIC      r1,r1,#1
000088  6001              STR      r1,[r0,#0]
                  |L24.138|
;;;683    
;;;684      /* Return function status */
;;;685      return HAL_OK;
00008a  2000              MOVS     r0,#0
;;;686    }
00008c  bd10              POP      {r4,pc}
;;;687    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1319     */
;;;1320   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1321     {
000002  4604              MOV      r4,r0
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1324   
;;;1325     /* Enable the complementary One Pulse output */
;;;1326     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000004  2204              MOVS     r2,#4
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1327   
;;;1328     /* Enable the Main Ouput */
;;;1329     __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;1330   
;;;1331     /* Return function status */
;;;1332     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1333   }
000018  bd10              POP      {r4,pc}
;;;1334   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1373     */
;;;1374   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1375   {
000002  4604              MOV      r4,r0
;;;1376     /* Check the parameters */
;;;1377     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1378   
;;;1379     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1380     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0420202          ORR      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1381   
;;;1382     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1383     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0420204          ORR      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1384   
;;;1385     /* Enable the complementary One Pulse output */
;;;1386     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000018  2204              MOVS     r2,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1387   
;;;1388     /* Enable the Main Ouput */
;;;1389     __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c41              LDR      r1,[r0,#0x44]
000024  f4414100          ORR      r1,r1,#0x8000
000028  6441              STR      r1,[r0,#0x44]
;;;1390   
;;;1391     /* Return function status */
;;;1392     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;1393     }
00002c  bd10              POP      {r4,pc}
;;;1394   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1344     */
;;;1345   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1346   {
000002  4604              MOV      r4,r0
;;;1347   
;;;1348     /* Check the parameters */
;;;1349     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1350   
;;;1351     /* Disable the complementary One Pulse output */
;;;1352     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000004  2200              MOVS     r2,#0
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1353   
;;;1354     /* Disable the Main Ouput */
;;;1355     __HAL_TIM_MOE_DISABLE(htim);
00000c  6821              LDR      r1,[r4,#0]
00000e  6a08              LDR      r0,[r1,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4210              TST      r0,r2
000016  f2404344          MOV      r3,#0x444
00001a  d106              BNE      |L27.42|
00001c  6a08              LDR      r0,[r1,#0x20]
00001e  4218              TST      r0,r3
000020  d103              BNE      |L27.42|
000022  6c48              LDR      r0,[r1,#0x44]
000024  f4204000          BIC      r0,r0,#0x8000
000028  6448              STR      r0,[r1,#0x44]
                  |L27.42|
;;;1356   
;;;1357     /* Disable the Peripheral */
;;;1358     __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  4211              TST      r1,r2
000030  d106              BNE      |L27.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4219              TST      r1,r3
000036  d103              BNE      |L27.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L27.64|
;;;1359   
;;;1360     /* Return function status */
;;;1361     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1362   }
000042  bd10              POP      {r4,pc}
;;;1363   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1404     */
;;;1405   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1406   {
000002  4604              MOV      r4,r0
;;;1407     /* Check the parameters */
;;;1408     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1409   
;;;1410     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1411     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0220202          BIC      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1412   
;;;1413     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1414     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0220204          BIC      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1415   
;;;1416     /* Disable the complementary One Pulse output */
;;;1417     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000018  2200              MOVS     r2,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1418   
;;;1419     /* Disable the Main Ouput */
;;;1420     __HAL_TIM_MOE_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a03              LDR      r3,[r0,#0x20]
000024  f2411111          MOV      r1,#0x1111
000028  420b              TST      r3,r1
00002a  f2404244          MOV      r2,#0x444
00002e  d106              BNE      |L28.62|
000030  6a03              LDR      r3,[r0,#0x20]
000032  4213              TST      r3,r2
000034  d103              BNE      |L28.62|
000036  6c43              LDR      r3,[r0,#0x44]
000038  f4234300          BIC      r3,r3,#0x8000
00003c  6443              STR      r3,[r0,#0x44]
                  |L28.62|
;;;1421   
;;;1422     /* Disable the Peripheral */
;;;1423      __HAL_TIM_DISABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6a03              LDR      r3,[r0,#0x20]
000042  420b              TST      r3,r1
000044  d106              BNE      |L28.84|
000046  6a01              LDR      r1,[r0,#0x20]
000048  4211              TST      r1,r2
00004a  d103              BNE      |L28.84|
00004c  6801              LDR      r1,[r0,#0]
00004e  f0210101          BIC      r1,r1,#1
000052  6001              STR      r1,[r0,#0]
                  |L28.84|
;;;1424   
;;;1425     /* Return function status */
;;;1426     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1427   }
000056  bd10              POP      {r4,pc}
;;;1428   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;916      */
;;;917    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;918    {
000002  4604              MOV      r4,r0
;;;919      /* Check the parameters */
;;;920      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;921    
;;;922      /* Enable the complementary PWM output  */
;;;923      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  2204              MOVS     r2,#4
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;924    
;;;925      /* Enable the Main Ouput */
;;;926      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;927    
;;;928      /* Enable the Peripheral */
;;;929      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;930    
;;;931      /* Return function status */
;;;932      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;933    }
000022  bd10              POP      {r4,pc}
;;;934    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1117     */
;;;1118   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1119   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  4611              MOV      r1,r2
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1122   
;;;1123     if((htim->State == HAL_TIM_STATE_BUSY))
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2802              CMP      r0,#2
00000e  d004              BEQ      |L30.26|
;;;1124     {
;;;1125        return HAL_BUSY;
;;;1126     }
;;;1127     else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L30.30|
000018  e008              B        |L30.44|
                  |L30.26|
00001a  2002              MOVS     r0,#2                 ;1125
;;;1128     {
;;;1129       if(((uint32_t)pData == 0U) && (Length > 0U))
;;;1130       {
;;;1131         return HAL_ERROR;
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135         htim->State = HAL_TIM_STATE_BUSY;
;;;1136       }
;;;1137     }
;;;1138     switch (Channel)
;;;1139     {
;;;1140       case TIM_CHANNEL_1:
;;;1141       {
;;;1142         /* Set the DMA Period elapsed callback */
;;;1143         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1144   
;;;1145         /* Set the DMA error callback */
;;;1146         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1147   
;;;1148         /* Enable the DMA channel */
;;;1149         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1150   
;;;1151         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1152         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1153       }
;;;1154       break;
;;;1155   
;;;1156       case TIM_CHANNEL_2:
;;;1157       {
;;;1158         /* Set the DMA Period elapsed callback */
;;;1159         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1160   
;;;1161         /* Set the DMA error callback */
;;;1162         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1163   
;;;1164         /* Enable the DMA channel */
;;;1165         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1166   
;;;1167         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1168         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1169       }
;;;1170       break;
;;;1171   
;;;1172       case TIM_CHANNEL_3:
;;;1173       {
;;;1174         /* Set the DMA Period elapsed callback */
;;;1175         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1176   
;;;1177         /* Set the DMA error callback */
;;;1178         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1179   
;;;1180         /* Enable the DMA channel */
;;;1181         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1182   
;;;1183         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1184         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1185       }
;;;1186       break;
;;;1187   
;;;1188       case TIM_CHANNEL_4:
;;;1189       {
;;;1190        /* Set the DMA Period elapsed callback */
;;;1191         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1192   
;;;1193         /* Set the DMA error callback */
;;;1194         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1195   
;;;1196         /* Enable the DMA channel */
;;;1197         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1198   
;;;1199         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1200         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1201       }
;;;1202       break;
;;;1203   
;;;1204       default:
;;;1205       break;
;;;1206     }
;;;1207   
;;;1208     /* Enable the complementary PWM output  */
;;;1209        TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1210   
;;;1211     /* Enable the Main Ouput */
;;;1212       __HAL_TIM_MOE_ENABLE(htim);
;;;1213   
;;;1214     /* Enable the Peripheral */
;;;1215     __HAL_TIM_ENABLE(htim);
;;;1216   
;;;1217     /* Return function status */
;;;1218     return HAL_OK;
;;;1219   }
00001c  bd70              POP      {r4-r6,pc}
                  |L30.30|
00001e  b911              CBNZ     r1,|L30.38|
000020  b10b              CBZ      r3,|L30.38|
000022  2001              MOVS     r0,#1                 ;1131
000024  bd70              POP      {r4-r6,pc}
                  |L30.38|
000026  2002              MOVS     r0,#2                 ;1135
000028  f884003d          STRB     r0,[r4,#0x3d]         ;1135
                  |L30.44|
00002c  482a              LDR      r0,|L30.216|
00002e  4a2b              LDR      r2,|L30.220|
000030  b135              CBZ      r5,|L30.64|
000032  2d04              CMP      r5,#4                 ;1138
000034  d013              BEQ      |L30.94|
000036  2d08              CMP      r5,#8                 ;1138
000038  d020              BEQ      |L30.124|
00003a  2d0c              CMP      r5,#0xc               ;1138
00003c  d13b              BNE      |L30.182|
00003e  e02c              B        |L30.154|
                  |L30.64|
000040  6a66              LDR      r6,[r4,#0x24]         ;1143
000042  62b0              STR      r0,[r6,#0x28]         ;1143
000044  6a60              LDR      r0,[r4,#0x24]         ;1146
000046  6302              STR      r2,[r0,#0x30]         ;1146
000048  6822              LDR      r2,[r4,#0]            ;1149
00004a  6a60              LDR      r0,[r4,#0x24]         ;1149
00004c  3234              ADDS     r2,r2,#0x34           ;1149
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;1152
000054  68c1              LDR      r1,[r0,#0xc]          ;1152
000056  f4417100          ORR      r1,r1,#0x200          ;1152
00005a  60c1              STR      r1,[r0,#0xc]          ;1152
00005c  e02b              B        |L30.182|
                  |L30.94|
00005e  6aa6              LDR      r6,[r4,#0x28]         ;1159
000060  62b0              STR      r0,[r6,#0x28]         ;1159
000062  6aa0              LDR      r0,[r4,#0x28]         ;1162
000064  6302              STR      r2,[r0,#0x30]         ;1162
000066  6822              LDR      r2,[r4,#0]            ;1165
000068  6aa0              LDR      r0,[r4,#0x28]         ;1165
00006a  3238              ADDS     r2,r2,#0x38           ;1165
00006c  f7fffffe          BL       HAL_DMA_Start_IT
000070  6820              LDR      r0,[r4,#0]            ;1168
000072  68c1              LDR      r1,[r0,#0xc]          ;1168
000074  f4416180          ORR      r1,r1,#0x400          ;1168
000078  60c1              STR      r1,[r0,#0xc]          ;1168
00007a  e01c              B        |L30.182|
                  |L30.124|
00007c  6ae6              LDR      r6,[r4,#0x2c]         ;1175
00007e  62b0              STR      r0,[r6,#0x28]         ;1175
000080  6ae0              LDR      r0,[r4,#0x2c]         ;1178
000082  6302              STR      r2,[r0,#0x30]         ;1178
000084  6822              LDR      r2,[r4,#0]            ;1181
000086  6ae0              LDR      r0,[r4,#0x2c]         ;1181
000088  323c              ADDS     r2,r2,#0x3c           ;1181
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  6820              LDR      r0,[r4,#0]            ;1184
000090  68c1              LDR      r1,[r0,#0xc]          ;1184
000092  f4416100          ORR      r1,r1,#0x800          ;1184
000096  60c1              STR      r1,[r0,#0xc]          ;1184
000098  e00d              B        |L30.182|
                  |L30.154|
00009a  6b26              LDR      r6,[r4,#0x30]         ;1191
00009c  62b0              STR      r0,[r6,#0x28]         ;1191
00009e  6b20              LDR      r0,[r4,#0x30]         ;1194
0000a0  6302              STR      r2,[r0,#0x30]         ;1194
0000a2  6822              LDR      r2,[r4,#0]            ;1197
0000a4  6b20              LDR      r0,[r4,#0x30]         ;1197
0000a6  3240              ADDS     r2,r2,#0x40           ;1197
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  6820              LDR      r0,[r4,#0]            ;1200
0000ae  68c1              LDR      r1,[r0,#0xc]          ;1200
0000b0  f4415180          ORR      r1,r1,#0x1000         ;1200
0000b4  60c1              STR      r1,[r0,#0xc]          ;1200
                  |L30.182|
0000b6  2204              MOVS     r2,#4                 ;1209
0000b8  4629              MOV      r1,r5                 ;1209
0000ba  6820              LDR      r0,[r4,#0]            ;1209
0000bc  f7fffffe          BL       TIM_CCxNChannelCmd
0000c0  6820              LDR      r0,[r4,#0]            ;1212
0000c2  6c41              LDR      r1,[r0,#0x44]         ;1212
0000c4  f4414100          ORR      r1,r1,#0x8000         ;1212
0000c8  6441              STR      r1,[r0,#0x44]         ;1212
0000ca  6820              LDR      r0,[r4,#0]            ;1215
0000cc  6801              LDR      r1,[r0,#0]            ;1215
0000ce  f0410101          ORR      r1,r1,#1              ;1215
0000d2  6001              STR      r1,[r0,#0]            ;1215
0000d4  2000              MOVS     r0,#0                 ;1218
0000d6  bd70              POP      {r4-r6,pc}
;;;1220   
                          ENDP

                  |L30.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L30.220|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;975      */
;;;976    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;977    {
000002  4604              MOV      r4,r0
;;;978      /* Check the parameters */
;;;979      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;980    
;;;981      switch (Channel)
000004  2900              CMP      r1,#0
;;;982      {
;;;983        case TIM_CHANNEL_1:
;;;984        {
;;;985          /* Enable the TIM Capture/Compare 1 interrupt */
;;;986          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L31.24|
00000a  2904              CMP      r1,#4                 ;981
00000c  d009              BEQ      |L31.34|
00000e  2908              CMP      r1,#8                 ;981
000010  d00c              BEQ      |L31.44|
000012  290c              CMP      r1,#0xc               ;981
000014  d113              BNE      |L31.62|
000016  e00e              B        |L31.54|
                  |L31.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;987        }
;;;988        break;
000020  e00d              B        |L31.62|
                  |L31.34|
;;;989    
;;;990        case TIM_CHANNEL_2:
;;;991        {
;;;992          /* Enable the TIM Capture/Compare 2 interrupt */
;;;993          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;994        }
;;;995        break;
00002a  e008              B        |L31.62|
                  |L31.44|
;;;996    
;;;997        case TIM_CHANNEL_3:
;;;998        {
;;;999          /* Enable the TIM Capture/Compare 3 interrupt */
;;;1000         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0400008          ORR      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;1001       }
;;;1002       break;
000034  e003              B        |L31.62|
                  |L31.54|
;;;1003   
;;;1004       case TIM_CHANNEL_4:
;;;1005       {
;;;1006         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1007         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0400010          ORR      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L31.62|
;;;1008       }
;;;1009       break;
;;;1010   
;;;1011       default:
;;;1012       break;
;;;1013     }
;;;1014   
;;;1015     /* Enable the TIM Break interrupt */
;;;1016     __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
00003e  6820              LDR      r0,[r4,#0]
000040  68c2              LDR      r2,[r0,#0xc]
000042  f0420280          ORR      r2,r2,#0x80
000046  60c2              STR      r2,[r0,#0xc]
;;;1017   
;;;1018     /* Enable the complementary PWM output  */
;;;1019     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000048  2204              MOVS     r2,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1020   
;;;1021     /* Enable the Main Ouput */
;;;1022     __HAL_TIM_MOE_ENABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6c41              LDR      r1,[r0,#0x44]
000054  f4414100          ORR      r1,r1,#0x8000
000058  6441              STR      r1,[r0,#0x44]
;;;1023   
;;;1024     /* Enable the Peripheral */
;;;1025     __HAL_TIM_ENABLE(htim);
00005a  6820              LDR      r0,[r4,#0]
00005c  6801              LDR      r1,[r0,#0]
00005e  f0410101          ORR      r1,r1,#1
000062  6001              STR      r1,[r0,#0]
;;;1026   
;;;1027     /* Return function status */
;;;1028     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1029   }
000066  bd10              POP      {r4,pc}
;;;1030   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;945      */
;;;946    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;947    {
000002  4604              MOV      r4,r0
;;;948      /* Check the parameters */
;;;949      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;950    
;;;951      /* Disable the complementary PWM output  */
;;;952      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  2200              MOVS     r2,#0
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;953    
;;;954      /* Disable the Main Ouput */
;;;955      __HAL_TIM_MOE_DISABLE(htim);
00000c  6821              LDR      r1,[r4,#0]
00000e  6a08              LDR      r0,[r1,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4210              TST      r0,r2
000016  f2404344          MOV      r3,#0x444
00001a  d106              BNE      |L32.42|
00001c  6a08              LDR      r0,[r1,#0x20]
00001e  4218              TST      r0,r3
000020  d103              BNE      |L32.42|
000022  6c48              LDR      r0,[r1,#0x44]
000024  f4204000          BIC      r0,r0,#0x8000
000028  6448              STR      r0,[r1,#0x44]
                  |L32.42|
;;;956    
;;;957      /* Disable the Peripheral */
;;;958      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  4211              TST      r1,r2
000030  d106              BNE      |L32.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4219              TST      r1,r3
000036  d103              BNE      |L32.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L32.64|
;;;959    
;;;960      /* Return function status */
;;;961      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;962    }
000042  bd10              POP      {r4,pc}
;;;963    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1232     */
;;;1233   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1234   {
000002  4604              MOV      r4,r0
;;;1235     /* Check the parameters */
;;;1236     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1237   
;;;1238     switch (Channel)
000004  2900              CMP      r1,#0
;;;1239     {
;;;1240       case TIM_CHANNEL_1:
;;;1241       {
;;;1242         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1243         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L33.24|
00000a  2904              CMP      r1,#4                 ;1238
00000c  d009              BEQ      |L33.34|
00000e  2908              CMP      r1,#8                 ;1238
000010  d00c              BEQ      |L33.44|
000012  290c              CMP      r1,#0xc               ;1238
000014  d113              BNE      |L33.62|
000016  e00e              B        |L33.54|
                  |L33.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  60d0              STR      r0,[r2,#0xc]
;;;1244       }
;;;1245       break;
000020  e00d              B        |L33.62|
                  |L33.34|
;;;1246   
;;;1247       case TIM_CHANNEL_2:
;;;1248       {
;;;1249         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1250         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f4206080          BIC      r0,r0,#0x400
000028  60d0              STR      r0,[r2,#0xc]
;;;1251       }
;;;1252       break;
00002a  e008              B        |L33.62|
                  |L33.44|
;;;1253   
;;;1254       case TIM_CHANNEL_3:
;;;1255       {
;;;1256         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1257         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f4206000          BIC      r0,r0,#0x800
000032  60d0              STR      r0,[r2,#0xc]
;;;1258       }
;;;1259       break;
000034  e003              B        |L33.62|
                  |L33.54|
;;;1260   
;;;1261       case TIM_CHANNEL_4:
;;;1262       {
;;;1263         /* Disable the TIM Capture/Compare 4 DMA request */
;;;1264         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f4205080          BIC      r0,r0,#0x1000
00003c  60d0              STR      r0,[r2,#0xc]
                  |L33.62|
;;;1265       }
;;;1266       break;
;;;1267   
;;;1268       default:
;;;1269       break;
;;;1270     }
;;;1271   
;;;1272     /* Disable the complementary PWM output */
;;;1273       TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1274   
;;;1275     /* Disable the Main Ouput */
;;;1276       __HAL_TIM_MOE_DISABLE(htim);
000046  6820              LDR      r0,[r4,#0]
000048  6a03              LDR      r3,[r0,#0x20]
00004a  f2411211          MOV      r2,#0x1111
00004e  4213              TST      r3,r2
000050  f2404144          MOV      r1,#0x444
000054  d106              BNE      |L33.100|
000056  6a03              LDR      r3,[r0,#0x20]
000058  420b              TST      r3,r1
00005a  d103              BNE      |L33.100|
00005c  6c43              LDR      r3,[r0,#0x44]
00005e  f4234300          BIC      r3,r3,#0x8000
000062  6443              STR      r3,[r0,#0x44]
                  |L33.100|
;;;1277   
;;;1278     /* Disable the Peripheral */
;;;1279     __HAL_TIM_DISABLE(htim);
000064  6820              LDR      r0,[r4,#0]
000066  6a03              LDR      r3,[r0,#0x20]
000068  4213              TST      r3,r2
00006a  d106              BNE      |L33.122|
00006c  6a02              LDR      r2,[r0,#0x20]
00006e  420a              TST      r2,r1
000070  d103              BNE      |L33.122|
000072  6801              LDR      r1,[r0,#0]
000074  f0210101          BIC      r1,r1,#1
000078  6001              STR      r1,[r0,#0]
                  |L33.122|
;;;1280   
;;;1281     /* Change the htim state */
;;;1282     htim->State = HAL_TIM_STATE_READY;
00007a  2001              MOVS     r0,#1
00007c  f884003d          STRB     r0,[r4,#0x3d]
;;;1283   
;;;1284     /* Return function status */
;;;1285     return HAL_OK;
000080  2000              MOVS     r0,#0
;;;1286   }
000082  bd10              POP      {r4,pc}
;;;1287   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1042     */
;;;1043   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1044   {
000002  4604              MOV      r4,r0
;;;1045     uint32_t tmpccer = 0U;
;;;1046   
;;;1047     /* Check the parameters */
;;;1048     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1049   
;;;1050     switch (Channel)
000004  2900              CMP      r1,#0
;;;1051     {
;;;1052       case TIM_CHANNEL_1:
;;;1053       {
;;;1054         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1055         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L34.24|
00000a  2904              CMP      r1,#4                 ;1050
00000c  d009              BEQ      |L34.34|
00000e  2908              CMP      r1,#8                 ;1050
000010  d00c              BEQ      |L34.44|
000012  290c              CMP      r1,#0xc               ;1050
000014  d113              BNE      |L34.62|
000016  e00e              B        |L34.54|
                  |L34.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;1056       }
;;;1057       break;
000020  e00d              B        |L34.62|
                  |L34.34|
;;;1058   
;;;1059       case TIM_CHANNEL_2:
;;;1060       {
;;;1061         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1062         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;1063       }
;;;1064       break;
00002a  e008              B        |L34.62|
                  |L34.44|
;;;1065   
;;;1066       case TIM_CHANNEL_3:
;;;1067       {
;;;1068         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1069         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0200008          BIC      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;1070       }
;;;1071       break;
000034  e003              B        |L34.62|
                  |L34.54|
;;;1072   
;;;1073       case TIM_CHANNEL_4:
;;;1074       {
;;;1075         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1076         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0200010          BIC      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L34.62|
;;;1077       }
;;;1078       break;
;;;1079   
;;;1080       default:
;;;1081       break;
;;;1082     }
;;;1083   
;;;1084     /* Disable the complementary PWM output  */
;;;1085     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1086   
;;;1087     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1088     tmpccer = htim->Instance->CCER;
000046  6820              LDR      r0,[r4,#0]
000048  6a02              LDR      r2,[r0,#0x20]
;;;1089     if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
00004a  f2404144          MOV      r1,#0x444
00004e  420a              TST      r2,r1
000050  d103              BNE      |L34.90|
;;;1090     {
;;;1091       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000052  68c2              LDR      r2,[r0,#0xc]
000054  f0220280          BIC      r2,r2,#0x80
000058  60c2              STR      r2,[r0,#0xc]
                  |L34.90|
;;;1092     }
;;;1093   
;;;1094     /* Disable the Main Ouput */
;;;1095     __HAL_TIM_MOE_DISABLE(htim);
00005a  6820              LDR      r0,[r4,#0]
00005c  6a03              LDR      r3,[r0,#0x20]
00005e  f2411211          MOV      r2,#0x1111
000062  4213              TST      r3,r2
000064  d106              BNE      |L34.116|
000066  6a03              LDR      r3,[r0,#0x20]
000068  420b              TST      r3,r1
00006a  d103              BNE      |L34.116|
00006c  6c43              LDR      r3,[r0,#0x44]
00006e  f4234300          BIC      r3,r3,#0x8000
000072  6443              STR      r3,[r0,#0x44]
                  |L34.116|
;;;1096   
;;;1097     /* Disable the Peripheral */
;;;1098     __HAL_TIM_DISABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6a03              LDR      r3,[r0,#0x20]
000078  4213              TST      r3,r2
00007a  d106              BNE      |L34.138|
00007c  6a02              LDR      r2,[r0,#0x20]
00007e  420a              TST      r2,r1
000080  d103              BNE      |L34.138|
000082  6801              LDR      r1,[r0,#0]
000084  f0210101          BIC      r1,r1,#1
000088  6001              STR      r1,[r0,#0]
                  |L34.138|
;;;1099   
;;;1100     /* Return function status */
;;;1101     return HAL_OK;
00008a  2000              MOVS     r0,#0
;;;1102   }
00008c  bd10              POP      {r4,pc}
;;;1103   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;1757     */
;;;1758   void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1759   {
;;;1760     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1761   
;;;1762     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;1763   
;;;1764     HAL_TIMEx_CommutationCallback(htim);
00000a  f7fffffe          BL       HAL_TIMEx_CommutationCallback
;;;1765   }
00000e  bd10              POP      {r4,pc}
;;;1766   
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;1830     */
;;;1831   static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b510              PUSH     {r4,lr}
;;;1832   {
;;;1833     uint32_t tmp = 0U;
;;;1834   
;;;1835     tmp = TIM_CCER_CC1NE << Channel;
000002  2304              MOVS     r3,#4
000004  408b              LSLS     r3,r3,r1
;;;1836   
;;;1837     /* Reset the CCxNE Bit */
;;;1838     TIMx->CCER &=  ~tmp;
000006  6a04              LDR      r4,[r0,#0x20]
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;1839   
;;;1840     /* Set or reset the CCxNE Bit */
;;;1841     TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;1842   }
000014  bd10              POP      {r4,pc}
;;;1843   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____RRX|
#line 587
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
