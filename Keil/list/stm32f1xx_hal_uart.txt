; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -ogsm_stm32f103\stm32f1xx_hal_uart.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -IE:\MC\2.STM32\STMProjects\GSM\GSM_M590\Project\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1941     */
;;;1942   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1943   {
;;;1944     uint32_t tmpreg = 0x00U;
;;;1945   
;;;1946     /* Process Locked */
;;;1947     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L1.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1948   
;;;1949     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1950   
;;;1951     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1952     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;1953   
;;;1954     /* Clear TE and RE bits */
;;;1955     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;1956   
;;;1957     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1958     tmpreg |= (uint32_t)USART_CR1_RE;
00001c  f0420204          ORR      r2,r2,#4
;;;1959   
;;;1960     /* Write to USART CR1 */
;;;1961     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;1962   
;;;1963     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;1964   
;;;1965     /* Process Unlocked */
;;;1966     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1967     
;;;1968     return HAL_OK; 
00002a  2000              MOVS     r0,#0
;;;1969   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;1947
000030  4770              BX       lr
;;;1970   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1906     */
;;;1907   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1908   {
;;;1909     uint32_t tmpreg = 0x00U;
;;;1910   
;;;1911     /* Process Locked */
;;;1912     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L2.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1913     
;;;1914     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1915   
;;;1916     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1917     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;1918   
;;;1919     /* Clear TE and RE bits */
;;;1920     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;1921   
;;;1922     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1923     tmpreg |= (uint32_t)USART_CR1_TE;
00001c  f0420208          ORR      r2,r2,#8
;;;1924   
;;;1925     /* Write to USART CR1 */
;;;1926     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;1927   
;;;1928     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;1929     
;;;1930     /* Process Unlocked */
;;;1931     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1932     
;;;1933     return HAL_OK; 
00002a  2000              MOVS     r0,#0
;;;1934   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;1912
000030  4770              BX       lr
;;;1935   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;325      */
;;;326    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328      /* Check the UART handle allocation */
;;;329      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L3.18|
;;;330      {
;;;331        return HAL_ERROR;
;;;332      }
;;;333     
;;;334      /* Check the parameters */ 
;;;335      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;336      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;337    #if defined(USART_CR1_OVER8)
;;;338      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;339    #endif /* USART_CR1_OVER8 */
;;;340      if(huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L3.22|
000010  e006              B        |L3.32|
                  |L3.18|
000012  2001              MOVS     r0,#1                 ;331
;;;341      {
;;;342        /* Allocate lock resource and initialize it */
;;;343        huart->Lock = HAL_UNLOCKED;
;;;344        /* Init the low level hardware */
;;;345        HAL_UART_MspInit(huart);
;;;346      }
;;;347    
;;;348      huart->gState = HAL_UART_STATE_BUSY;
;;;349    
;;;350      /* Disable the peripheral */
;;;351      __HAL_UART_DISABLE(huart);
;;;352      
;;;353      /* Set the UART Communication parameters */
;;;354      UART_SetConfig(huart);
;;;355      
;;;356      /* In half-duplex mode, the following bits must be kept cleared:
;;;357         - LINEN and CLKEN bits in the USART_CR2 register,
;;;358         - SCEN and IREN bits in the USART_CR3 register.*/
;;;359      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;360      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;361      
;;;362      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;363      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;364     
;;;365      /* Enable the peripheral */
;;;366      __HAL_UART_ENABLE(huart);
;;;367      
;;;368      /* Initialize the UART state*/
;;;369      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;370      huart->gState= HAL_UART_STATE_READY;
;;;371      huart->RxState= HAL_UART_STATE_READY;
;;;372      
;;;373      return HAL_OK;
;;;374    }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;343
00001a  4620              MOV      r0,r4                 ;345
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L3.32|
000020  2024              MOVS     r0,#0x24              ;348
000022  f8840039          STRB     r0,[r4,#0x39]         ;348
000026  6820              LDR      r0,[r4,#0]            ;351
000028  68c1              LDR      r1,[r0,#0xc]          ;351
00002a  f4215100          BIC      r1,r1,#0x2000         ;351
00002e  60c1              STR      r1,[r0,#0xc]          ;351
000030  4620              MOV      r0,r4                 ;354
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;359
000038  6901              LDR      r1,[r0,#0x10]         ;359
00003a  f4214190          BIC      r1,r1,#0x4800         ;359
00003e  6101              STR      r1,[r0,#0x10]         ;359
000040  6820              LDR      r0,[r4,#0]            ;360
000042  6941              LDR      r1,[r0,#0x14]         ;360
000044  f0210122          BIC      r1,r1,#0x22           ;360
000048  6141              STR      r1,[r0,#0x14]         ;360
00004a  6820              LDR      r0,[r4,#0]            ;363
00004c  6941              LDR      r1,[r0,#0x14]         ;363
00004e  f0410108          ORR      r1,r1,#8              ;363
000052  6141              STR      r1,[r0,#0x14]         ;363
000054  6820              LDR      r0,[r4,#0]            ;366
000056  68c1              LDR      r1,[r0,#0xc]          ;366
000058  f4415100          ORR      r1,r1,#0x2000         ;366
00005c  60c1              STR      r1,[r0,#0xc]          ;366
00005e  63e5              STR      r5,[r4,#0x3c]         ;369
000060  2020              MOVS     r0,#0x20              ;370
000062  f8840039          STRB     r0,[r4,#0x39]         ;370
000066  f884003a          STRB     r0,[r4,#0x3a]         ;371
00006a  2000              MOVS     r0,#0                 ;373
00006c  bd70              POP      {r4-r6,pc}
;;;375    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;386      */
;;;387    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;388    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;389      /* Check the UART handle allocation */
;;;390      if(huart == NULL)
000006  2c00              CMP      r4,#0
000008  d004              BEQ      |L4.20|
;;;391      {
;;;392        return HAL_ERROR;
;;;393      }
;;;394      
;;;395      /* Check the LIN UART instance */  
;;;396      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;397      /* Check the Break detection length parameter */
;;;398      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;399      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;400    #if defined(USART_CR1_OVER8)
;;;401      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;402    #endif /* USART_CR1_OVER8 */
;;;403      
;;;404      if(huart->gState == HAL_UART_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  2500              MOVS     r5,#0
000010  b110              CBZ      r0,|L4.24|
000012  e006              B        |L4.34|
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;392
;;;405      {
;;;406        /* Allocate lock resource and initialize it */
;;;407        huart->Lock = HAL_UNLOCKED;
;;;408        /* Init the low level hardware */
;;;409        HAL_UART_MspInit(huart);
;;;410      }
;;;411    
;;;412      huart->gState = HAL_UART_STATE_BUSY;
;;;413    
;;;414      /* Disable the peripheral */
;;;415      __HAL_UART_DISABLE(huart);
;;;416      
;;;417      /* Set the UART Communication parameters */
;;;418      UART_SetConfig(huart);
;;;419      
;;;420      /* In LIN mode, the following bits must be kept cleared: 
;;;421         - CLKEN bits in the USART_CR2 register,
;;;422         - SCEN and IREN bits in the USART_CR3 register.*/
;;;423      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;424      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;425      
;;;426      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;427      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;428      
;;;429      /* Set the USART LIN Break detection length. */
;;;430      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;431      
;;;432      /* Enable the peripheral */
;;;433      __HAL_UART_ENABLE(huart);
;;;434      
;;;435      /* Initialize the UART state*/
;;;436      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;437      huart->gState= HAL_UART_STATE_READY;
;;;438      huart->RxState= HAL_UART_STATE_READY;
;;;439      
;;;440      return HAL_OK;
;;;441    }
000016  bd70              POP      {r4-r6,pc}
                  |L4.24|
000018  f8845038          STRB     r5,[r4,#0x38]         ;407
00001c  4620              MOV      r0,r4                 ;409
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L4.34|
000022  2024              MOVS     r0,#0x24              ;412
000024  f8840039          STRB     r0,[r4,#0x39]         ;412
000028  6820              LDR      r0,[r4,#0]            ;415
00002a  68c1              LDR      r1,[r0,#0xc]          ;415
00002c  f4215100          BIC      r1,r1,#0x2000         ;415
000030  60c1              STR      r1,[r0,#0xc]          ;415
000032  4620              MOV      r0,r4                 ;418
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;423
00003a  6901              LDR      r1,[r0,#0x10]         ;423
00003c  f4216100          BIC      r1,r1,#0x800          ;423
000040  6101              STR      r1,[r0,#0x10]         ;423
000042  6820              LDR      r0,[r4,#0]            ;424
000044  6941              LDR      r1,[r0,#0x14]         ;424
000046  f021012a          BIC      r1,r1,#0x2a           ;424
00004a  6141              STR      r1,[r0,#0x14]         ;424
00004c  6820              LDR      r0,[r4,#0]            ;427
00004e  6901              LDR      r1,[r0,#0x10]         ;427
000050  f4414180          ORR      r1,r1,#0x4000         ;427
000054  6101              STR      r1,[r0,#0x10]         ;427
000056  6820              LDR      r0,[r4,#0]            ;430
000058  6901              LDR      r1,[r0,#0x10]         ;430
00005a  f0210120          BIC      r1,r1,#0x20           ;430
00005e  4331              ORRS     r1,r1,r6              ;430
000060  6101              STR      r1,[r0,#0x10]         ;430
000062  6820              LDR      r0,[r4,#0]            ;433
000064  68c1              LDR      r1,[r0,#0xc]          ;433
000066  f4415100          ORR      r1,r1,#0x2000         ;433
00006a  60c1              STR      r1,[r0,#0xc]          ;433
00006c  63e5              STR      r5,[r4,#0x3c]         ;436
00006e  2020              MOVS     r0,#0x20              ;437
000070  f8840039          STRB     r0,[r4,#0x39]         ;437
000074  f884003a          STRB     r0,[r4,#0x3a]         ;438
000078  2000              MOVS     r0,#0                 ;440
00007a  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1825     */
;;;1826   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1827   {
;;;1828     /* Check the parameters */
;;;1829     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1830     
;;;1831     /* Process Locked */
;;;1832     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1833     
;;;1834     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1835     
;;;1836     /* Send break characters */
;;;1837     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420201          ORR      r2,r2,#1
00001c  60ca              STR      r2,[r1,#0xc]
;;;1838    
;;;1839     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1840     
;;;1841     /* Process Unlocked */
;;;1842     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1843     
;;;1844     return HAL_OK; 
000026  2000              MOVS     r0,#0
;;;1845   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;1832
00002c  4770              BX       lr
;;;1846   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1852     */
;;;1853   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1854   {
;;;1855     /* Check the parameters */
;;;1856     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1857     
;;;1858     /* Process Locked */
;;;1859     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L6.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1860     
;;;1861     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1862     
;;;1863     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1864     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420202          ORR      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;1865     
;;;1866     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1867     
;;;1868     /* Process Unlocked */
;;;1869     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1870     
;;;1871     return HAL_OK; 
000026  2000              MOVS     r0,#0
;;;1872   }
000028  4770              BX       lr
                  |L6.42|
00002a  2002              MOVS     r0,#2                 ;1859
00002c  4770              BX       lr
;;;1873   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1879     */
;;;1880   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1881   {
;;;1882     /* Check the parameters */
;;;1883     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1884     
;;;1885     /* Process Locked */
;;;1886     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L7.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1887     
;;;1888     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1889     
;;;1890     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1891     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0220202          BIC      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;1892     
;;;1893     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1894     
;;;1895     /* Process Unlocked */
;;;1896     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1897     
;;;1898     return HAL_OK; 
000026  2000              MOVS     r0,#0
;;;1899   }
000028  4770              BX       lr
                  |L7.42|
00002a  2002              MOVS     r0,#2                 ;1886
00002c  4770              BX       lr
;;;1900   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;454      */
;;;455    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;456    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;457      /* Check the UART handle allocation */
;;;458      if(huart == NULL)
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L8.24|
;;;459      {
;;;460        return HAL_ERROR;
;;;461      }
;;;462    
;;;463      /* Check UART instance capabilities */  
;;;464      assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
;;;465    
;;;466      /* Check the Address & wake up method parameters */
;;;467      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;468      assert_param(IS_UART_ADDRESS(Address));
;;;469      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;470    #if defined(USART_CR1_OVER8)
;;;471      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;472    #endif /* USART_CR1_OVER8 */
;;;473    
;;;474      if(huart->gState == HAL_UART_STATE_RESET)
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2500              MOVS     r5,#0
000014  b118              CBZ      r0,|L8.30|
000016  e007              B        |L8.40|
                  |L8.24|
000018  2001              MOVS     r0,#1                 ;460
                  |L8.26|
;;;475      {
;;;476        /* Allocate lock resource and initialize it */
;;;477        huart->Lock = HAL_UNLOCKED;
;;;478        /* Init the low level hardware */
;;;479        HAL_UART_MspInit(huart);
;;;480      }
;;;481    
;;;482      huart->gState = HAL_UART_STATE_BUSY;
;;;483    
;;;484      /* Disable the peripheral */
;;;485      __HAL_UART_DISABLE(huart);
;;;486      
;;;487      /* Set the UART Communication parameters */
;;;488      UART_SetConfig(huart);
;;;489      
;;;490      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;491         - LINEN and CLKEN bits in the USART_CR2 register,
;;;492         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;493      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;494      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;495      
;;;496      /* Set the USART address node */
;;;497      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
;;;498      
;;;499      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;500      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;501      
;;;502      /* Enable the peripheral */
;;;503      __HAL_UART_ENABLE(huart);
;;;504      
;;;505      /* Initialize the UART state */
;;;506      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;507      huart->gState = HAL_UART_STATE_READY;
;;;508      huart->RxState = HAL_UART_STATE_READY;
;;;509      
;;;510      return HAL_OK;
;;;511    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.30|
00001e  f8845038          STRB     r5,[r4,#0x38]         ;477
000022  4620              MOV      r0,r4                 ;479
000024  f7fffffe          BL       HAL_UART_MspInit
                  |L8.40|
000028  2024              MOVS     r0,#0x24              ;482
00002a  f8840039          STRB     r0,[r4,#0x39]         ;482
00002e  6820              LDR      r0,[r4,#0]            ;485
000030  68c1              LDR      r1,[r0,#0xc]          ;485
000032  f4215100          BIC      r1,r1,#0x2000         ;485
000036  60c1              STR      r1,[r0,#0xc]          ;485
000038  4620              MOV      r0,r4                 ;488
00003a  f7fffffe          BL       UART_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;493
000040  6901              LDR      r1,[r0,#0x10]         ;493
000042  f4214190          BIC      r1,r1,#0x4800         ;493
000046  6101              STR      r1,[r0,#0x10]         ;493
000048  6820              LDR      r0,[r4,#0]            ;494
00004a  6941              LDR      r1,[r0,#0x14]         ;494
00004c  f021012a          BIC      r1,r1,#0x2a           ;494
000050  6141              STR      r1,[r0,#0x14]         ;494
000052  6820              LDR      r0,[r4,#0]            ;497
000054  6901              LDR      r1,[r0,#0x10]         ;497
000056  f021010f          BIC      r1,r1,#0xf            ;497
00005a  4339              ORRS     r1,r1,r7              ;497
00005c  6101              STR      r1,[r0,#0x10]         ;497
00005e  6820              LDR      r0,[r4,#0]            ;500
000060  68c1              LDR      r1,[r0,#0xc]          ;500
000062  f4216100          BIC      r1,r1,#0x800          ;500
000066  4331              ORRS     r1,r1,r6              ;500
000068  60c1              STR      r1,[r0,#0xc]          ;500
00006a  6820              LDR      r0,[r4,#0]            ;503
00006c  68c1              LDR      r1,[r0,#0xc]          ;503
00006e  f4415100          ORR      r1,r1,#0x2000         ;503
000072  60c1              STR      r1,[r0,#0xc]          ;503
000074  63e5              STR      r5,[r4,#0x3c]         ;506
000076  2020              MOVS     r0,#0x20              ;507
000078  f8840039          STRB     r0,[r4,#0x39]         ;507
00007c  f884003a          STRB     r0,[r4,#0x3a]         ;508
000080  2000              MOVS     r0,#0                 ;510
000082  e7ca              B        |L8.26|
;;;512    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1160   */
;;;1161   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1162   {
000002  4604              MOV      r4,r0
;;;1163     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1164     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1165     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1166     
;;;1167     /* Disable the UART DMA Tx request if enabled */
;;;1168     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0609              LSLS     r1,r1,#24
000022  d509              BPL      |L9.56|
;;;1169     {
;;;1170       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210180          BIC      r1,r1,#0x80
00002a  6141              STR      r1,[r0,#0x14]
;;;1171   
;;;1172       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1173       if(huart->hdmatx != NULL)
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  b118              CBZ      r0,|L9.56|
;;;1174       {
;;;1175         /* Set the UART DMA Abort callback to Null. 
;;;1176            No call back execution at end of DMA abort procedure */
;;;1177         huart->hdmatx->XferAbortCallback = NULL;
000030  6345              STR      r5,[r0,#0x34]
;;;1178   
;;;1179         HAL_DMA_Abort(huart->hdmatx);
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L9.56|
;;;1180       }
;;;1181     }
;;;1182   
;;;1183     /* Disable the UART DMA Rx request if enabled */
;;;1184     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000038  6820              LDR      r0,[r4,#0]
00003a  6941              LDR      r1,[r0,#0x14]
00003c  0649              LSLS     r1,r1,#25
00003e  d509              BPL      |L9.84|
;;;1185     {
;;;1186       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6941              LDR      r1,[r0,#0x14]
000042  f0210140          BIC      r1,r1,#0x40
000046  6141              STR      r1,[r0,#0x14]
;;;1187   
;;;1188       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1189       if(huart->hdmarx != NULL)
000048  6b60              LDR      r0,[r4,#0x34]
00004a  b118              CBZ      r0,|L9.84|
;;;1190       {
;;;1191         /* Set the UART DMA Abort callback to Null. 
;;;1192            No call back execution at end of DMA abort procedure */
;;;1193         huart->hdmarx->XferAbortCallback = NULL;
00004c  6345              STR      r5,[r0,#0x34]
;;;1194   
;;;1195         HAL_DMA_Abort(huart->hdmarx);
00004e  6b60              LDR      r0,[r4,#0x34]
000050  f7fffffe          BL       HAL_DMA_Abort
                  |L9.84|
;;;1196       }
;;;1197     }
;;;1198   
;;;1199     /* Reset Tx and Rx transfer counters */
;;;1200     huart->TxXferCount = 0x00U;
000054  84e5              STRH     r5,[r4,#0x26]
;;;1201     huart->RxXferCount = 0x00U;
000056  85e5              STRH     r5,[r4,#0x2e]
;;;1202   
;;;1203     /* Reset ErrorCode */
;;;1204     huart->ErrorCode = HAL_UART_ERROR_NONE;
000058  63e5              STR      r5,[r4,#0x3c]
;;;1205   
;;;1206     /* Restore huart->RxState and huart->gState to Ready */
;;;1207     huart->RxState = HAL_UART_STATE_READY;
00005a  2020              MOVS     r0,#0x20
00005c  f884003a          STRB     r0,[r4,#0x3a]
;;;1208     huart->gState = HAL_UART_STATE_READY;
000060  f8840039          STRB     r0,[r4,#0x39]
;;;1209   
;;;1210     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1211   }
000066  bd70              POP      {r4-r6,pc}
;;;1212   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1757     */
;;;1758   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1759   {
;;;1760     /* Prevent unused argument(s) compilation warning */
;;;1761     UNUSED(huart);
;;;1762   
;;;1763     /* NOTE : This function should not be modified, when the callback is needed,
;;;1764               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1765      */
;;;1766   }
;;;1767   /**
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1266   */
;;;1267   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1268   {
000002  4604              MOV      r4,r0
;;;1269     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1270     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1271     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1272   
;;;1273     /* Disable the UART DMA Rx request if enabled */
;;;1274     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0649              LSLS     r1,r1,#25
000022  d509              BPL      |L11.56|
;;;1275     {
;;;1276       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210140          BIC      r1,r1,#0x40
00002a  6141              STR      r1,[r0,#0x14]
;;;1277   
;;;1278       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1279       if(huart->hdmarx != NULL)
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  b118              CBZ      r0,|L11.56|
;;;1280       {
;;;1281         /* Set the UART DMA Abort callback to Null. 
;;;1282            No call back execution at end of DMA abort procedure */
;;;1283         huart->hdmarx->XferAbortCallback = NULL;
000030  6345              STR      r5,[r0,#0x34]
;;;1284   
;;;1285         HAL_DMA_Abort(huart->hdmarx);
000032  6b60              LDR      r0,[r4,#0x34]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L11.56|
;;;1286       }
;;;1287     }
;;;1288   
;;;1289     /* Reset Rx transfer counter */
;;;1290     huart->RxXferCount = 0x00U;
000038  85e5              STRH     r5,[r4,#0x2e]
;;;1291   
;;;1292     /* Restore huart->RxState to Ready */
;;;1293     huart->RxState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  f884003a          STRB     r0,[r4,#0x3a]
;;;1294   
;;;1295     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1296   }
000042  bd70              POP      {r4-r6,pc}
;;;1297   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1786     */
;;;1787   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1788   {
;;;1789     /* Prevent unused argument(s) compilation warning */
;;;1790     UNUSED(huart);
;;;1791   
;;;1792     /* NOTE : This function should not be modified, when the callback is needed,
;;;1793               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1794      */
;;;1795   }
;;;1796   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1498   */
;;;1499   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1500   {
000002  4604              MOV      r4,r0
;;;1501     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1502     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1503     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1504   
;;;1505     /* Disable the UART DMA Rx request if enabled */
;;;1506     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0200          MOV      r2,#0
000020  064b              LSLS     r3,r1,#25
;;;1507     {
;;;1508       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1509   
;;;1510       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1511       if(huart->hdmarx != NULL)
;;;1512       {
;;;1513         /* Set the UART DMA Abort callback : 
;;;1514            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1515         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1516   
;;;1517         /* Abort DMA RX */
;;;1518         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1519         {
;;;1520           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1521           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1522         }
;;;1523       }
;;;1524       else
;;;1525       {
;;;1526         /* Reset Rx transfer counter */
;;;1527         huart->RxXferCount = 0x00U;
;;;1528   
;;;1529         /* Restore huart->RxState to Ready */
;;;1530         huart->RxState = HAL_UART_STATE_READY;
000022  f04f0120          MOV      r1,#0x20
000026  d516              BPL      |L13.86|
000028  6943              LDR      r3,[r0,#0x14]         ;1508
00002a  f0230340          BIC      r3,r3,#0x40           ;1508
00002e  6143              STR      r3,[r0,#0x14]         ;1508
000030  6b60              LDR      r0,[r4,#0x34]         ;1511
000032  b148              CBZ      r0,|L13.72|
000034  490c              LDR      r1,|L13.104|
000036  6341              STR      r1,[r0,#0x34]         ;1515
000038  6b60              LDR      r0,[r4,#0x34]         ;1518
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  b180              CBZ      r0,|L13.98|
000040  6b60              LDR      r0,[r4,#0x34]         ;1521
000042  6b41              LDR      r1,[r0,#0x34]         ;1521
000044  4788              BLX      r1                    ;1521
000046  e00c              B        |L13.98|
                  |L13.72|
000048  85e2              STRH     r2,[r4,#0x2e]         ;1527
00004a  f884103a          STRB     r1,[r4,#0x3a]
;;;1531   
;;;1532         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1533         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
000054  e005              B        |L13.98|
                  |L13.86|
;;;1534       }
;;;1535     }
;;;1536     else
;;;1537     {
;;;1538       /* Reset Rx transfer counter */
;;;1539       huart->RxXferCount = 0x00U;
000056  85e2              STRH     r2,[r4,#0x2e]
;;;1540   
;;;1541       /* Restore huart->RxState to Ready */
;;;1542       huart->RxState = HAL_UART_STATE_READY;
000058  f884103a          STRB     r1,[r4,#0x3a]
;;;1543   
;;;1544       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1545       HAL_UART_AbortReceiveCpltCallback(huart);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.98|
;;;1546     }
;;;1547   
;;;1548     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1549   }
000064  bd10              POP      {r4,pc}
;;;1550   
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1224   */
;;;1225   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1226   {
000002  4604              MOV      r4,r0
;;;1227     /* Disable TXEIE and TCIE interrupts */
;;;1228     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1229   
;;;1230     /* Disable the UART DMA Tx request if enabled */
;;;1231     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d509              BPL      |L14.46|
;;;1232     {
;;;1233       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6141              STR      r1,[r0,#0x14]
;;;1234   
;;;1235       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1236       if(huart->hdmatx != NULL)
000022  6b20              LDR      r0,[r4,#0x30]
000024  b118              CBZ      r0,|L14.46|
;;;1237       {
;;;1238         /* Set the UART DMA Abort callback to Null. 
;;;1239            No call back execution at end of DMA abort procedure */
;;;1240         huart->hdmatx->XferAbortCallback = NULL;
000026  6345              STR      r5,[r0,#0x34]
;;;1241   
;;;1242         HAL_DMA_Abort(huart->hdmatx);
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L14.46|
;;;1243       }
;;;1244     }
;;;1245   
;;;1246     /* Reset Tx transfer counter */
;;;1247     huart->TxXferCount = 0x00U;
00002e  84e5              STRH     r5,[r4,#0x26]
;;;1248   
;;;1249     /* Restore huart->gState to Ready */
;;;1250     huart->gState = HAL_UART_STATE_READY;
000030  2020              MOVS     r0,#0x20
000032  f8840039          STRB     r0,[r4,#0x39]
;;;1251   
;;;1252     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1253   }
000038  bd70              POP      {r4-r6,pc}
;;;1254   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1771     */
;;;1772   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1773   {
;;;1774     /* Prevent unused argument(s) compilation warning */
;;;1775     UNUSED(huart);
;;;1776   
;;;1777     /* NOTE : This function should not be modified, when the callback is needed,
;;;1778               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1779      */
;;;1780   }
;;;1781   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1433   */
;;;1434   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436     /* Disable TXEIE and TCIE interrupts */
;;;1437     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1438   
;;;1439     /* Disable the UART DMA Tx request if enabled */
;;;1440     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1441     {
;;;1442       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1443   
;;;1444       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1445       if(huart->hdmatx != NULL)
;;;1446       {
;;;1447         /* Set the UART DMA Abort callback : 
;;;1448            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1449         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1450   
;;;1451         /* Abort DMA TX */
;;;1452         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1453         {
;;;1454           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1455           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1456         }
;;;1457       }
;;;1458       else
;;;1459       {
;;;1460         /* Reset Tx transfer counter */
;;;1461         huart->TxXferCount = 0x00U;
;;;1462   
;;;1463         /* Restore huart->gState to Ready */
;;;1464         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;1440
000018  f04f0100          MOV      r1,#0                 ;1440
00001c  d516              BPL      |L16.76|
00001e  6943              LDR      r3,[r0,#0x14]         ;1442
000020  f0230380          BIC      r3,r3,#0x80           ;1442
000024  6143              STR      r3,[r0,#0x14]         ;1442
000026  6b20              LDR      r0,[r4,#0x30]         ;1445
000028  b148              CBZ      r0,|L16.62|
00002a  490c              LDR      r1,|L16.92|
00002c  6341              STR      r1,[r0,#0x34]         ;1449
00002e  6b20              LDR      r0,[r4,#0x30]         ;1452
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b180              CBZ      r0,|L16.88|
000036  6b20              LDR      r0,[r4,#0x30]         ;1455
000038  6b41              LDR      r1,[r0,#0x34]         ;1455
00003a  4788              BLX      r1                    ;1455
00003c  e00c              B        |L16.88|
                  |L16.62|
00003e  84e1              STRH     r1,[r4,#0x26]         ;1461
000040  f8842039          STRB     r2,[r4,#0x39]
;;;1465   
;;;1466         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1467         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
00004a  e005              B        |L16.88|
                  |L16.76|
;;;1468       }
;;;1469     }
;;;1470     else
;;;1471     {
;;;1472       /* Reset Tx transfer counter */
;;;1473       huart->TxXferCount = 0x00U;
00004c  84e1              STRH     r1,[r4,#0x26]
;;;1474   
;;;1475       /* Restore huart->gState to Ready */
;;;1476       huart->gState = HAL_UART_STATE_READY;
00004e  f8842039          STRB     r2,[r4,#0x39]
;;;1477   
;;;1478       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1479       HAL_UART_AbortTransmitCpltCallback(huart);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.88|
;;;1480     }
;;;1481   
;;;1482     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;1483   }
00005a  bd10              POP      {r4,pc}
;;;1484   
                          ENDP

                  |L16.92|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1311   */
;;;1312   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1313   {
000002  4604              MOV      r4,r0
;;;1314     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;1315   
;;;1316     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1317     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1318     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
;;;1319   
;;;1320     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1321        before any call to DMA Abort functions */
;;;1322     /* DMA Tx Handle is valid */
;;;1323     if(huart->hdmatx != NULL)
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  2600              MOVS     r6,#0
00001e  2800              CMP      r0,#0
000020  d007              BEQ      |L17.50|
;;;1324     {
;;;1325       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1326          Otherwise, set it to NULL */
;;;1327       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6821              LDR      r1,[r4,#0]
000024  6949              LDR      r1,[r1,#0x14]
000026  0609              LSLS     r1,r1,#24
000028  d502              BPL      |L17.48|
;;;1328       {
;;;1329         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002a  4920              LDR      r1,|L17.172|
00002c  6341              STR      r1,[r0,#0x34]
00002e  e000              B        |L17.50|
                  |L17.48|
;;;1330       }
;;;1331       else
;;;1332       {
;;;1333         huart->hdmatx->XferAbortCallback = NULL;
000030  6346              STR      r6,[r0,#0x34]
                  |L17.50|
;;;1334       }
;;;1335     }
;;;1336     /* DMA Rx Handle is valid */
;;;1337     if(huart->hdmarx != NULL)
000032  6b60              LDR      r0,[r4,#0x34]
000034  b138              CBZ      r0,|L17.70|
;;;1338     {
;;;1339       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1340          Otherwise, set it to NULL */
;;;1341       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000036  6821              LDR      r1,[r4,#0]
000038  6949              LDR      r1,[r1,#0x14]
00003a  0649              LSLS     r1,r1,#25
00003c  d502              BPL      |L17.68|
;;;1342       {
;;;1343         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00003e  491c              LDR      r1,|L17.176|
000040  6341              STR      r1,[r0,#0x34]
000042  e000              B        |L17.70|
                  |L17.68|
;;;1344       }
;;;1345       else
;;;1346       {
;;;1347         huart->hdmarx->XferAbortCallback = NULL;
000044  6346              STR      r6,[r0,#0x34]
                  |L17.70|
;;;1348       }
;;;1349     }
;;;1350   
;;;1351     /* Disable the UART DMA Tx request if enabled */
;;;1352     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  0609              LSLS     r1,r1,#24
00004c  d50c              BPL      |L17.104|
;;;1353     {
;;;1354       /* Disable DMA Tx at UART level */
;;;1355       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1356   
;;;1357       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1358       if(huart->hdmatx != NULL)
000056  6b20              LDR      r0,[r4,#0x30]
000058  b130              CBZ      r0,|L17.104|
;;;1359       {
;;;1360         /* UART Tx DMA Abort callback has already been initialised : 
;;;1361            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1362   
;;;1363         /* Abort DMA TX */
;;;1364         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  b110              CBZ      r0,|L17.102|
;;;1365         {
;;;1366           huart->hdmatx->XferAbortCallback = NULL;
000060  6b20              LDR      r0,[r4,#0x30]
000062  6346              STR      r6,[r0,#0x34]
000064  e000              B        |L17.104|
                  |L17.102|
;;;1367         }
;;;1368         else
;;;1369         {
;;;1370           AbortCplt = 0x00U;
000066  2500              MOVS     r5,#0
                  |L17.104|
;;;1371         }
;;;1372       }
;;;1373     }
;;;1374   
;;;1375     /* Disable the UART DMA Rx request if enabled */
;;;1376     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  0649              LSLS     r1,r1,#25
00006e  d50d              BPL      |L17.140|
;;;1377     {
;;;1378       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  6941              LDR      r1,[r0,#0x14]
000072  f0210140          BIC      r1,r1,#0x40
000076  6141              STR      r1,[r0,#0x14]
;;;1379   
;;;1380       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1381       if(huart->hdmarx != NULL)
000078  6b60              LDR      r0,[r4,#0x34]
00007a  b138              CBZ      r0,|L17.140|
;;;1382       {
;;;1383         /* UART Rx DMA Abort callback has already been initialised : 
;;;1384            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1385   
;;;1386         /* Abort DMA RX */
;;;1387         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  b118              CBZ      r0,|L17.138|
;;;1388         {
;;;1389           huart->hdmarx->XferAbortCallback = NULL;
000082  6b60              LDR      r0,[r4,#0x34]
000084  6346              STR      r6,[r0,#0x34]
;;;1390           AbortCplt = 0x01U;
000086  2501              MOVS     r5,#1
000088  e000              B        |L17.140|
                  |L17.138|
;;;1391         }
;;;1392         else
;;;1393         {
;;;1394           AbortCplt = 0x00U;
00008a  2500              MOVS     r5,#0
                  |L17.140|
;;;1395         }
;;;1396       }
;;;1397     }
;;;1398   
;;;1399     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1400     if(AbortCplt == 0x01U)
00008c  2d01              CMP      r5,#1
00008e  d10a              BNE      |L17.166|
;;;1401     {
;;;1402       /* Reset Tx and Rx transfer counters */
;;;1403       huart->TxXferCount = 0x00U; 
000090  84e6              STRH     r6,[r4,#0x26]
;;;1404       huart->RxXferCount = 0x00U;
000092  85e6              STRH     r6,[r4,#0x2e]
;;;1405   
;;;1406       /* Reset ErrorCode */
;;;1407       huart->ErrorCode = HAL_UART_ERROR_NONE;
000094  63e6              STR      r6,[r4,#0x3c]
;;;1408   
;;;1409       /* Restore huart->gState and huart->RxState to Ready */
;;;1410       huart->gState  = HAL_UART_STATE_READY;
000096  2020              MOVS     r0,#0x20
000098  f8840039          STRB     r0,[r4,#0x39]
;;;1411       huart->RxState = HAL_UART_STATE_READY;
00009c  f884003a          STRB     r0,[r4,#0x3a]
;;;1412   
;;;1413       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1414       HAL_UART_AbortCpltCallback(huart);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.166|
;;;1415     }
;;;1416   
;;;1417     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1418   }
0000a8  bd70              POP      {r4-r6,pc}
;;;1419   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L17.172|
                          DCD      UART_DMATxAbortCallback
                  |L17.176|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1035     */
;;;1036   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1037   {
;;;1038     uint32_t dmarequest = 0x00U;
;;;1039   
;;;1040     /* Process Locked */
;;;1041     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L18.32|
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
;;;1042   
;;;1043     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
000012  f3c212c0          UBFX     r2,r2,#7,#1
;;;1044     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000016  f8903039          LDRB     r3,[r0,#0x39]
00001a  2b21              CMP      r3,#0x21
00001c  d002              BEQ      |L18.36|
00001e  e006              B        |L18.46|
                  |L18.32|
000020  2002              MOVS     r0,#2                 ;1041
;;;1045     {
;;;1046       /* Disable the UART DMA Tx request */
;;;1047       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1048     }
;;;1049   
;;;1050     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1051     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1052     {
;;;1053       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1054       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1055       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1056   
;;;1057       /* Disable the UART DMA Rx request */
;;;1058       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1059     }
;;;1060   
;;;1061     /* Process Unlocked */
;;;1062     __HAL_UNLOCK(huart);
;;;1063     
;;;1064     return HAL_OK;
;;;1065   }
000022  4770              BX       lr
                  |L18.36|
000024  b11a              CBZ      r2,|L18.46|
000026  694a              LDR      r2,[r1,#0x14]         ;1047
000028  f0220280          BIC      r2,r2,#0x80           ;1047
00002c  614a              STR      r2,[r1,#0x14]         ;1047
                  |L18.46|
00002e  6801              LDR      r1,[r0,#0]            ;1050
000030  694a              LDR      r2,[r1,#0x14]         ;1050
000032  f3c21280          UBFX     r2,r2,#6,#1           ;1050
000036  f890303a          LDRB     r3,[r0,#0x3a]         ;1051
00003a  2b22              CMP      r3,#0x22              ;1051
00003c  d10e              BNE      |L18.92|
00003e  b16a              CBZ      r2,|L18.92|
000040  68ca              LDR      r2,[r1,#0xc]          ;1054
000042  f4227280          BIC      r2,r2,#0x100          ;1054
000046  60ca              STR      r2,[r1,#0xc]          ;1054
000048  6801              LDR      r1,[r0,#0]            ;1055
00004a  694a              LDR      r2,[r1,#0x14]         ;1055
00004c  f0220201          BIC      r2,r2,#1              ;1055
000050  614a              STR      r2,[r1,#0x14]         ;1055
000052  6801              LDR      r1,[r0,#0]            ;1058
000054  694a              LDR      r2,[r1,#0x14]         ;1058
000056  f0220240          BIC      r2,r2,#0x40           ;1058
00005a  614a              STR      r2,[r1,#0x14]         ;1058
                  |L18.92|
00005c  2100              MOVS     r1,#0                 ;1062
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1062
000062  2000              MOVS     r0,#0                 ;1064
000064  4770              BX       lr
;;;1066   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1072     */
;;;1073   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1074   {
;;;1075     /* Process Locked */
;;;1076     __HAL_LOCK(huart);
000002  f8901038          LDRB     r1,[r0,#0x38]
000006  2901              CMP      r1,#1
000008  d007              BEQ      |L19.26|
00000a  2101              MOVS     r1,#1
00000c  f8801038          STRB     r1,[r0,#0x38]
;;;1077     
;;;1078     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000010  f8901039          LDRB     r1,[r0,#0x39]
000014  2921              CMP      r1,#0x21
000016  d002              BEQ      |L19.30|
000018  e006              B        |L19.40|
                  |L19.26|
00001a  2002              MOVS     r0,#2                 ;1076
;;;1079     {
;;;1080       /* Enable the UART DMA Tx request */
;;;1081       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1082     }
;;;1083   
;;;1084     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1085     {
;;;1086       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1087       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1088       
;;;1089       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1090       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1091       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1092       
;;;1093       /* Enable the UART DMA Rx request */
;;;1094       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1095     }
;;;1096   
;;;1097     /* Process Unlocked */
;;;1098     __HAL_UNLOCK(huart);
;;;1099     
;;;1100     return HAL_OK;
;;;1101   }
00001c  bd08              POP      {r3,pc}
                  |L19.30|
00001e  6801              LDR      r1,[r0,#0]            ;1081
000020  694a              LDR      r2,[r1,#0x14]         ;1081
000022  f0420280          ORR      r2,r2,#0x80           ;1081
000026  614a              STR      r2,[r1,#0x14]         ;1081
                  |L19.40|
000028  f890103a          LDRB     r1,[r0,#0x3a]         ;1084
00002c  2200              MOVS     r2,#0                 ;1084
00002e  2922              CMP      r1,#0x22              ;1084
000030  d111              BNE      |L19.86|
000032  6801              LDR      r1,[r0,#0]            ;1087
000034  680b              LDR      r3,[r1,#0]            ;1087
000036  684b              LDR      r3,[r1,#4]            ;1087
000038  9300              STR      r3,[sp,#0]            ;1087
00003a  68cb              LDR      r3,[r1,#0xc]          ;1090
00003c  f4437380          ORR      r3,r3,#0x100          ;1090
000040  60cb              STR      r3,[r1,#0xc]          ;1090
000042  6801              LDR      r1,[r0,#0]            ;1091
000044  694b              LDR      r3,[r1,#0x14]         ;1091
000046  f0430301          ORR      r3,r3,#1              ;1091
00004a  614b              STR      r3,[r1,#0x14]         ;1091
00004c  6801              LDR      r1,[r0,#0]            ;1094
00004e  694b              LDR      r3,[r1,#0x14]         ;1094
000050  f0430340          ORR      r3,r3,#0x40           ;1094
000054  614b              STR      r3,[r1,#0x14]         ;1094
                  |L19.86|
000056  f8802038          STRB     r2,[r0,#0x38]         ;1098
00005a  2000              MOVS     r0,#0                 ;1100
00005c  bd08              POP      {r3,pc}
;;;1102   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1108     */
;;;1109   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1110   {
000002  4604              MOV      r4,r0
;;;1111     uint32_t dmarequest = 0x00U;
;;;1112     /* The Lock is not implemented on this API to allow the user application
;;;1113        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1114        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1115        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1116        */
;;;1117   
;;;1118     /* Stop UART DMA Tx request if ongoing */
;;;1119     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  f3c111c0          UBFX     r1,r1,#7,#1
;;;1120     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8942039          LDRB     r2,[r4,#0x39]
000010  2a21              CMP      r2,#0x21
000012  d10b              BNE      |L20.44|
000014  b151              CBZ      r1,|L20.44|
;;;1121     {
;;;1122       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1123   
;;;1124       /* Abort the UART DMA Tx channel */
;;;1125       if(huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b108              CBZ      r0,|L20.38|
;;;1126       {
;;;1127         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L20.38|
;;;1128       }
;;;1129       UART_EndTxTransfer(huart);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       UART_EndTxTransfer
                  |L20.44|
;;;1130     }
;;;1131   
;;;1132     /* Stop UART DMA Rx request if ongoing */
;;;1133     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  f3c11180          UBFX     r1,r1,#6,#1
;;;1134     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000034  f894203a          LDRB     r2,[r4,#0x3a]
000038  2a22              CMP      r2,#0x22
00003a  d10b              BNE      |L20.84|
00003c  b151              CBZ      r1,|L20.84|
;;;1135     {
;;;1136       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00003e  6941              LDR      r1,[r0,#0x14]
000040  f0210140          BIC      r1,r1,#0x40
000044  6141              STR      r1,[r0,#0x14]
;;;1137   
;;;1138       /* Abort the UART DMA Rx channel */
;;;1139       if(huart->hdmarx != NULL)
000046  6b60              LDR      r0,[r4,#0x34]
000048  b108              CBZ      r0,|L20.78|
;;;1140       {
;;;1141         HAL_DMA_Abort(huart->hdmarx);
00004a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.78|
;;;1142       }
;;;1143       UART_EndRxTransfer(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       UART_EndRxTransfer
                  |L20.84|
;;;1144     }
;;;1145   
;;;1146     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1147   }
000056  bd10              POP      {r4,pc}
;;;1148   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;518      */
;;;519    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;520    {
000002  4604              MOV      r4,r0
;;;521      /* Check the UART handle allocation */
;;;522      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d00c              BEQ      |L21.34|
;;;523      {
;;;524        return HAL_ERROR;
;;;525      }
;;;526    
;;;527      /* Check the parameters */
;;;528      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;529    
;;;530      huart->gState = HAL_UART_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  f8840039          STRB     r0,[r4,#0x39]
;;;531    
;;;532      /* DeInit the low level hardware */
;;;533      HAL_UART_MspDeInit(huart);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_UART_MspDeInit
;;;534    
;;;535      huart->ErrorCode = HAL_UART_ERROR_NONE;
000014  2000              MOVS     r0,#0
000016  3438              ADDS     r4,r4,#0x38
000018  6060              STR      r0,[r4,#4]
;;;536      huart->gState = HAL_UART_STATE_RESET;
00001a  7060              STRB     r0,[r4,#1]
;;;537      huart->RxState = HAL_UART_STATE_RESET;
00001c  70a0              STRB     r0,[r4,#2]
;;;538    
;;;539      /* Process Unlock */
;;;540      __HAL_UNLOCK(huart);
00001e  7020              STRB     r0,[r4,#0]
;;;541    
;;;542      return HAL_OK;
;;;543    }
000020  bd10              POP      {r4,pc}
                  |L21.34|
000022  2001              MOVS     r0,#1                 ;524
000024  bd10              POP      {r4,pc}
;;;544    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1743     */
;;;1744    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1745   {
;;;1746     /* Prevent unused argument(s) compilation warning */
;;;1747     UNUSED(huart); 
;;;1748     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1749              the HAL_UART_ErrorCallback could be implemented in the user file
;;;1750      */ 
;;;1751   }
;;;1752   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2013     */
;;;2014   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2015   {
;;;2016     return huart->ErrorCode;
;;;2017   }
000002  4770              BX       lr
;;;2018   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1998     */
;;;1999   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2000   {
;;;2001     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;2002     temp1 = huart->gState;
000002  f8110f39          LDRB     r0,[r1,#0x39]!
;;;2003     temp2 = huart->RxState;
000006  7849              LDRB     r1,[r1,#1]
;;;2004     
;;;2005     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000008  4308              ORRS     r0,r0,r1
;;;2006   }
00000a  4770              BX       lr
;;;2007   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1556     */
;;;1557   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
000002  4604              MOV      r4,r0
;;;1559      uint32_t isrflags   = READ_REG(huart->Instance->SR);
000004  6822              LDR      r2,[r4,#0]
000006  6810              LDR      r0,[r2,#0]
;;;1560      uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;1561      uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  6952              LDR      r2,[r2,#0x14]
;;;1562      uint32_t errorflags = 0x00U;
;;;1563      uint32_t dmarequest = 0x00U;
;;;1564   
;;;1565     /* If no error occurs */
;;;1566     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f000030f          AND      r3,r0,#0xf
;;;1567     if(errorflags == RESET)
000010  2b00              CMP      r3,#0
000012  d108              BNE      |L25.38|
;;;1568     {
;;;1569       /* UART in mode Receiver -------------------------------------------------*/
;;;1570       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000014  0685              LSLS     r5,r0,#26
000016  d506              BPL      |L25.38|
000018  068d              LSLS     r5,r1,#26
00001a  d504              BPL      |L25.38|
;;;1571       {
;;;1572         UART_Receive_IT(huart);
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      UART_Receive_IT
                  |L25.38|
;;;1573         return;
;;;1574       }
;;;1575     }
;;;1576   
;;;1577     /* If some errors occur */
;;;1578     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000026  2b00              CMP      r3,#0
000028  d05f              BEQ      |L25.234|
00002a  f0020301          AND      r3,r2,#1
00002e  f4017590          AND      r5,r1,#0x120
000032  432b              ORRS     r3,r3,r5
000034  d059              BEQ      |L25.234|
;;;1579     {
;;;1580       /* UART parity error interrupt occurred ----------------------------------*/
;;;1581       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000036  07c3              LSLS     r3,r0,#31
000038  d005              BEQ      |L25.70|
00003a  05cb              LSLS     r3,r1,#23
00003c  d503              BPL      |L25.70|
;;;1582       {
;;;1583         huart->ErrorCode |= HAL_UART_ERROR_PE;
00003e  6be3              LDR      r3,[r4,#0x3c]
000040  f0430301          ORR      r3,r3,#1
000044  63e3              STR      r3,[r4,#0x3c]
                  |L25.70|
;;;1584       }
;;;1585   
;;;1586       /* UART noise error interrupt occurred -----------------------------------*/
;;;1587       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000046  0743              LSLS     r3,r0,#29
000048  d505              BPL      |L25.86|
00004a  07d3              LSLS     r3,r2,#31
00004c  d003              BEQ      |L25.86|
;;;1588       {
;;;1589         huart->ErrorCode |= HAL_UART_ERROR_NE;
00004e  6be3              LDR      r3,[r4,#0x3c]
000050  f0430302          ORR      r3,r3,#2
000054  63e3              STR      r3,[r4,#0x3c]
                  |L25.86|
;;;1590       }
;;;1591   
;;;1592       /* UART frame error interrupt occurred -----------------------------------*/
;;;1593       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  0783              LSLS     r3,r0,#30
000058  d505              BPL      |L25.102|
00005a  07d3              LSLS     r3,r2,#31
00005c  d003              BEQ      |L25.102|
;;;1594       {
;;;1595         huart->ErrorCode |= HAL_UART_ERROR_FE;
00005e  6be3              LDR      r3,[r4,#0x3c]
000060  f0430304          ORR      r3,r3,#4
000064  63e3              STR      r3,[r4,#0x3c]
                  |L25.102|
;;;1596       }
;;;1597   
;;;1598       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;1599       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000066  0703              LSLS     r3,r0,#28
000068  d505              BPL      |L25.118|
00006a  07d2              LSLS     r2,r2,#31
00006c  d003              BEQ      |L25.118|
;;;1600       { 
;;;1601         huart->ErrorCode |= HAL_UART_ERROR_ORE;
00006e  6be2              LDR      r2,[r4,#0x3c]
000070  f0420208          ORR      r2,r2,#8
000074  63e2              STR      r2,[r4,#0x3c]
                  |L25.118|
;;;1602       }
;;;1603   
;;;1604       /* Call UART Error Call back function if need be --------------------------*/
;;;1605       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000076  6be2              LDR      r2,[r4,#0x3c]
000078  2a00              CMP      r2,#0
00007a  d02b              BEQ      |L25.212|
;;;1606       {
;;;1607         /* UART in mode Receiver -----------------------------------------------*/
;;;1608         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00007c  0680              LSLS     r0,r0,#26
00007e  d504              BPL      |L25.138|
000080  0688              LSLS     r0,r1,#26
000082  d502              BPL      |L25.138|
;;;1609         {
;;;1610           UART_Receive_IT(huart);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       UART_Receive_IT
                  |L25.138|
;;;1611         }
;;;1612   
;;;1613         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1614            consider error as blocking */
;;;1615         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00008a  6820              LDR      r0,[r4,#0]
00008c  6940              LDR      r0,[r0,#0x14]
00008e  f3c01080          UBFX     r0,r0,#6,#1
;;;1616         if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
000092  6be1              LDR      r1,[r4,#0x3c]
000094  f0010108          AND      r1,r1,#8
000098  4301              ORRS     r1,r1,r0
00009a  d020              BEQ      |L25.222|
;;;1617         {
;;;1618           /* Blocking error : transfer is aborted
;;;1619              Set the UART state ready to be able to start again the process,
;;;1620              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1621           UART_EndRxTransfer(huart);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       UART_EndRxTransfer
;;;1622   
;;;1623           /* Disable the UART DMA Rx request if enabled */
;;;1624           if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6941              LDR      r1,[r0,#0x14]
0000a6  0649              LSLS     r1,r1,#25
0000a8  d515              BPL      |L25.214|
;;;1625           {
;;;1626             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000aa  6941              LDR      r1,[r0,#0x14]
0000ac  f0210140          BIC      r1,r1,#0x40
0000b0  6141              STR      r1,[r0,#0x14]
;;;1627   
;;;1628             /* Abort the UART DMA Rx channel */
;;;1629             if(huart->hdmarx != NULL)
0000b2  6b60              LDR      r0,[r4,#0x34]
0000b4  b158              CBZ      r0,|L25.206|
;;;1630             {
;;;1631               /* Set the UART DMA Abort callback : 
;;;1632                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1633               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000b6  4916              LDR      r1,|L25.272|
0000b8  6341              STR      r1,[r0,#0x34]
;;;1634               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000ba  6b60              LDR      r0,[r4,#0x34]
0000bc  f7fffffe          BL       HAL_DMA_Abort_IT
0000c0  2800              CMP      r0,#0
0000c2  d007              BEQ      |L25.212|
;;;1635               {
;;;1636                 /* Call Directly XferAbortCallback function in case of error */
;;;1637                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000c4  6b60              LDR      r0,[r4,#0x34]
0000c6  6b41              LDR      r1,[r0,#0x34]
0000c8  e8bd4070          POP      {r4-r6,lr}
0000cc  4708              BX       r1
                  |L25.206|
;;;1638               }
;;;1639             }
;;;1640             else
;;;1641             {
;;;1642               /* Call user error callback */
;;;1643               HAL_UART_ErrorCallback(huart);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L25.212|
;;;1644             }
;;;1645           }
;;;1646           else
;;;1647           {
;;;1648             /* Call user error callback */
;;;1649             HAL_UART_ErrorCallback(huart);
;;;1650           }
;;;1651         }
;;;1652         else
;;;1653         {
;;;1654           /* Non Blocking error : transfer could go on. 
;;;1655              Error is notified to user through user error callback */
;;;1656           HAL_UART_ErrorCallback(huart);
;;;1657           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1658         }
;;;1659       }
;;;1660       return;
;;;1661     } /* End if some error occurs */
;;;1662   
;;;1663     /* UART in mode Transmitter ------------------------------------------------*/
;;;1664     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1665     {
;;;1666       UART_Transmit_IT(huart);
;;;1667       return;
;;;1668     }
;;;1669     
;;;1670     /* UART in mode Transmitter end --------------------------------------------*/
;;;1671     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1672     {
;;;1673       UART_EndTransmit_IT(huart);
;;;1674       return;
;;;1675     }
;;;1676   }
0000d4  bd70              POP      {r4-r6,pc}
                  |L25.214|
0000d6  4620              MOV      r0,r4                 ;1649
0000d8  f7fffffe          BL       HAL_UART_ErrorCallback
0000dc  bd70              POP      {r4-r6,pc}
                  |L25.222|
0000de  4620              MOV      r0,r4                 ;1656
0000e0  f7fffffe          BL       HAL_UART_ErrorCallback
0000e4  2000              MOVS     r0,#0                 ;1657
0000e6  63e0              STR      r0,[r4,#0x3c]         ;1657
                  |L25.232|
0000e8  bd70              POP      {r4-r6,pc}
                  |L25.234|
0000ea  0602              LSLS     r2,r0,#24             ;1664
0000ec  d506              BPL      |L25.252|
0000ee  060a              LSLS     r2,r1,#24             ;1664
0000f0  d504              BPL      |L25.252|
0000f2  4620              MOV      r0,r4                 ;1666
0000f4  e8bd4070          POP      {r4-r6,lr}            ;1666
0000f8  f7ffbffe          B.W      UART_Transmit_IT
                  |L25.252|
0000fc  0640              LSLS     r0,r0,#25             ;1671
0000fe  d5f3              BPL      |L25.232|
000100  0648              LSLS     r0,r1,#25             ;1671
000102  d5f1              BPL      |L25.232|
000104  4620              MOV      r0,r4                 ;1673
000106  e8bd4070          POP      {r4-r6,lr}            ;1673
00010a  f7ffbffe          B.W      UART_EndTransmit_IT
;;;1677   
                          ENDP

00010e  0000              DCW      0x0000
                  |L25.272|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;260      */
;;;261    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;262    {
000002  4604              MOV      r4,r0
;;;263      /* Check the UART handle allocation */
;;;264      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L26.18|
;;;265      {
;;;266        return HAL_ERROR;
;;;267      }
;;;268    
;;;269      /* Check the parameters */
;;;270      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;271      {
;;;272        /* The hardware flow control is available only for USART1, USART2, USART3 */
;;;273        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;274        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;275      }
;;;276      else
;;;277      {
;;;278        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;279      }
;;;280      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;281    #if defined(USART_CR1_OVER8)
;;;282      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;283    #endif /* USART_CR1_OVER8 */
;;;284      
;;;285      if(huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L26.22|
000010  e006              B        |L26.32|
                  |L26.18|
000012  2001              MOVS     r0,#1                 ;266
;;;286      {  
;;;287        /* Allocate lock resource and initialize it */
;;;288        huart->Lock = HAL_UNLOCKED;
;;;289    
;;;290        /* Init the low level hardware */
;;;291        HAL_UART_MspInit(huart);
;;;292      }
;;;293    
;;;294      huart->gState = HAL_UART_STATE_BUSY;
;;;295    
;;;296      /* Disable the peripheral */
;;;297      __HAL_UART_DISABLE(huart);
;;;298      
;;;299      /* Set the UART Communication parameters */
;;;300      UART_SetConfig(huart);
;;;301      
;;;302      /* In asynchronous mode, the following bits must be kept cleared: 
;;;303         - LINEN and CLKEN bits in the USART_CR2 register,
;;;304         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;305      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;306      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;307      
;;;308      /* Enable the peripheral */
;;;309      __HAL_UART_ENABLE(huart);
;;;310      
;;;311      /* Initialize the UART state */
;;;312      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;313      huart->gState= HAL_UART_STATE_READY;
;;;314      huart->RxState= HAL_UART_STATE_READY;
;;;315      
;;;316      return HAL_OK;
;;;317    }
000014  bd70              POP      {r4-r6,pc}
                  |L26.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;288
00001a  4620              MOV      r0,r4                 ;291
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L26.32|
000020  2024              MOVS     r0,#0x24              ;294
000022  f8840039          STRB     r0,[r4,#0x39]         ;294
000026  6820              LDR      r0,[r4,#0]            ;297
000028  68c1              LDR      r1,[r0,#0xc]          ;297
00002a  f4215100          BIC      r1,r1,#0x2000         ;297
00002e  60c1              STR      r1,[r0,#0xc]          ;297
000030  4620              MOV      r0,r4                 ;300
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;305
000038  6901              LDR      r1,[r0,#0x10]         ;305
00003a  f4214190          BIC      r1,r1,#0x4800         ;305
00003e  6101              STR      r1,[r0,#0x10]         ;305
000040  6820              LDR      r0,[r4,#0]            ;306
000042  6941              LDR      r1,[r0,#0x14]         ;306
000044  f021012a          BIC      r1,r1,#0x2a           ;306
000048  6141              STR      r1,[r0,#0x14]         ;306
00004a  6820              LDR      r0,[r4,#0]            ;309
00004c  68c1              LDR      r1,[r0,#0xc]          ;309
00004e  f4415100          ORR      r1,r1,#0x2000         ;309
000052  60c1              STR      r1,[r0,#0xc]          ;309
000054  63e5              STR      r5,[r4,#0x3c]         ;312
000056  2020              MOVS     r0,#0x20              ;313
000058  f8840039          STRB     r0,[r4,#0x39]         ;313
00005c  f884003a          STRB     r0,[r4,#0x3a]         ;314
000060  2000              MOVS     r0,#0                 ;316
000062  bd70              POP      {r4-r6,pc}
;;;318    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;565      */
;;;566    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;567    {
;;;568      /* Prevent unused argument(s) compilation warning */
;;;569      UNUSED(huart);
;;;570      /* NOTE: This function should not be modified, when the callback is needed,
;;;571               the HAL_UART_MspDeInit could be implemented in the user file
;;;572       */
;;;573    }
;;;574    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;550      */
;;;551    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;552    {
;;;553      /* Prevent unused argument(s) compilation warning */
;;;554      UNUSED(huart);
;;;555      /* NOTE: This function should not be modified, when the callback is needed,
;;;556               the HAL_UART_MspInit could be implemented in the user file
;;;557       */
;;;558    }
;;;559    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;728    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;729      uint16_t* tmp;
;;;730      uint32_t tickstart = 0U;
;;;731      
;;;732      /* Check that a Rx process is not already ongoing */
;;;733      if(huart->RxState == HAL_UART_STATE_READY)
00000c  f894003a          LDRB     r0,[r4,#0x3a]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L29.26|
;;;734      {
;;;735        if((pData == NULL) || (Size == 0U))
;;;736        {
;;;737          return  HAL_ERROR;
;;;738        }
;;;739    
;;;740        /* Process Locked */
;;;741        __HAL_LOCK(huart);
;;;742        
;;;743        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;744        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;745    
;;;746        /* Init tickstart for timeout managment */
;;;747        tickstart = HAL_GetTick();
;;;748    
;;;749        huart->RxXferSize = Size;
;;;750        huart->RxXferCount = Size;
;;;751    
;;;752        /* Check the remain data to be received */
;;;753        while(huart->RxXferCount > 0U)
;;;754        {
;;;755          huart->RxXferCount--;
;;;756          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;757          {
;;;758            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;759            {
;;;760              return HAL_TIMEOUT;
;;;761            }
;;;762            tmp = (uint16_t*)pData;
;;;763            if(huart->Init.Parity == UART_PARITY_NONE)
;;;764            {
;;;765              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;766              pData +=2U;
;;;767            }
;;;768            else
;;;769            {
;;;770              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;771              pData +=1U;
;;;772            }
;;;773    
;;;774          } 
;;;775          else
;;;776          {
;;;777            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;778            {
;;;779              return HAL_TIMEOUT;
;;;780            }
;;;781            if(huart->Init.Parity == UART_PARITY_NONE)
;;;782            {
;;;783              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;784            }
;;;785            else
;;;786            {
;;;787              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;788            }
;;;789    
;;;790          }
;;;791        }
;;;792    
;;;793        /* At end of Rx process, restore huart->RxState to Ready */
;;;794        huart->RxState = HAL_UART_STATE_READY;
;;;795        
;;;796        /* Process Unlocked */
;;;797        __HAL_UNLOCK(huart);
;;;798    
;;;799        return HAL_OK;
;;;800      }
;;;801      else
;;;802      {
;;;803        return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L29.22|
;;;804      }
;;;805    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L29.26|
00001a  b1b5              CBZ      r5,|L29.74|
00001c  f1b90f00          CMP      r9,#0                 ;735
000020  d013              BEQ      |L29.74|
000022  f8940038          LDRB     r0,[r4,#0x38]         ;741
000026  2801              CMP      r0,#1                 ;741
000028  d011              BEQ      |L29.78|
00002a  2001              MOVS     r0,#1                 ;741
00002c  f8840038          STRB     r0,[r4,#0x38]         ;741
000030  2700              MOVS     r7,#0                 ;743
000032  63e7              STR      r7,[r4,#0x3c]         ;743
000034  2022              MOVS     r0,#0x22              ;744
000036  f884003a          STRB     r0,[r4,#0x3a]         ;744
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;747
000040  f8a4902c          STRH     r9,[r4,#0x2c]         ;749
000044  f8a4902e          STRH     r9,[r4,#0x2e]         ;750
000048  e035              B        |L29.182|
                  |L29.74|
00004a  2001              MOVS     r0,#1                 ;737
00004c  e7e3              B        |L29.22|
                  |L29.78|
00004e  2002              MOVS     r0,#2                 ;741
000050  e7e1              B        |L29.22|
                  |L29.82|
000052  8de0              LDRH     r0,[r4,#0x2e]         ;755
000054  1e40              SUBS     r0,r0,#1              ;755
000056  85e0              STRH     r0,[r4,#0x2e]         ;755
000058  68a0              LDR      r0,[r4,#8]            ;756
00005a  f5b05f80          CMP      r0,#0x1000            ;756
00005e  d009              BEQ      |L29.116|
000060  4643              MOV      r3,r8                 ;777
000062  2200              MOVS     r2,#0                 ;777
000064  2120              MOVS     r1,#0x20              ;777
000066  4620              MOV      r0,r4                 ;777
000068  9600              STR      r6,[sp,#0]            ;777
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b1d0              CBZ      r0,|L29.166|
000070  2003              MOVS     r0,#3                 ;779
000072  e7d0              B        |L29.22|
                  |L29.116|
000074  4643              MOV      r3,r8                 ;758
000076  2200              MOVS     r2,#0                 ;758
000078  2120              MOVS     r1,#0x20              ;758
00007a  4620              MOV      r0,r4                 ;758
00007c  9600              STR      r6,[sp,#0]            ;758
00007e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L29.136|
000084  2003              MOVS     r0,#3                 ;760
000086  e7c6              B        |L29.22|
                  |L29.136|
000088  6920              LDR      r0,[r4,#0x10]         ;763
00008a  b128              CBZ      r0,|L29.152|
00008c  6820              LDR      r0,[r4,#0]            ;770
00008e  6840              LDR      r0,[r0,#4]            ;770
000090  b2c1              UXTB     r1,r0                 ;770
000092  8029              STRH     r1,[r5,#0]            ;770
000094  1c6d              ADDS     r5,r5,#1              ;771
000096  e00e              B        |L29.182|
                  |L29.152|
000098  6820              LDR      r0,[r4,#0]            ;765
00009a  6840              LDR      r0,[r0,#4]            ;765
00009c  f3c00108          UBFX     r1,r0,#0,#9           ;765
0000a0  8029              STRH     r1,[r5,#0]            ;765
0000a2  1cad              ADDS     r5,r5,#2              ;766
0000a4  e007              B        |L29.182|
                  |L29.166|
0000a6  6920              LDR      r0,[r4,#0x10]         ;781
0000a8  b170              CBZ      r0,|L29.200|
0000aa  6820              LDR      r0,[r4,#0]            ;787
0000ac  6840              LDR      r0,[r0,#4]            ;787
0000ae  f000007f          AND      r0,r0,#0x7f           ;787
0000b2  f8050b01          STRB     r0,[r5],#1            ;787
                  |L29.182|
0000b6  8de0              LDRH     r0,[r4,#0x2e]         ;753
0000b8  2800              CMP      r0,#0                 ;753
0000ba  d1ca              BNE      |L29.82|
0000bc  2020              MOVS     r0,#0x20              ;794
0000be  3438              ADDS     r4,r4,#0x38           ;794
0000c0  70a0              STRB     r0,[r4,#2]            ;794
0000c2  7027              STRB     r7,[r4,#0]            ;797
0000c4  2000              MOVS     r0,#0                 ;799
0000c6  e7a6              B        |L29.22|
                  |L29.200|
0000c8  6820              LDR      r0,[r4,#0]            ;783
0000ca  6840              LDR      r0,[r0,#4]            ;783
0000cc  f8050b01          STRB     r0,[r5],#1            ;783
0000d0  e7f1              B        |L29.182|
;;;806    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;968      */
;;;969    HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;970    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4613              MOV      r3,r2
;;;971      uint32_t *tmp;
;;;972      
;;;973      /* Check that a Rx process is not already ongoing */
;;;974      if(huart->RxState == HAL_UART_STATE_READY) 
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  2820              CMP      r0,#0x20
00000e  d002              BEQ      |L30.22|
;;;975      {
;;;976        if((pData == NULL) || (Size == 0U))
;;;977        {
;;;978          return HAL_ERROR;
;;;979        }
;;;980    
;;;981        /* Process Locked */
;;;982        __HAL_LOCK(huart);
;;;983    
;;;984        huart->pRxBuffPtr = pData;
;;;985        huart->RxXferSize = Size;
;;;986    
;;;987        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;988        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;989    
;;;990        /* Set the UART DMA transfer complete callback */
;;;991        huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;992    
;;;993        /* Set the UART DMA Half transfer complete callback */
;;;994        huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;995    
;;;996        /* Set the DMA error callback */
;;;997        huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;998    
;;;999        /* Set the DMA abort callback */
;;;1000       huart->hdmarx->XferAbortCallback = NULL;
;;;1001   
;;;1002       /* Enable the DMA channel */
;;;1003       tmp = (uint32_t*)&pData;
;;;1004       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1005   
;;;1006       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1007       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1008   
;;;1009       /* Process Unlocked */
;;;1010       __HAL_UNLOCK(huart);
;;;1011   
;;;1012       /* Enable the UART Parity Error Interrupt */
;;;1013       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1014   
;;;1015       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1016       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1017   
;;;1018       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1019       in the UART CR3 register */
;;;1020       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1021   
;;;1022       return HAL_OK;
;;;1023     }
;;;1024     else
;;;1025     {
;;;1026       return HAL_BUSY;
000010  2002              MOVS     r0,#2
                  |L30.18|
;;;1027     }
;;;1028   }
000012  b005              ADD      sp,sp,#0x14
000014  bd30              POP      {r4,r5,pc}
                  |L30.22|
000016  9a03              LDR      r2,[sp,#0xc]          ;976
000018  b3a2              CBZ      r2,|L30.132|
00001a  b39b              CBZ      r3,|L30.132|
00001c  f8940038          LDRB     r0,[r4,#0x38]         ;982
000020  2801              CMP      r0,#1                 ;982
000022  d032              BEQ      |L30.138|
000024  2001              MOVS     r0,#1                 ;982
000026  f8840038          STRB     r0,[r4,#0x38]         ;982
00002a  62a2              STR      r2,[r4,#0x28]         ;984
00002c  85a3              STRH     r3,[r4,#0x2c]         ;985
00002e  2500              MOVS     r5,#0                 ;987
000030  63e5              STR      r5,[r4,#0x3c]         ;987
000032  2022              MOVS     r0,#0x22              ;988
000034  f884003a          STRB     r0,[r4,#0x3a]         ;988
000038  6b61              LDR      r1,[r4,#0x34]         ;991
00003a  4815              LDR      r0,|L30.144|
00003c  6288              STR      r0,[r1,#0x28]         ;991
00003e  6b61              LDR      r1,[r4,#0x34]         ;994
000040  4814              LDR      r0,|L30.148|
000042  62c8              STR      r0,[r1,#0x2c]         ;994
000044  6b61              LDR      r1,[r4,#0x34]         ;997
000046  4814              LDR      r0,|L30.152|
000048  6308              STR      r0,[r1,#0x30]         ;997
00004a  6b60              LDR      r0,[r4,#0x34]         ;1000
00004c  6345              STR      r5,[r0,#0x34]         ;1000
00004e  6821              LDR      r1,[r4,#0]            ;1004
000050  6b60              LDR      r0,[r4,#0x34]         ;1004
000052  1d09              ADDS     r1,r1,#4              ;1004
000054  f7fffffe          BL       HAL_DMA_Start_IT
000058  6820              LDR      r0,[r4,#0]            ;1007
00005a  6801              LDR      r1,[r0,#0]            ;1007
00005c  6841              LDR      r1,[r0,#4]            ;1007
00005e  9101              STR      r1,[sp,#4]            ;1007
000060  f8845038          STRB     r5,[r4,#0x38]         ;1010
000064  68c1              LDR      r1,[r0,#0xc]          ;1013
000066  f4417180          ORR      r1,r1,#0x100          ;1013
00006a  60c1              STR      r1,[r0,#0xc]          ;1013
00006c  6820              LDR      r0,[r4,#0]            ;1016
00006e  6941              LDR      r1,[r0,#0x14]         ;1016
000070  f0410101          ORR      r1,r1,#1              ;1016
000074  6141              STR      r1,[r0,#0x14]         ;1016
000076  6820              LDR      r0,[r4,#0]            ;1020
000078  6941              LDR      r1,[r0,#0x14]         ;1020
00007a  f0410140          ORR      r1,r1,#0x40           ;1020
00007e  6141              STR      r1,[r0,#0x14]         ;1020
000080  2000              MOVS     r0,#0                 ;1022
000082  e7c6              B        |L30.18|
                  |L30.132|
000084  e7ff              B        |L30.134|
                  |L30.134|
000086  2001              MOVS     r0,#1                 ;978
000088  e7c3              B        |L30.18|
                  |L30.138|
00008a  2002              MOVS     r0,#2                 ;982
00008c  e7c1              B        |L30.18|
;;;1029   
                          ENDP

00008e  0000              DCW      0x0000
                  |L30.144|
                          DCD      UART_DMAReceiveCplt
                  |L30.148|
                          DCD      UART_DMARxHalfCplt
                  |L30.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;855      */
;;;856    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f890303a          LDRB     r3,[r0,#0x3a]
;;;857    {
;;;858      /* Check that a Rx process is not already ongoing */
;;;859      if(huart->RxState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L31.12|
;;;860      {
;;;861        if((pData == NULL) || (Size == 0U))
;;;862        {
;;;863          return HAL_ERROR;
;;;864        }
;;;865    
;;;866        /* Process Locked */
;;;867        __HAL_LOCK(huart);
;;;868    
;;;869        huart->pRxBuffPtr = pData;
;;;870        huart->RxXferSize = Size;
;;;871        huart->RxXferCount = Size;
;;;872    
;;;873        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;874        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;875        
;;;876        /* Process Unlocked */
;;;877        __HAL_UNLOCK(huart);
;;;878    
;;;879        /* Enable the UART Parity Error Interrupt */
;;;880        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;881    
;;;882        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;883        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;884    
;;;885        /* Enable the UART Data Register not empty Interrupt */
;;;886        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;887    
;;;888        return HAL_OK;
;;;889      }
;;;890      else
;;;891      {
;;;892        return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;893      }
;;;894    }
00000a  4770              BX       lr
                  |L31.12|
00000c  b1f9              CBZ      r1,|L31.78|
00000e  b1f2              CBZ      r2,|L31.78|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;867
000014  2b01              CMP      r3,#1                 ;867
000016  d01c              BEQ      |L31.82|
000018  6281              STR      r1,[r0,#0x28]         ;869
00001a  8582              STRH     r2,[r0,#0x2c]         ;870
00001c  85c2              STRH     r2,[r0,#0x2e]         ;871
00001e  2100              MOVS     r1,#0                 ;873
000020  63c1              STR      r1,[r0,#0x3c]         ;873
000022  2222              MOVS     r2,#0x22              ;874
000024  f880203a          STRB     r2,[r0,#0x3a]         ;874
000028  f8801038          STRB     r1,[r0,#0x38]         ;877
00002c  6801              LDR      r1,[r0,#0]            ;880
00002e  68ca              LDR      r2,[r1,#0xc]          ;880
000030  f4427280          ORR      r2,r2,#0x100          ;880
000034  60ca              STR      r2,[r1,#0xc]          ;880
000036  6801              LDR      r1,[r0,#0]            ;883
000038  694a              LDR      r2,[r1,#0x14]         ;883
00003a  f0420201          ORR      r2,r2,#1              ;883
00003e  614a              STR      r2,[r1,#0x14]         ;883
000040  6800              LDR      r0,[r0,#0]            ;886
000042  68c1              LDR      r1,[r0,#0xc]          ;886
000044  f0410120          ORR      r1,r1,#0x20           ;886
000048  60c1              STR      r1,[r0,#0xc]          ;886
00004a  2000              MOVS     r0,#0                 ;888
00004c  4770              BX       lr
                  |L31.78|
00004e  2001              MOVS     r0,#1                 ;863
000050  4770              BX       lr
                  |L31.82|
000052  2002              MOVS     r0,#2                 ;867
000054  4770              BX       lr
;;;895    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1713     */
;;;1714   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1715   {
;;;1716     /* Prevent unused argument(s) compilation warning */
;;;1717     UNUSED(huart);
;;;1718     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1719              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;1720      */
;;;1721   }
;;;1722   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1728     */
;;;1729   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1730   {
;;;1731     /* Prevent unused argument(s) compilation warning */
;;;1732     UNUSED(huart);
;;;1733     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1734              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;1735      */
;;;1736   }
;;;1737   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;644      */
;;;645    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;646    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;647      uint16_t* tmp;
;;;648      uint32_t tickstart = 0U;
;;;649      
;;;650      /* Check that a Tx process is not already ongoing */
;;;651      if(huart->gState == HAL_UART_STATE_READY)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L34.26|
;;;652      {
;;;653        if((pData == NULL) || (Size == 0U))
;;;654        {
;;;655          return  HAL_ERROR;
;;;656        }
;;;657    
;;;658        /* Process Locked */
;;;659        __HAL_LOCK(huart);
;;;660    
;;;661        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;662        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;663    
;;;664        /* Init tickstart for timeout managment */
;;;665        tickstart = HAL_GetTick();
;;;666    
;;;667        huart->TxXferSize = Size;
;;;668        huart->TxXferCount = Size;
;;;669        while(huart->TxXferCount > 0U)
;;;670        {
;;;671          huart->TxXferCount--;
;;;672          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;673          {
;;;674            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;675            {
;;;676              return HAL_TIMEOUT;
;;;677            }
;;;678            tmp = (uint16_t*) pData;
;;;679            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;680            if(huart->Init.Parity == UART_PARITY_NONE)
;;;681            {
;;;682              pData +=2U;
;;;683            }
;;;684            else
;;;685            {
;;;686              pData +=1U;
;;;687            }
;;;688          }
;;;689          else
;;;690          {
;;;691            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;692            {
;;;693              return HAL_TIMEOUT;
;;;694            }
;;;695            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;696          }
;;;697        }
;;;698    
;;;699        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;700        {
;;;701          return HAL_TIMEOUT;
;;;702        }
;;;703    
;;;704        /* At end of Tx process, restore huart->gState to Ready */
;;;705        huart->gState = HAL_UART_STATE_READY;
;;;706    
;;;707        /* Process Unlocked */
;;;708        __HAL_UNLOCK(huart);
;;;709    
;;;710        return HAL_OK;
;;;711      }
;;;712      else
;;;713      {
;;;714        return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L34.22|
;;;715      }
;;;716    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L34.26|
00001a  b1b5              CBZ      r5,|L34.74|
00001c  f1b90f00          CMP      r9,#0                 ;653
000020  d013              BEQ      |L34.74|
000022  f8940038          LDRB     r0,[r4,#0x38]         ;659
000026  2801              CMP      r0,#1                 ;659
000028  d011              BEQ      |L34.78|
00002a  2001              MOVS     r0,#1                 ;659
00002c  f8840038          STRB     r0,[r4,#0x38]         ;659
000030  2700              MOVS     r7,#0                 ;661
000032  63e7              STR      r7,[r4,#0x3c]         ;661
000034  2021              MOVS     r0,#0x21              ;662
000036  f8840039          STRB     r0,[r4,#0x39]         ;662
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;665
000040  f8a49024          STRH     r9,[r4,#0x24]         ;667
000044  f8a49026          STRH     r9,[r4,#0x26]         ;668
000048  e02d              B        |L34.166|
                  |L34.74|
00004a  2001              MOVS     r0,#1                 ;655
00004c  e7e3              B        |L34.22|
                  |L34.78|
00004e  2002              MOVS     r0,#2                 ;659
000050  e7e1              B        |L34.22|
                  |L34.82|
000052  8ce0              LDRH     r0,[r4,#0x26]         ;671
000054  1e40              SUBS     r0,r0,#1              ;671
000056  84e0              STRH     r0,[r4,#0x26]         ;671
000058  68a0              LDR      r0,[r4,#8]            ;672
00005a  f5b05f80          CMP      r0,#0x1000            ;672
00005e  d009              BEQ      |L34.116|
000060  4643              MOV      r3,r8                 ;691
000062  2200              MOVS     r2,#0                 ;691
000064  2180              MOVS     r1,#0x80              ;691
000066  4620              MOV      r0,r4                 ;691
000068  9600              STR      r6,[sp,#0]            ;691
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b1b0              CBZ      r0,|L34.158|
000070  2003              MOVS     r0,#3                 ;693
000072  e7d0              B        |L34.22|
                  |L34.116|
000074  4643              MOV      r3,r8                 ;674
000076  2200              MOVS     r2,#0                 ;674
000078  2180              MOVS     r1,#0x80              ;674
00007a  4620              MOV      r0,r4                 ;674
00007c  9600              STR      r6,[sp,#0]            ;674
00007e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L34.136|
000084  2003              MOVS     r0,#3                 ;676
000086  e7c6              B        |L34.22|
                  |L34.136|
000088  8828              LDRH     r0,[r5,#0]            ;679
00008a  6821              LDR      r1,[r4,#0]            ;679
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;679
000090  6048              STR      r0,[r1,#4]            ;679
000092  6920              LDR      r0,[r4,#0x10]         ;680
000094  b108              CBZ      r0,|L34.154|
000096  1c6d              ADDS     r5,r5,#1              ;686
000098  e005              B        |L34.166|
                  |L34.154|
00009a  1cad              ADDS     r5,r5,#2              ;682
00009c  e003              B        |L34.166|
                  |L34.158|
00009e  6821              LDR      r1,[r4,#0]            ;695
0000a0  f8150b01          LDRB     r0,[r5],#1            ;695
0000a4  6048              STR      r0,[r1,#4]            ;695
                  |L34.166|
0000a6  8ce0              LDRH     r0,[r4,#0x26]         ;669
0000a8  2800              CMP      r0,#0                 ;669
0000aa  d1d2              BNE      |L34.82|
0000ac  4643              MOV      r3,r8                 ;699
0000ae  2200              MOVS     r2,#0                 ;699
0000b0  2140              MOVS     r1,#0x40              ;699
0000b2  4620              MOV      r0,r4                 ;699
0000b4  9600              STR      r6,[sp,#0]            ;699
0000b6  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ba  b108              CBZ      r0,|L34.192|
0000bc  2003              MOVS     r0,#3                 ;701
0000be  e7aa              B        |L34.22|
                  |L34.192|
0000c0  2020              MOVS     r0,#0x20              ;705
0000c2  3438              ADDS     r4,r4,#0x38           ;705
0000c4  7060              STRB     r0,[r4,#1]            ;705
0000c6  7027              STRB     r7,[r4,#0]            ;708
0000c8  2000              MOVS     r0,#0                 ;710
0000ca  e7a4              B        |L34.22|
;;;717    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;903      */
;;;904    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;905    {
000002  4604              MOV      r4,r0
;;;906      uint32_t *tmp;
;;;907      
;;;908      /* Check that a Tx process is not already ongoing */
;;;909      if(huart->gState == HAL_UART_STATE_READY)
000004  f8940039          LDRB     r0,[r4,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L35.16|
;;;910      {
;;;911        if((pData == NULL) || (Size == 0U))
;;;912        {
;;;913          return HAL_ERROR;
;;;914        }
;;;915    
;;;916        /* Process Locked */
;;;917        __HAL_LOCK(huart);
;;;918    
;;;919        huart->pTxBuffPtr = pData;
;;;920        huart->TxXferSize = Size;
;;;921        huart->TxXferCount = Size;
;;;922    
;;;923        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;924        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;925    
;;;926        /* Set the UART DMA transfer complete callback */
;;;927        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;928    
;;;929        /* Set the UART DMA Half transfer complete callback */
;;;930        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;931    
;;;932        /* Set the DMA error callback */
;;;933        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;934    
;;;935        /* Set the DMA abort callback */
;;;936        huart->hdmatx->XferAbortCallback = NULL;
;;;937    
;;;938        /* Enable the UART transmit DMA channel */
;;;939        tmp = (uint32_t*)&pData;
;;;940        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;941    
;;;942        /* Clear the TC flag in the SR register by writing 0 to it */
;;;943        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;944    
;;;945        /* Process Unlocked */
;;;946        __HAL_UNLOCK(huart);
;;;947    
;;;948        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;949           in the UART CR3 register */
;;;950        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;951    
;;;952        return HAL_OK;
;;;953      }
;;;954      else
;;;955      {
;;;956        return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;957      }
;;;958    }
00000e  bdfe              POP      {r1-r7,pc}
                  |L35.16|
000010  9901              LDR      r1,[sp,#4]            ;911
000012  b379              CBZ      r1,|L35.116|
000014  b372              CBZ      r2,|L35.116|
000016  f8940038          LDRB     r0,[r4,#0x38]         ;917
00001a  2801              CMP      r0,#1                 ;917
00001c  d02d              BEQ      |L35.122|
00001e  2001              MOVS     r0,#1                 ;917
000020  f8840038          STRB     r0,[r4,#0x38]         ;917
000024  6221              STR      r1,[r4,#0x20]         ;919
000026  84a2              STRH     r2,[r4,#0x24]         ;920
000028  84e2              STRH     r2,[r4,#0x26]         ;921
00002a  2500              MOVS     r5,#0                 ;923
00002c  63e5              STR      r5,[r4,#0x3c]         ;923
00002e  2021              MOVS     r0,#0x21              ;924
000030  f8840039          STRB     r0,[r4,#0x39]         ;924
000034  6b23              LDR      r3,[r4,#0x30]         ;927
000036  4812              LDR      r0,|L35.128|
000038  6298              STR      r0,[r3,#0x28]         ;927
00003a  6b23              LDR      r3,[r4,#0x30]         ;930
00003c  4811              LDR      r0,|L35.132|
00003e  62d8              STR      r0,[r3,#0x2c]         ;930
000040  6b23              LDR      r3,[r4,#0x30]         ;933
000042  4811              LDR      r0,|L35.136|
000044  6318              STR      r0,[r3,#0x30]         ;933
000046  6b20              LDR      r0,[r4,#0x30]         ;936
000048  6345              STR      r5,[r0,#0x34]         ;936
00004a  6820              LDR      r0,[r4,#0]            ;940
00004c  4613              MOV      r3,r2                 ;940
00004e  1d00              ADDS     r0,r0,#4              ;940
000050  6b26              LDR      r6,[r4,#0x30]         ;940
000052  4602              MOV      r2,r0                 ;940
000054  4630              MOV      r0,r6                 ;940
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6821              LDR      r1,[r4,#0]            ;943
00005c  f06f0040          MVN      r0,#0x40              ;943
000060  6008              STR      r0,[r1,#0]            ;943
000062  f8845038          STRB     r5,[r4,#0x38]         ;946
000066  6820              LDR      r0,[r4,#0]            ;950
000068  6941              LDR      r1,[r0,#0x14]         ;950
00006a  f0410180          ORR      r1,r1,#0x80           ;950
00006e  6141              STR      r1,[r0,#0x14]         ;950
000070  2000              MOVS     r0,#0                 ;952
                  |L35.114|
000072  bdfe              POP      {r1-r7,pc}
                  |L35.116|
000074  e7ff              B        |L35.118|
                  |L35.118|
000076  2001              MOVS     r0,#1                 ;913
000078  e7fb              B        |L35.114|
                  |L35.122|
00007a  2002              MOVS     r0,#2                 ;917
00007c  e7f9              B        |L35.114|
;;;959    
                          ENDP

00007e  0000              DCW      0x0000
                  |L35.128|
                          DCD      UART_DMATransmitCplt
                  |L35.132|
                          DCD      UART_DMATxHalfCplt
                  |L35.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;814      */
;;;815    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;816    {
;;;817      /* Check that a Tx process is not already ongoing */
;;;818      if(huart->gState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L36.12|
;;;819      {
;;;820        if((pData == NULL) || (Size == 0U)) 
;;;821        {
;;;822          return HAL_ERROR;
;;;823        }
;;;824        /* Process Locked */
;;;825        __HAL_LOCK(huart);
;;;826    
;;;827        huart->pTxBuffPtr = pData;
;;;828        huart->TxXferSize = Size;
;;;829        huart->TxXferCount = Size;
;;;830    
;;;831        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;832        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;833    
;;;834        /* Process Unlocked */
;;;835        __HAL_UNLOCK(huart);
;;;836    
;;;837        /* Enable the UART Transmit data register empty Interrupt */
;;;838        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;839    
;;;840        return HAL_OK;
;;;841      }
;;;842      else
;;;843      {
;;;844        return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;845      }
;;;846    }
00000a  4770              BX       lr
                  |L36.12|
00000c  b1a9              CBZ      r1,|L36.58|
00000e  b1a2              CBZ      r2,|L36.58|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;825
000014  2b01              CMP      r3,#1                 ;825
000016  d012              BEQ      |L36.62|
000018  6201              STR      r1,[r0,#0x20]         ;827
00001a  8482              STRH     r2,[r0,#0x24]         ;828
00001c  84c2              STRH     r2,[r0,#0x26]         ;829
00001e  2100              MOVS     r1,#0                 ;831
000020  63c1              STR      r1,[r0,#0x3c]         ;831
000022  2221              MOVS     r2,#0x21              ;832
000024  f8802039          STRB     r2,[r0,#0x39]         ;832
000028  f8801038          STRB     r1,[r0,#0x38]         ;835
00002c  6800              LDR      r0,[r0,#0]            ;838
00002e  68c1              LDR      r1,[r0,#0xc]          ;838
000030  f0410180          ORR      r1,r1,#0x80           ;838
000034  60c1              STR      r1,[r0,#0xc]          ;838
000036  2000              MOVS     r0,#0                 ;840
000038  4770              BX       lr
                  |L36.58|
00003a  2001              MOVS     r0,#1                 ;822
00003c  4770              BX       lr
                  |L36.62|
00003e  2002              MOVS     r0,#2                 ;825
000040  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1683     */
;;;1684    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1685   {
;;;1686     /* Prevent unused argument(s) compilation warning */
;;;1687     UNUSED(huart);
;;;1688     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1689              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1690      */ 
;;;1691   }
;;;1692   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1698     */
;;;1699    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1700   {
;;;1701     /* Prevent unused argument(s) compilation warning */
;;;1702     UNUSED(huart);
;;;1703     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1704              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;1705      */ 
;;;1706   }
;;;1707   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2205     */
;;;2206   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2207   {
;;;2208     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2209     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2210     huart->TxXferCount = 0x00U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2211   
;;;2212     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2213   }
00000e  bd10              POP      {r4,pc}
;;;2214   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2107     */
;;;2108   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2109   {
;;;2110     uint32_t dmarequest = 0x00U;
;;;2111     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a44              LDR      r4,[r0,#0x24]
;;;2112   
;;;2113     /* Stop UART DMA Tx request if ongoing */
;;;2114     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f3c010c0          UBFX     r0,r0,#7,#1
;;;2115     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8941039          LDRB     r1,[r4,#0x39]
000010  2500              MOVS     r5,#0
000012  2921              CMP      r1,#0x21
000014  d104              BNE      |L40.32|
000016  b118              CBZ      r0,|L40.32|
;;;2116     {
;;;2117       huart->TxXferCount = 0U;
000018  84e5              STRH     r5,[r4,#0x26]
;;;2118       UART_EndTxTransfer(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       UART_EndTxTransfer
                  |L40.32|
;;;2119     }
;;;2120   
;;;2121     /* Stop UART DMA Rx request if ongoing */
;;;2122     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
000024  f3c01080          UBFX     r0,r0,#6,#1
;;;2123     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000028  f894103a          LDRB     r1,[r4,#0x3a]
00002c  2922              CMP      r1,#0x22
00002e  d104              BNE      |L40.58|
000030  b118              CBZ      r0,|L40.58|
;;;2124     {
;;;2125       huart->RxXferCount = 0U;
000032  85e5              STRH     r5,[r4,#0x2e]
;;;2126       UART_EndRxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndRxTransfer
                  |L40.58|
;;;2127     }
;;;2128   
;;;2129     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f0400010          ORR      r0,r0,#0x10
000040  63e0              STR      r0,[r4,#0x3c]
;;;2130     HAL_UART_ErrorCallback(huart);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2131   }
000048  bd70              POP      {r4-r6,pc}
;;;2132   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2068     */
;;;2069   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2070   {
000002  4601              MOV      r1,r0
;;;2071     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2072     /* DMA Normal mode*/
;;;2073     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d413              BMI      |L41.54|
;;;2074     {
;;;2075       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  85c1              STRH     r1,[r0,#0x2e]
;;;2076     
;;;2077       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2078       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000012  6801              LDR      r1,[r0,#0]
000014  68ca              LDR      r2,[r1,#0xc]
000016  f4227280          BIC      r2,r2,#0x100
00001a  60ca              STR      r2,[r1,#0xc]
;;;2079       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001c  6801              LDR      r1,[r0,#0]
00001e  694a              LDR      r2,[r1,#0x14]
000020  f0220201          BIC      r2,r2,#1
000024  614a              STR      r2,[r1,#0x14]
;;;2080       
;;;2081       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;2082          in the UART CR3 register */
;;;2083       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6801              LDR      r1,[r0,#0]
000028  694a              LDR      r2,[r1,#0x14]
00002a  f0220240          BIC      r2,r2,#0x40
00002e  614a              STR      r2,[r1,#0x14]
;;;2084   
;;;2085       /* At end of Rx process, restore huart->RxState to Ready */
;;;2086       huart->RxState = HAL_UART_STATE_READY;
000030  2120              MOVS     r1,#0x20
000032  f880103a          STRB     r1,[r0,#0x3a]
                  |L41.54|
;;;2087     }
;;;2088     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2089   }
00003a  bd10              POP      {r4,pc}
;;;2090   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2260     */
;;;2261   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2262   {
;;;2263     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2264     
;;;2265     huart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b41              LDR      r1,[r0,#0x34]
000008  634a              STR      r2,[r1,#0x34]
;;;2266   
;;;2267     /* Check if an Abort process is still ongoing */
;;;2268     if(huart->hdmatx != NULL)
00000a  6b01              LDR      r1,[r0,#0x30]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L42.22|
;;;2269     {
;;;2270       if(huart->hdmatx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L42.42|
                  |L42.22|
;;;2271       {
;;;2272         return;
;;;2273       }
;;;2274     }
;;;2275     
;;;2276     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2277     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2278     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2279   
;;;2280     /* Reset ErrorCode */
;;;2281     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2282   
;;;2283     /* Restore huart->gState and huart->RxState to Ready */
;;;2284     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2285     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2286   
;;;2287     /* Call user Abort complete callback */
;;;2288     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L42.42|
;;;2289   }
00002a  bd10              POP      {r4,pc}
;;;2290   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2096     */
;;;2097   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2098   {
;;;2099     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2100     HAL_UART_RxHalfCpltCallback(huart); 
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2101   }
000008  bd10              POP      {r4,pc}
;;;2102   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2319     */
;;;2320   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2321   {
;;;2322     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2323   
;;;2324     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2325   
;;;2326     /* Restore huart->RxState to Ready */
;;;2327     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f880103a          STRB     r1,[r0,#0x3a]
;;;2328   
;;;2329     /* Call user Abort complete callback */
;;;2330     HAL_UART_AbortReceiveCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2331   }
000012  bd10              POP      {r4,pc}
;;;2332   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2027     */
;;;2028   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2029   {
000002  4601              MOV      r1,r0
;;;2030     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2031     /* DMA Normal mode*/
;;;2032     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40c              BMI      |L45.40|
;;;2033     {
;;;2034       huart->TxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  84c1              STRH     r1,[r0,#0x26]
;;;2035   
;;;2036       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2037          in the UART CR3 register */
;;;2038       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220280          BIC      r2,r2,#0x80
00001a  614a              STR      r2,[r1,#0x14]
;;;2039   
;;;2040       /* Enable the UART Transmit Complete Interrupt */
;;;2041       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001c  6800              LDR      r0,[r0,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  f0410140          ORR      r1,r1,#0x40
000024  60c1              STR      r1,[r0,#0xc]
;;;2042   
;;;2043     }
;;;2044     /* DMA Circular mode */
;;;2045     else
;;;2046     {
;;;2047       HAL_UART_TxCpltCallback(huart);
;;;2048     }
;;;2049   }
000026  bd10              POP      {r4,pc}
                  |L45.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;2050   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2222     */
;;;2223   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2224   {
;;;2225     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2226     
;;;2227     huart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b01              LDR      r1,[r0,#0x30]
000008  634a              STR      r2,[r1,#0x34]
;;;2228   
;;;2229     /* Check if an Abort process is still ongoing */
;;;2230     if(huart->hdmarx != NULL)
00000a  6b41              LDR      r1,[r0,#0x34]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L46.22|
;;;2231     {
;;;2232       if(huart->hdmarx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L46.42|
                  |L46.22|
;;;2233       {
;;;2234         return;
;;;2235       }
;;;2236     }
;;;2237   
;;;2238     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2239     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2240     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2241   
;;;2242     /* Reset ErrorCode */
;;;2243     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2244   
;;;2245     /* Restore huart->gState and huart->RxState to Ready */
;;;2246     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2247     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2248   
;;;2249     /* Call user Abort complete callback */
;;;2250     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L46.42|
;;;2251   }
00002a  bd10              POP      {r4,pc}
;;;2252   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2056     */
;;;2057   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2058   {
;;;2059     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2060   
;;;2061     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2062   }
000008  bd10              POP      {r4,pc}
;;;2063   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2298     */
;;;2299   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2300   {
;;;2301     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2302   
;;;2303     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2304   
;;;2305     /* Restore huart->gState to Ready */
;;;2306     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f8801039          STRB     r1,[r0,#0x39]
;;;2307   
;;;2308     /* Call user Abort complete callback */
;;;2309     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2310   }
000012  bd10              POP      {r4,pc}
;;;2311   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2189     */
;;;2190   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2191   {
;;;2192     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2193     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227290          BIC      r2,r2,#0x120
000008  60ca              STR      r2,[r1,#0xc]
;;;2194     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  694a              LDR      r2,[r1,#0x14]
00000e  f0220201          BIC      r2,r2,#1
000012  614a              STR      r2,[r1,#0x14]
;;;2195   
;;;2196     /* At end of Rx process, restore huart->RxState to Ready */
;;;2197     huart->RxState = HAL_UART_STATE_READY;
000014  2120              MOVS     r1,#0x20
000016  f880103a          STRB     r1,[r0,#0x3a]
;;;2198   }
00001a  4770              BX       lr
;;;2199   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2385     */
;;;2386   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2387   {
;;;2388     /* Disable the UART Transmit Complete Interrupt */    
;;;2389     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  f0220240          BIC      r2,r2,#0x40
00000a  60ca              STR      r2,[r1,#0xc]
;;;2390     
;;;2391     /* Tx process is ended, restore huart->gState to Ready */
;;;2392     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  f8801039          STRB     r1,[r0,#0x39]
;;;2393     HAL_UART_TxCpltCallback(huart);
000012  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2394     
;;;2395     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;2396   }
000018  bd10              POP      {r4,pc}
;;;2397   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2175     */
;;;2176   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2177   {
;;;2178     /* Disable TXEIE and TCIE interrupts */
;;;2179     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  60ca              STR      r2,[r1,#0xc]
;;;2180   
;;;2181     /* At end of Tx process, restore huart->gState to Ready */
;;;2182     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801039          STRB     r1,[r0,#0x39]
;;;2183   }
000010  4770              BX       lr
;;;2184   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2403     */
;;;2404   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2405   {
;;;2406     uint16_t* tmp;
;;;2407     
;;;2408     /* Check that a Rx process is ongoing */
;;;2409     if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
000002  f890103a          LDRB     r1,[r0,#0x3a]
000006  2922              CMP      r1,#0x22
000008  d001              BEQ      |L52.14|
;;;2410     {
;;;2411       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;2412       {
;;;2413         tmp = (uint16_t*) huart->pRxBuffPtr;
;;;2414         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2415         {
;;;2416           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;2417           huart->pRxBuffPtr += 2U;
;;;2418         }
;;;2419         else
;;;2420         {
;;;2421           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;2422           huart->pRxBuffPtr += 1U;
;;;2423         }
;;;2424       }
;;;2425       else
;;;2426       {
;;;2427         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2428         {
;;;2429           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;2430         }
;;;2431         else
;;;2432         {
;;;2433           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;2434         }
;;;2435       }
;;;2436   
;;;2437       if(--huart->RxXferCount == 0U)
;;;2438       {
;;;2439         /* Disable the IRDA Data Register not empty Interrupt */
;;;2440         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;2441   
;;;2442         /* Disable the UART Parity Error Interrupt */
;;;2443         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;2444           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2445           __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;2446   
;;;2447         /* Rx process is completed, restore huart->RxState to Ready */
;;;2448         huart->RxState = HAL_UART_STATE_READY;
;;;2449   
;;;2450         HAL_UART_RxCpltCallback(huart);
;;;2451   
;;;2452         return HAL_OK;
;;;2453       }
;;;2454       return HAL_OK;
;;;2455     }
;;;2456     else
;;;2457     {
;;;2458       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;2459     }
;;;2460   }
00000c  bd10              POP      {r4,pc}
                  |L52.14|
00000e  6881              LDR      r1,[r0,#8]            ;2411
000010  f5b15f80          CMP      r1,#0x1000            ;2411
000014  d011              BEQ      |L52.58|
000016  6901              LDR      r1,[r0,#0x10]         ;2427
000018  b319              CBZ      r1,|L52.98|
00001a  6801              LDR      r1,[r0,#0]            ;2433
00001c  6849              LDR      r1,[r1,#4]            ;2433
00001e  f001037f          AND      r3,r1,#0x7f           ;2433
000022  6a81              LDR      r1,[r0,#0x28]         ;2433
000024  1c4a              ADDS     r2,r1,#1              ;2433
000026  6282              STR      r2,[r0,#0x28]         ;2433
000028  700b              STRB     r3,[r1,#0]            ;2433
                  |L52.42|
00002a  8dc1              LDRH     r1,[r0,#0x2e]         ;2437
00002c  1e49              SUBS     r1,r1,#1              ;2437
00002e  0409              LSLS     r1,r1,#16             ;2437
000030  0c09              LSRS     r1,r1,#16             ;2437
000032  85c1              STRH     r1,[r0,#0x2e]         ;2437
000034  d01c              BEQ      |L52.112|
000036  2000              MOVS     r0,#0                 ;2454
000038  bd10              POP      {r4,pc}
                  |L52.58|
00003a  6a81              LDR      r1,[r0,#0x28]         ;2413
00003c  6902              LDR      r2,[r0,#0x10]         ;2414
00003e  b13a              CBZ      r2,|L52.80|
000040  6802              LDR      r2,[r0,#0]            ;2421
000042  6852              LDR      r2,[r2,#4]            ;2421
000044  b2d2              UXTB     r2,r2                 ;2421
000046  800a              STRH     r2,[r1,#0]            ;2421
000048  6a81              LDR      r1,[r0,#0x28]         ;2422
00004a  1c49              ADDS     r1,r1,#1              ;2422
00004c  6281              STR      r1,[r0,#0x28]         ;2422
00004e  e7ec              B        |L52.42|
                  |L52.80|
000050  6802              LDR      r2,[r0,#0]            ;2416
000052  6852              LDR      r2,[r2,#4]            ;2416
000054  f3c20208          UBFX     r2,r2,#0,#9           ;2416
000058  800a              STRH     r2,[r1,#0]            ;2416
00005a  6a81              LDR      r1,[r0,#0x28]         ;2417
00005c  1c89              ADDS     r1,r1,#2              ;2417
00005e  6281              STR      r1,[r0,#0x28]         ;2417
000060  e7e3              B        |L52.42|
                  |L52.98|
000062  6801              LDR      r1,[r0,#0]            ;2429
000064  684a              LDR      r2,[r1,#4]            ;2429
000066  6a81              LDR      r1,[r0,#0x28]         ;2429
000068  1c4b              ADDS     r3,r1,#1              ;2429
00006a  6283              STR      r3,[r0,#0x28]         ;2429
00006c  700a              STRB     r2,[r1,#0]            ;2429
00006e  e7dc              B        |L52.42|
                  |L52.112|
000070  6801              LDR      r1,[r0,#0]            ;2440
000072  68ca              LDR      r2,[r1,#0xc]          ;2440
000074  f0220220          BIC      r2,r2,#0x20           ;2440
000078  60ca              STR      r2,[r1,#0xc]          ;2440
00007a  6801              LDR      r1,[r0,#0]            ;2443
00007c  68ca              LDR      r2,[r1,#0xc]          ;2443
00007e  f4227280          BIC      r2,r2,#0x100          ;2443
000082  60ca              STR      r2,[r1,#0xc]          ;2443
000084  6801              LDR      r1,[r0,#0]            ;2445
000086  694a              LDR      r2,[r1,#0x14]         ;2445
000088  f0220201          BIC      r2,r2,#1              ;2445
00008c  614a              STR      r2,[r1,#0x14]         ;2445
00008e  2120              MOVS     r1,#0x20              ;2448
000090  f880103a          STRB     r1,[r0,#0x3a]         ;2448
000094  f7fffffe          BL       HAL_UART_RxCpltCallback
000098  2000              MOVS     r0,#0                 ;2452
00009a  bd10              POP      {r4,pc}
;;;2461   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2467     */
;;;2468   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2469   {
000004  4604              MOV      r4,r0
;;;2470     uint32_t tmpreg = 0x00U;
;;;2471   
;;;2472     /* Check the parameters */
;;;2473     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2474     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2475     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2476     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2477   
;;;2478     /*------- UART-associated USART registers setting : CR2 Configuration ------*/
;;;2479     /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
;;;2480      * to huart->Init.StopBits value */
;;;2481     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6901              LDR      r1,[r0,#0x10]
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000
000010  4311              ORRS     r1,r1,r2
000012  6101              STR      r1,[r0,#0x10]
;;;2482   
;;;2483     /*------- UART-associated USART registers setting : CR1 Configuration ------*/
;;;2484     /* Configure the UART Word Length, Parity and mode: 
;;;2485        Set the M bits according to huart->Init.WordLength value 
;;;2486        Set PCE and PS bits according to huart->Init.Parity value
;;;2487        Set TE and RE bits according to huart->Init.Mode value
;;;2488        Set OVER8 bit according to huart->Init.OverSampling value */
;;;2489   
;;;2490   #if defined(USART_CR1_OVER8)
;;;2491     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
;;;2492     MODIFY_REG(huart->Instance->CR1, 
;;;2493                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
;;;2494                tmpreg);
;;;2495   #else
;;;2496     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
000014  68a1              LDR      r1,[r4,#8]
000016  6920              LDR      r0,[r4,#0x10]
000018  4301              ORRS     r1,r1,r0
00001a  6960              LDR      r0,[r4,#0x14]
00001c  4301              ORRS     r1,r1,r0
;;;2497     MODIFY_REG(huart->Instance->CR1, 
00001e  6820              LDR      r0,[r4,#0]
000020  68c2              LDR      r2,[r0,#0xc]
000022  f241630c          MOV      r3,#0x160c
000026  439a              BICS     r2,r2,r3
000028  430a              ORRS     r2,r2,r1
00002a  60c2              STR      r2,[r0,#0xc]
;;;2498                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
;;;2499                tmpreg);
;;;2500   #endif /* USART_CR1_OVER8 */
;;;2501   
;;;2502     /*------- UART-associated USART registers setting : CR3 Configuration ------*/
;;;2503     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;2504     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  69a2              LDR      r2,[r4,#0x18]
000032  f4217140          BIC      r1,r1,#0x300
000036  4311              ORRS     r1,r1,r2
000038  6141              STR      r1,[r0,#0x14]
;;;2505   
;;;2506   #if defined(USART_CR1_OVER8)
;;;2507     /* Check the Over Sampling */
;;;2508     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;2509     {
;;;2510       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2511       if(huart->Instance == USART1)
;;;2512       {
;;;2513         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2514       }
;;;2515       else
;;;2516       {
;;;2517         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2518       }
;;;2519     }
;;;2520     else
;;;2521     {
;;;2522       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2523       if(huart->Instance == USART1)
;;;2524       {
;;;2525         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2526       }
;;;2527       else
;;;2528       {
;;;2529         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2530       }
;;;2531     }
;;;2532   #else
;;;2533     /*-------------------------- USART BRR Configuration ---------------------*/
;;;2534     if(huart->Instance == USART1)
00003a  4957              LDR      r1,|L53.408|
00003c  6820              LDR      r0,[r4,#0]
;;;2535     {
;;;2536       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00003e  2564              MOVS     r5,#0x64
000040  2632              MOVS     r6,#0x32
000042  4288              CMP      r0,r1                 ;2534
000044  d154              BNE      |L53.240|
000046  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6861              LDR      r1,[r4,#4]
000054  0089              LSLS     r1,r1,#2
000056  fbb0f7f1          UDIV     r7,r0,r1
00005a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005e  eb0001c0          ADD      r1,r0,r0,LSL #3
000062  eb011000          ADD      r0,r1,r0,LSL #4
000066  6861              LDR      r1,[r4,#4]
000068  0089              LSLS     r1,r1,#2
00006a  fbb0f0f1          UDIV     r0,r0,r1
00006e  fbb0f0f5          UDIV     r0,r0,r5
000072  f06f0118          MVN      r1,#0x18
000076  4348              MULS     r0,r1,r0
000078  eb070080          ADD      r0,r7,r0,LSL #2
00007c  eb061000          ADD      r0,r6,r0,LSL #4
000080  fbb0f0f5          UDIV     r0,r0,r5
000084  f00007f0          AND      r7,r0,#0xf0
000088  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00008c  eb0001c0          ADD      r1,r0,r0,LSL #3
000090  eb011000          ADD      r0,r1,r0,LSL #4
000094  6861              LDR      r1,[r4,#4]
000096  0089              LSLS     r1,r1,#2
000098  fbb0f0f1          UDIV     r0,r0,r1
00009c  fbb0f0f5          UDIV     r0,r0,r5
0000a0  eb071700          ADD      r7,r7,r0,LSL #4
0000a4  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000a8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ac  eb011000          ADD      r0,r1,r0,LSL #4
0000b0  6861              LDR      r1,[r4,#4]
0000b2  0089              LSLS     r1,r1,#2
0000b4  fbb0f8f1          UDIV     r8,r0,r1
0000b8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000bc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000c0  eb011000          ADD      r0,r1,r0,LSL #4
0000c4  6861              LDR      r1,[r4,#4]
0000c6  0089              LSLS     r1,r1,#2
0000c8  fbb0f0f1          UDIV     r0,r0,r1
0000cc  fbb0f0f5          UDIV     r0,r0,r5
0000d0  f06f0118          MVN      r1,#0x18
0000d4  4348              MULS     r0,r1,r0
0000d6  eb080080          ADD      r0,r8,r0,LSL #2
0000da  eb061000          ADD      r0,r6,r0,LSL #4
0000de  fbb0f0f5          UDIV     r0,r0,r5
0000e2  6821              LDR      r1,[r4,#0]
0000e4  f000000f          AND      r0,r0,#0xf
0000e8  4438              ADD      r0,r0,r7
0000ea  6088              STR      r0,[r1,#8]
                  |L53.236|
;;;2537     }
;;;2538     else
;;;2539     {
;;;2540       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2541     }
;;;2542   #endif /* USART_CR1_OVER8 */
;;;2543   }
0000ec  e8bd81f0          POP      {r4-r8,pc}
                  |L53.240|
0000f0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000f4  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2540
0000f8  eb011000          ADD      r0,r1,r0,LSL #4       ;2540
0000fc  6861              LDR      r1,[r4,#4]            ;2540
0000fe  0089              LSLS     r1,r1,#2              ;2540
000100  fbb0f7f1          UDIV     r7,r0,r1              ;2540
000104  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000108  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2540
00010c  eb011000          ADD      r0,r1,r0,LSL #4       ;2540
000110  6861              LDR      r1,[r4,#4]            ;2540
000112  0089              LSLS     r1,r1,#2              ;2540
000114  fbb0f0f1          UDIV     r0,r0,r1              ;2540
000118  fbb0f0f5          UDIV     r0,r0,r5              ;2540
00011c  f06f0118          MVN      r1,#0x18              ;2540
000120  4348              MULS     r0,r1,r0              ;2540
000122  eb070080          ADD      r0,r7,r0,LSL #2       ;2540
000126  eb061000          ADD      r0,r6,r0,LSL #4       ;2540
00012a  fbb0f0f5          UDIV     r0,r0,r5              ;2540
00012e  f00007f0          AND      r7,r0,#0xf0           ;2540
000132  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000136  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2540
00013a  eb011000          ADD      r0,r1,r0,LSL #4       ;2540
00013e  6861              LDR      r1,[r4,#4]            ;2540
000140  0089              LSLS     r1,r1,#2              ;2540
000142  fbb0f0f1          UDIV     r0,r0,r1              ;2540
000146  fbb0f0f5          UDIV     r0,r0,r5              ;2540
00014a  eb071700          ADD      r7,r7,r0,LSL #4       ;2540
00014e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000152  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2540
000156  eb011000          ADD      r0,r1,r0,LSL #4       ;2540
00015a  6861              LDR      r1,[r4,#4]            ;2540
00015c  0089              LSLS     r1,r1,#2              ;2540
00015e  fbb0f8f1          UDIV     r8,r0,r1              ;2540
000162  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000166  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2540
00016a  eb011000          ADD      r0,r1,r0,LSL #4       ;2540
00016e  6861              LDR      r1,[r4,#4]            ;2540
000170  0089              LSLS     r1,r1,#2              ;2540
000172  fbb0f0f1          UDIV     r0,r0,r1              ;2540
000176  fbb0f0f5          UDIV     r0,r0,r5              ;2540
00017a  f06f0118          MVN      r1,#0x18              ;2540
00017e  4348              MULS     r0,r1,r0              ;2540
000180  eb080080          ADD      r0,r8,r0,LSL #2       ;2540
000184  eb061000          ADD      r0,r6,r0,LSL #4       ;2540
000188  fbb0f0f5          UDIV     r0,r0,r5              ;2540
00018c  6821              LDR      r1,[r4,#0]            ;2540
00018e  f000000f          AND      r0,r0,#0xf            ;2540
000192  4438              ADD      r0,r0,r7              ;2540
000194  6088              STR      r0,[r1,#8]            ;2540
000196  e7a9              B        |L53.236|
;;;2544   
                          ENDP

                  |L53.408|
                          DCD      0x40013800

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2338     */
;;;2339   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  f8901039          LDRB     r1,[r0,#0x39]
;;;2340   {
;;;2341     uint16_t* tmp;
;;;2342     
;;;2343     /* Check that a Tx process is ongoing */
;;;2344     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d001              BEQ      |L54.12|
;;;2345     {
;;;2346       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;2347       {
;;;2348         tmp = (uint16_t*) huart->pTxBuffPtr;
;;;2349         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;2350         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2351         {
;;;2352           huart->pTxBuffPtr += 2U;
;;;2353         }
;;;2354         else
;;;2355         {
;;;2356           huart->pTxBuffPtr += 1U;
;;;2357         }
;;;2358       } 
;;;2359       else
;;;2360       {
;;;2361         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;2362       }
;;;2363   
;;;2364       if(--huart->TxXferCount == 0U)
;;;2365       {
;;;2366         /* Disable the UART Transmit Complete Interrupt */
;;;2367         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;2368   
;;;2369         /* Enable the UART Transmit Complete Interrupt */    
;;;2370         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
;;;2371       }
;;;2372       return HAL_OK;
;;;2373     }
;;;2374     else
;;;2375     {
;;;2376       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;2377     }
;;;2378   }
00000a  4770              BX       lr
                  |L54.12|
00000c  6881              LDR      r1,[r0,#8]            ;2346
00000e  f5b15f80          CMP      r1,#0x1000            ;2346
000012  d00c              BEQ      |L54.46|
000014  6a01              LDR      r1,[r0,#0x20]         ;2361
000016  1c4a              ADDS     r2,r1,#1              ;2361
000018  6202              STR      r2,[r0,#0x20]         ;2361
00001a  6802              LDR      r2,[r0,#0]            ;2361
00001c  7809              LDRB     r1,[r1,#0]            ;2361
00001e  6051              STR      r1,[r2,#4]            ;2361
                  |L54.32|
000020  8cc1              LDRH     r1,[r0,#0x26]         ;2364
000022  1e49              SUBS     r1,r1,#1              ;2364
000024  0409              LSLS     r1,r1,#16             ;2364
000026  0c09              LSRS     r1,r1,#16             ;2364
000028  84c1              STRH     r1,[r0,#0x26]         ;2364
00002a  d010              BEQ      |L54.78|
00002c  e019              B        |L54.98|
                  |L54.46|
00002e  6a01              LDR      r1,[r0,#0x20]         ;2348
000030  6802              LDR      r2,[r0,#0]            ;2349
000032  8809              LDRH     r1,[r1,#0]            ;2349
000034  f3c10108          UBFX     r1,r1,#0,#9           ;2349
000038  6051              STR      r1,[r2,#4]            ;2349
00003a  6901              LDR      r1,[r0,#0x10]         ;2350
00003c  b119              CBZ      r1,|L54.70|
00003e  6a01              LDR      r1,[r0,#0x20]         ;2356
000040  1c49              ADDS     r1,r1,#1              ;2356
000042  6201              STR      r1,[r0,#0x20]         ;2356
000044  e7ec              B        |L54.32|
                  |L54.70|
000046  6a01              LDR      r1,[r0,#0x20]         ;2352
000048  1c89              ADDS     r1,r1,#2              ;2352
00004a  6201              STR      r1,[r0,#0x20]         ;2352
00004c  e7e8              B        |L54.32|
                  |L54.78|
00004e  6801              LDR      r1,[r0,#0]            ;2367
000050  68ca              LDR      r2,[r1,#0xc]          ;2367
000052  f0220280          BIC      r2,r2,#0x80           ;2367
000056  60ca              STR      r2,[r1,#0xc]          ;2367
000058  6800              LDR      r0,[r0,#0]            ;2370
00005a  68c1              LDR      r1,[r0,#0xc]          ;2370
00005c  f0410140          ORR      r1,r1,#0x40           ;2370
000060  60c1              STR      r1,[r0,#0xc]          ;2370
                  |L54.98|
000062  2000              MOVS     r0,#0                 ;2372
000064  4770              BX       lr
;;;2379   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2142     */
;;;2143   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2144   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;2145     /* Wait until flag is set */
;;;2146     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
;;;2147     {
;;;2148       /* Check for the Timeout */
;;;2149       if(Timeout != HAL_MAX_DELAY)
;;;2150       {
;;;2151         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
;;;2152         {
;;;2153           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2154           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;2155           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2156           
;;;2157           huart->gState  = HAL_UART_STATE_READY;
;;;2158           huart->RxState = HAL_UART_STATE_READY;
;;;2159           
;;;2160           /* Process Unlocked */
;;;2161           __HAL_UNLOCK(huart);
;;;2162           
;;;2163           return HAL_TIMEOUT;
00000e  e01d              B        |L55.76|
                  |L55.16|
000010  1c68              ADDS     r0,r5,#1              ;2149
000012  d01b              BEQ      |L55.76|
000014  b12d              CBZ      r5,|L55.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;2151
00001e  42a8              CMP      r0,r5                 ;2151
000020  d914              BLS      |L55.76|
                  |L55.34|
000022  6820              LDR      r0,[r4,#0]            ;2154
000024  68c1              LDR      r1,[r0,#0xc]          ;2154
000026  f42171d0          BIC      r1,r1,#0x1a0          ;2154
00002a  60c1              STR      r1,[r0,#0xc]          ;2154
00002c  6820              LDR      r0,[r4,#0]            ;2155
00002e  6941              LDR      r1,[r0,#0x14]         ;2155
000030  f0210101          BIC      r1,r1,#1              ;2155
000034  6141              STR      r1,[r0,#0x14]         ;2155
000036  2020              MOVS     r0,#0x20              ;2157
000038  f8840039          STRB     r0,[r4,#0x39]         ;2157
00003c  f884003a          STRB     r0,[r4,#0x3a]         ;2158
000040  2000              MOVS     r0,#0                 ;2161
000042  f8840038          STRB     r0,[r4,#0x38]         ;2161
000046  2003              MOVS     r0,#3
                  |L55.72|
;;;2164         }
;;;2165       }
;;;2166     }
;;;2167     
;;;2168     return HAL_OK;
;;;2169   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L55.76|
00004c  6820              LDR      r0,[r4,#0]            ;2146
00004e  6800              LDR      r0,[r0,#0]            ;2146
000050  ea360000          BICS     r0,r6,r0              ;2146
000054  d004              BEQ      |L55.96|
000056  2000              MOVS     r0,#0                 ;2146
                  |L55.88|
000058  42b8              CMP      r0,r7                 ;2146
00005a  d0d9              BEQ      |L55.16|
00005c  2000              MOVS     r0,#0                 ;2168
00005e  e7f3              B        |L55.72|
                  |L55.96|
000060  2001              MOVS     r0,#1                 ;2146
000062  e7f9              B        |L55.88|
;;;2170   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
