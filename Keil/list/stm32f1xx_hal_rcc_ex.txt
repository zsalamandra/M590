; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -ogsm_stm32f103\stm32f1xx_hal_rcc_ex.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS -IE:\MC\2.STM32\STMProjects\GSM\GSM_M590\Project\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=gsm_stm32f103\stm32f1xx_hal_rcc_ex.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;311      */
;;;312    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2101              MOVS     r1,#1
;;;313    {
;;;314      uint32_t srcclk = 0U;
;;;315      
;;;316      /* Set all possible values for the extended clock type parameter------------*/
;;;317      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
000002  6001              STR      r1,[r0,#0]
;;;318    
;;;319      /* Get the RTC configuration -----------------------------------------------*/
;;;320      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000004  4908              LDR      r1,|L1.40|
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f4027240          AND      r2,r2,#0x300
;;;321      /* Source clock is LSE or LSI*/
;;;322      PeriphClkInit->RTCClockSelection = srcclk;
00000c  6042              STR      r2,[r0,#4]
;;;323    
;;;324      /* Get the ADC clock configuration -----------------------------------------*/
;;;325      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
00000e  2203              MOVS     r2,#3
000010  6002              STR      r2,[r0,#0]
;;;326      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000012  684a              LDR      r2,[r1,#4]
000014  f4024240          AND      r2,r2,#0xc000
000018  6082              STR      r2,[r0,#8]
;;;327    
;;;328    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;329      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;330      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;331      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;332    
;;;333      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;334      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;335      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;336    
;;;337    #endif /* STM32F105xC || STM32F107xC */
;;;338    
;;;339    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;340      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;341      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;342      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;343    
;;;344      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;345      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;346      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;347    
;;;348    #endif /* STM32F103xE || STM32F103xG */
;;;349    
;;;350    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;351     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;352     || defined(STM32F105xC) || defined(STM32F107xC)
;;;353      /* Get the USB clock configuration -----------------------------------------*/
;;;354      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
00001a  2213              MOVS     r2,#0x13
00001c  6002              STR      r2,[r0,#0]
;;;355      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00001e  6849              LDR      r1,[r1,#4]
000020  f4010180          AND      r1,r1,#0x400000
000024  60c1              STR      r1,[r0,#0xc]
;;;356    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;357    }
000026  4770              BX       lr
;;;358    
                          ENDP

                  |L1.40|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;404      */
;;;405    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b510              PUSH     {r4,lr}
;;;406    {
000002  b086              SUB      sp,sp,#0x18
000004  4601              MOV      r1,r0
;;;407    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;408      const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;409      const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;410    
;;;411      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;412      uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
;;;413    #endif /* STM32F105xC || STM32F107xC */
;;;414    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
;;;415        defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
;;;416      const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
000006  a02a              ADR      r0,|L2.176|
000008  e890001c          LDM      r0,{r2-r4}
00000c  68c0              LDR      r0,[r0,#0xc]
00000e  e9cd3403          STRD     r3,r4,[sp,#0xc]
000012  9202              STR      r2,[sp,#8]
000014  9005              STR      r0,[sp,#0x14]
;;;417      const uint8_t aPredivFactorTable[2] = {1, 2};
000016  a02a              ADR      r0,|L2.192|
000018  6800              LDR      r0,[r0,#0]
00001a  9001              STR      r0,[sp,#4]
;;;418    
;;;419      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;420    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG */
;;;421      uint32_t temp_reg = 0U, frequency = 0U;
00001c  2000              MOVS     r0,#0
;;;422    
;;;423      /* Check the parameters */
;;;424      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;425      
;;;426      switch (PeriphClk)
;;;427      {
;;;428    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;429     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;430     || defined(STM32F105xC) || defined(STM32F107xC)
;;;431      case RCC_PERIPHCLK_USB:  
;;;432        {
;;;433          /* Get RCC configuration ------------------------------------------------------*/
;;;434          temp_reg = RCC->CFGR;
00001e  4c29              LDR      r4,|L2.196|
000020  2901              CMP      r1,#1                 ;426
000022  d022              BEQ      |L2.106|
000024  2902              CMP      r1,#2                 ;426
000026  d039              BEQ      |L2.156|
000028  2910              CMP      r1,#0x10              ;426
00002a  d11c              BNE      |L2.102|
00002c  6861              LDR      r1,[r4,#4]
;;;435      
;;;436          /* Check if PLL is enabled */
;;;437          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
00002e  6822              LDR      r2,[r4,#0]
000030  01d2              LSLS     r2,r2,#7
000032  d518              BPL      |L2.102|
;;;438          {
;;;439            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
000034  a802              ADD      r0,sp,#8
000036  f3c14283          UBFX     r2,r1,#18,#4
00003a  5c80              LDRB     r0,[r0,r2]
;;;440            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
00003c  03c9              LSLS     r1,r1,#15
00003e  d509              BPL      |L2.84|
;;;441            {
;;;442    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;443     || defined(STM32F100xE)
;;;444              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;445    #else
;;;446              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
000040  6861              LDR      r1,[r4,#4]
000042  aa01              ADD      r2,sp,#4
000044  f3c14140          UBFX     r1,r1,#17,#1
000048  5c51              LDRB     r1,[r2,r1]
;;;447    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;448    
;;;449    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;450              if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;451              {
;;;452                /* PLL2 selected as Prediv1 source */
;;;453                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;454                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;455                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;456                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;457              }
;;;458              else
;;;459              {
;;;460                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;461                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;462              }
;;;463              
;;;464              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;465              /* In this case need to divide pllclk by 2 */
;;;466              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;467              {
;;;468                  pllclk = pllclk / 2;
;;;469              }
;;;470    #else
;;;471              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;472              {
;;;473                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;474                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
00004a  4a1f              LDR      r2,|L2.200|
00004c  fbb2f1f1          UDIV     r1,r2,r1
000050  4348              MULS     r0,r1,r0
000052  e001              B        |L2.88|
                  |L2.84|
;;;475              }
;;;476    #endif /* STM32F105xC || STM32F107xC */
;;;477            }
;;;478            else
;;;479            {
;;;480              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;481              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
000054  491d              LDR      r1,|L2.204|
000056  4348              MULS     r0,r1,r0
                  |L2.88|
;;;482            }
;;;483    
;;;484            /* Calcul of the USB frequency*/
;;;485    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;486            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;487            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;488            {
;;;489              /* Prescaler of 2 selected for USB */ 
;;;490              frequency = pllclk;
;;;491            }
;;;492            else
;;;493            {
;;;494              /* Prescaler of 3 selected for USB */ 
;;;495              frequency = (2 * pllclk) / 3;
;;;496            }
;;;497    #else
;;;498            /* USBCLK = PLLCLK / USB prescaler */
;;;499            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
000058  6861              LDR      r1,[r4,#4]
00005a  0249              LSLS     r1,r1,#9
00005c  d403              BMI      |L2.102|
;;;500            {
;;;501              /* No prescaler selected for USB */
;;;502              frequency = pllclk;
;;;503            }
;;;504            else
;;;505            {
;;;506              /* Prescaler of 1.5 selected for USB */ 
;;;507              frequency = (pllclk * 2) / 3;
00005e  0040              LSLS     r0,r0,#1
000060  2103              MOVS     r1,#3
000062  fbb0f0f1          UDIV     r0,r0,r1
                  |L2.102|
;;;508            }
;;;509    #endif
;;;510          }
;;;511          break;
;;;512        }
;;;513    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;514    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC) || defined(STM32F107xC)
;;;515      case RCC_PERIPHCLK_I2S2:  
;;;516        {
;;;517    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;518          /* SYSCLK used as source clock for I2S2 */
;;;519          frequency = HAL_RCC_GetSysClockFreq();
;;;520    #else
;;;521          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;522          {
;;;523            /* SYSCLK used as source clock for I2S2 */
;;;524            frequency = HAL_RCC_GetSysClockFreq();
;;;525          }
;;;526          else
;;;527          {
;;;528             /* Check if PLLI2S is enabled */
;;;529            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;530            {
;;;531              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;532              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;533              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;534              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;535            }
;;;536          }
;;;537    #endif /* STM32F103xE || STM32F103xG */
;;;538          break;
;;;539        }
;;;540      case RCC_PERIPHCLK_I2S3:
;;;541        {
;;;542    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;543          /* SYSCLK used as source clock for I2S3 */
;;;544          frequency = HAL_RCC_GetSysClockFreq();
;;;545    #else
;;;546          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;547          {
;;;548            /* SYSCLK used as source clock for I2S3 */
;;;549            frequency = HAL_RCC_GetSysClockFreq();
;;;550          }
;;;551          else
;;;552          {
;;;553             /* Check if PLLI2S is enabled */
;;;554            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;555            {
;;;556              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;557              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;558              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;559              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;560            }
;;;561          }
;;;562    #endif /* STM32F103xE || STM32F103xG */
;;;563          break;
;;;564        }
;;;565    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;566      case RCC_PERIPHCLK_RTC:  
;;;567        {
;;;568          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;569          temp_reg = RCC->BDCR;
;;;570    
;;;571          /* Check if LSE is ready if RTC clock selection is LSE */
;;;572          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
;;;573          {
;;;574            frequency = LSE_VALUE;
;;;575          }
;;;576          /* Check if LSI is ready if RTC clock selection is LSI */
;;;577          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
;;;578          {
;;;579            frequency = LSI_VALUE;
;;;580          }
;;;581          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;582          {
;;;583            frequency = HSE_VALUE / 128U;
;;;584          }
;;;585          /* Clock not enabled for RTC*/
;;;586          else
;;;587          {
;;;588            frequency = 0U;
;;;589          }
;;;590          break;
;;;591        }
;;;592      case RCC_PERIPHCLK_ADC:  
;;;593        {
;;;594          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
;;;595          break;
;;;596        }
;;;597      default: 
;;;598        {
;;;599          break;
;;;600        }
;;;601      }
;;;602      return(frequency);
;;;603    }
000066  b006              ADD      sp,sp,#0x18
000068  bd10              POP      {r4,pc}
                  |L2.106|
00006a  6a21              LDR      r1,[r4,#0x20]         ;569
00006c  f3c12201          UBFX     r2,r1,#8,#2           ;572
000070  2a01              CMP      r2,#1                 ;572
000072  d103              BNE      |L2.124|
000074  0789              LSLS     r1,r1,#30             ;572
000076  d501              BPL      |L2.124|
000078  03d0              LSLS     r0,r2,#15             ;574
00007a  e7f4              B        |L2.102|
                  |L2.124|
00007c  2a02              CMP      r2,#2                 ;577
00007e  d105              BNE      |L2.140|
000080  6a61              LDR      r1,[r4,#0x24]         ;577
000082  0789              LSLS     r1,r1,#30             ;577
000084  d502              BPL      |L2.140|
000086  f6494040          MOV      r0,#0x9c40            ;579
00008a  e7ec              B        |L2.102|
                  |L2.140|
00008c  2a03              CMP      r2,#3                 ;581
00008e  d1ea              BNE      |L2.102|
000090  6821              LDR      r1,[r4,#0]            ;581
000092  0389              LSLS     r1,r1,#14             ;581
000094  d5e7              BPL      |L2.102|
000096  f24f4024          MOV      r0,#0xf424            ;583
00009a  e7e4              B        |L2.102|
                  |L2.156|
00009c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000a0  6861              LDR      r1,[r4,#4]            ;594
0000a2  f3c13181          UBFX     r1,r1,#14,#2          ;594
0000a6  1c49              ADDS     r1,r1,#1              ;594
0000a8  0049              LSLS     r1,r1,#1              ;594
0000aa  fbb0f0f1          UDIV     r0,r0,r1              ;594
0000ae  e7da              B        |L2.102|
;;;604    
                          ENDP

                  |L2.176|
0000b0  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
0000b4  06070809
0000b8  0a0b0c0d
0000bc  0e0f1010
                  |L2.192|
0000c0  010200            DCB      1,2,0
0000c3  00                DCB      0
                  |L2.196|
                          DCD      0x40021000
                  |L2.200|
                          DCD      0x007a1200
                  |L2.204|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;117      */
;;;118    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;119    {
000004  4604              MOV      r4,r0
;;;120      uint32_t tickstart = 0U, temp_reg = 0U;
;;;121    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;122      uint32_t  pllactive = 0U;
;;;123    #endif /* STM32F105xC || STM32F107xC */
;;;124    
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;129      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
;;;130      {
;;;131        /* check for RTC Parameters used to output RTCCLK */
;;;132        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;133    
;;;134        FlagStatus       pwrclkchanged = RESET;
;;;135    
;;;136        /* As soon as function is called to change RTC clock source, activation of the 
;;;137           power domain is done. */
;;;138        /* Requires to enable write access to Backup Domain of necessary */
;;;139        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000006  f8df80f8          LDR      r8,|L3.256|
00000a  7820              LDRB     r0,[r4,#0]            ;129
00000c  07c0              LSLS     r0,r0,#31             ;129
00000e  d05f              BEQ      |L3.208|
000010  2700              MOVS     r7,#0                 ;134
000012  f8d8001c          LDR      r0,[r8,#0x1c]
000016  00c0              LSLS     r0,r0,#3
000018  d40b              BMI      |L3.50|
;;;140        {
;;;141        __HAL_RCC_PWR_CLK_ENABLE();
00001a  f8d8001c          LDR      r0,[r8,#0x1c]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  f8c8001c          STR      r0,[r8,#0x1c]
000026  f8d8001c          LDR      r0,[r8,#0x1c]
00002a  f0005080          AND      r0,r0,#0x10000000
00002e  9000              STR      r0,[sp,#0]
;;;142          pwrclkchanged = SET;
000030  2701              MOVS     r7,#1
                  |L3.50|
;;;143        }
;;;144        
;;;145        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000032  4d34              LDR      r5,|L3.260|
000034  6828              LDR      r0,[r5,#0]
000036  05c0              LSLS     r0,r0,#23
000038  d412              BMI      |L3.96|
;;;146        {
;;;147          /* Enable write access to Backup domain */
;;;148          SET_BIT(PWR->CR, PWR_CR_DBP);
00003a  6828              LDR      r0,[r5,#0]
00003c  f4407080          ORR      r0,r0,#0x100
000040  6028              STR      r0,[r5,#0]
;;;149          
;;;150          /* Wait for Backup domain Write protection disable */
;;;151          tickstart = HAL_GetTick();
000042  f7fffffe          BL       HAL_GetTick
000046  4606              MOV      r6,r0
;;;152          
;;;153          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000048  e007              B        |L3.90|
                  |L3.74|
;;;154          {
;;;155            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
00004a  f7fffffe          BL       HAL_GetTick
00004e  1b80              SUBS     r0,r0,r6
000050  2864              CMP      r0,#0x64
000052  d902              BLS      |L3.90|
;;;156            {
;;;157              return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L3.86|
;;;158            }
;;;159          }
;;;160        }
;;;161          
;;;162        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;163        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
;;;164        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
;;;165        {
;;;166          /* Store the content of BDCR register before the reset of Backup Domain */
;;;167          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
;;;168          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;169          __HAL_RCC_BACKUPRESET_FORCE();
;;;170          __HAL_RCC_BACKUPRESET_RELEASE();
;;;171          /* Restore the Content of BDCR register */
;;;172          RCC->BDCR = temp_reg;
;;;173    
;;;174          /* Wait for LSERDY if LSE was enabled */
;;;175          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
;;;176          {
;;;177            /* Get Start Tick */
;;;178            tickstart = HAL_GetTick();
;;;179          
;;;180            /* Wait till LSE is ready */  
;;;181            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;182            {
;;;183              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;184              {
;;;185                return HAL_TIMEOUT;
;;;186              }      
;;;187            }  
;;;188          }
;;;189        }
;;;190        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
;;;191    
;;;192        /* Require to disable power clock if necessary */
;;;193        if(pwrclkchanged == SET)
;;;194        {
;;;195          __HAL_RCC_PWR_CLK_DISABLE();
;;;196        }
;;;197      }
;;;198    
;;;199      /*------------------------------ ADC clock Configuration ------------------*/ 
;;;200      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;201      {
;;;202        /* Check the parameters */
;;;203        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;204        
;;;205        /* Configure the ADC clock source */
;;;206        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;207      }
;;;208    
;;;209    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;210      /*------------------------------ I2S2 Configuration ------------------------*/ 
;;;211      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;212      {
;;;213        /* Check the parameters */
;;;214        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;215    
;;;216        /* Configure the I2S2 clock source */
;;;217        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;218      }
;;;219    
;;;220      /*------------------------------ I2S3 Configuration ------------------------*/ 
;;;221      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;222      {
;;;223        /* Check the parameters */
;;;224        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;225        
;;;226        /* Configure the I2S3 clock source */
;;;227        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;228      }
;;;229    
;;;230      /*------------------------------ PLL I2S Configuration ----------------------*/ 
;;;231      /* Check that PLLI2S need to be enabled */
;;;232      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;233      {
;;;234        /* Update flag to indicate that PLL I2S should be active */
;;;235        pllactive = 1;
;;;236      }
;;;237    
;;;238      /* Check if PLL I2S need to be enabled */
;;;239      if (pllactive == 1)
;;;240      {
;;;241        /* Enable PLL I2S only if not active */
;;;242        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;243        {
;;;244          /* Check the parameters */
;;;245          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;246          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;247    
;;;248          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;249          /* Return an error only if new value is different from the programmed value */
;;;250          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL2ON) && \
;;;251            (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;252          {
;;;253            return HAL_ERROR;
;;;254          }
;;;255    
;;;256          /* Configure the HSE prediv2 factor --------------------------------*/
;;;257          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;258    
;;;259          /* Configure the main PLLI2S multiplication factors. */
;;;260          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;261          
;;;262          /* Enable the main PLLI2S. */
;;;263          __HAL_RCC_PLLI2S_ENABLE();
;;;264          
;;;265          /* Get Start Tick*/
;;;266          tickstart = HAL_GetTick();
;;;267          
;;;268          /* Wait till PLLI2S is ready */
;;;269          while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;270          {
;;;271            if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;272            {
;;;273              return HAL_TIMEOUT;
;;;274            }
;;;275          }
;;;276        }
;;;277        else
;;;278        {
;;;279          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;280          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;281          {
;;;282              return HAL_ERROR;
;;;283          }
;;;284        }
;;;285      }
;;;286    #endif /* STM32F105xC || STM32F107xC */
;;;287    
;;;288    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;289     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;290     || defined(STM32F105xC) || defined(STM32F107xC)
;;;291      /*------------------------------ USB clock Configuration ------------------*/ 
;;;292      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;293      {
;;;294        /* Check the parameters */
;;;295        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;296        
;;;297        /* Configure the USB clock source */
;;;298        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;299      }
;;;300    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;301    
;;;302      return HAL_OK;
;;;303    }
000056  e8bd83f8          POP      {r3-r9,pc}
                  |L3.90|
00005a  6828              LDR      r0,[r5,#0]            ;153
00005c  05c0              LSLS     r0,r0,#23             ;153
00005e  d5f4              BPL      |L3.74|
                  |L3.96|
000060  f8d80020          LDR      r0,[r8,#0x20]         ;163
000064  f4007040          AND      r0,r0,#0x300          ;163
000068  b310              CBZ      r0,|L3.176|
00006a  88a1              LDRH     r1,[r4,#4]            ;164
00006c  f4017140          AND      r1,r1,#0x300          ;164
000070  4281              CMP      r1,r0                 ;164
000072  d01d              BEQ      |L3.176|
000074  f8d80020          LDR      r0,[r8,#0x20]         ;167
000078  f4207040          BIC      r0,r0,#0x300          ;167
00007c  4922              LDR      r1,|L3.264|
00007e  2201              MOVS     r2,#1                 ;169
000080  600a              STR      r2,[r1,#0]            ;169
000082  2200              MOVS     r2,#0                 ;170
000084  600a              STR      r2,[r1,#0]            ;170
000086  f8c80020          STR      r0,[r8,#0x20]         ;172
00008a  07c0              LSLS     r0,r0,#31             ;175
00008c  d010              BEQ      |L3.176|
00008e  f7fffffe          BL       HAL_GetTick
000092  4605              MOV      r5,r0                 ;178
000094  f2413688          MOV      r6,#0x1388            ;183
000098  e006              B        |L3.168|
                  |L3.154|
00009a  f7fffffe          BL       HAL_GetTick
00009e  1b40              SUBS     r0,r0,r5              ;183
0000a0  42b0              CMP      r0,r6                 ;183
0000a2  d901              BLS      |L3.168|
0000a4  2003              MOVS     r0,#3                 ;185
0000a6  e7d6              B        |L3.86|
                  |L3.168|
0000a8  f8d80020          LDR      r0,[r8,#0x20]         ;181
0000ac  0780              LSLS     r0,r0,#30             ;181
0000ae  d5f4              BPL      |L3.154|
                  |L3.176|
0000b0  f8d80020          LDR      r0,[r8,#0x20]         ;190
0000b4  6861              LDR      r1,[r4,#4]            ;190
0000b6  f4207040          BIC      r0,r0,#0x300          ;190
0000ba  4308              ORRS     r0,r0,r1              ;190
0000bc  f8c80020          STR      r0,[r8,#0x20]         ;190
0000c0  2f01              CMP      r7,#1                 ;193
0000c2  d105              BNE      |L3.208|
0000c4  f8d8001c          LDR      r0,[r8,#0x1c]         ;195
0000c8  f0205080          BIC      r0,r0,#0x10000000     ;195
0000cc  f8c8001c          STR      r0,[r8,#0x1c]         ;195
                  |L3.208|
0000d0  7820              LDRB     r0,[r4,#0]            ;200
0000d2  0780              LSLS     r0,r0,#30             ;200
0000d4  d507              BPL      |L3.230|
0000d6  f8d80004          LDR      r0,[r8,#4]            ;206
0000da  68a1              LDR      r1,[r4,#8]            ;206
0000dc  f4204040          BIC      r0,r0,#0xc000         ;206
0000e0  4308              ORRS     r0,r0,r1              ;206
0000e2  f8c80004          STR      r0,[r8,#4]            ;206
                  |L3.230|
0000e6  7820              LDRB     r0,[r4,#0]            ;292
0000e8  06c0              LSLS     r0,r0,#27             ;292
0000ea  d507              BPL      |L3.252|
0000ec  f8d80004          LDR      r0,[r8,#4]            ;298
0000f0  68e1              LDR      r1,[r4,#0xc]          ;298
0000f2  f4200080          BIC      r0,r0,#0x400000       ;298
0000f6  4308              ORRS     r0,r0,r1              ;298
0000f8  f8c80004          STR      r0,[r8,#4]            ;298
                  |L3.252|
0000fc  2000              MOVS     r0,#0                 ;302
0000fe  e7aa              B        |L3.86|
;;;304    
                          ENDP

                  |L3.256|
                          DCD      0x40021000
                  |L3.260|
                          DCD      0x40007000
                  |L3.264|
                          DCD      0x42420440

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
