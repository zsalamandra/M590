; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -ogsm_stm32f103\gsm_usart.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\gsm_usart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS -IE:\MC\2.STM32\STMProjects\GSM\M590\Project\Keil\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=gsm_stm32f103\gsm_usart.crf ..\Hardware\GSM_LIB\USART\gsm_usart.c]
                          THUMB

                          AREA ||i.GSM_UART_Abort||, CODE, READONLY, ALIGN=2

                  GSM_UART_Abort PROC
;;;97       */
;;;98     void GSM_UART_Abort(){
000000  4802              LDR      r0,|L1.12|
;;;99     	USART1->CR1 &= !USART_CR1_UE;
000002  6801              LDR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
000006  6001              STR      r1,[r0,#0]
;;;100    }
000008  4770              BX       lr
;;;101    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x4001380c

                          AREA ||i.GSM_UART_FlushRxBuf||, CODE, READONLY, ALIGN=2

                  GSM_UART_FlushRxBuf PROC
;;;166      */
;;;167    void GSM_UART_FlushRxBuf(void){
000000  b510              PUSH     {r4,lr}
;;;168    	memset(rxBuffer, 0x00, rxBufferLength);
000002  2180              MOVS     r1,#0x80
000004  4804              LDR      r0,|L2.24|
000006  f7fffffe          BL       __aeabi_memclr
;;;169    	rxLength = 0;
00000a  4804              LDR      r0,|L2.28|
00000c  2100              MOVS     r1,#0
00000e  8081              STRH     r1,[r0,#4]
;;;170    	prxBuffer = rxBuffer;
000010  4901              LDR      r1,|L2.24|
000012  6081              STR      r1,[r0,#8]  ; prxBuffer
;;;171    	
;;;172    }
000014  bd10              POP      {r4,pc}
;;;173    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      ||.bss||+0x20
                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.GSM_UART_FlushTxBuf||, CODE, READONLY, ALIGN=2

                  GSM_UART_FlushTxBuf PROC
;;;155      */
;;;156    void GSM_UART_FlushTxBuf(void){
000000  2120              MOVS     r1,#0x20
;;;157    	memset(txBuffer, 0x00, txBufferLength);
000002  4801              LDR      r0,|L3.8|
000004  f7ffbffe          B.W      __aeabi_memclr
;;;158    }
;;;159    
                          ENDP

                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.GSM_UART_GetRxBuffer||, CODE, READONLY, ALIGN=2

                  GSM_UART_GetRxBuffer PROC
;;;191      */
;;;192    char *GSM_UART_GetRxBuffer(void){
000000  4800              LDR      r0,|L4.4|
;;;193    	return rxBuffer;
;;;194    }
000002  4770              BX       lr
                          ENDP

                  |L4.4|
                          DCD      ||.bss||+0x20

                          AREA ||i.GSM_UART_GetTxBuffer||, CODE, READONLY, ALIGN=2

                  GSM_UART_GetTxBuffer PROC
;;;180      */
;;;181    char *GSM_UART_GetTxBuffer(void){
000000  4800              LDR      r0,|L5.4|
;;;182    	return txBuffer;
;;;183    }
000002  4770              BX       lr
;;;184    
                          ENDP

                  |L5.4|
                          DCD      ||.bss||

                          AREA ||i.GSM_UART_Init||, CODE, READONLY, ALIGN=2

                  GSM_UART_Init PROC
;;;16     
;;;17     void GSM_UART_Init(){
000000  4812              LDR      r0,|L6.76|
;;;18     	
;;;19     	// Включаем модули USART1 и GPIOA, а также включаем альтернативные функции выходов
;;;20       RCC->APB2ENR|= RCC_APB2ENR_USART1EN | RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN;
000002  6981              LDR      r1,[r0,#0x18]
000004  f2440205          MOV      r2,#0x4005
000008  4311              ORRS     r1,r1,r2
00000a  6181              STR      r1,[r0,#0x18]
;;;21     	
;;;22       // Контакт PA9 будет выходом с альтернативной функцией, а контакт PA10 - входом
;;;23       GPIOA->CRH &= !GPIO_CRH_CNF9;
00000c  4810              LDR      r0,|L6.80|
00000e  6801              LDR      r1,[r0,#0]
000010  2100              MOVS     r1,#0
000012  6001              STR      r1,[r0,#0]
;;;24       GPIOA->CRH |= GPIO_CRH_CNF9_1 | GPIO_CRH_MODE9_0 | GPIO_CRH_CNF10_0;
000014  6801              LDR      r1,[r0,#0]
000016  f4416192          ORR      r1,r1,#0x490
00001a  6001              STR      r1,[r0,#0]
;;;25     	
;;;26     	// Настраиваем регистр тактирования, скорость составит 9600 бод (при тактовой частоте 24 МГц)
;;;27       USART1->BRR = 0x271; //72000000/115200 = 625
00001c  490d              LDR      r1,|L6.84|
00001e  f2402071          MOV      r0,#0x271
000022  6008              STR      r0,[r1,#0]
;;;28       // Включаем TxD и RxD USART
;;;29       USART1->CR1 |= USART_CR1_TE | USART_CR1_RE;
000024  1d08              ADDS     r0,r1,#4
000026  6801              LDR      r1,[r0,#0]
000028  f041010c          ORR      r1,r1,#0xc
00002c  6001              STR      r1,[r0,#0]
;;;30       // Запускаем модуль USART
;;;31       USART1->CR1 |= USART_CR1_UE;
00002e  6801              LDR      r1,[r0,#0]
000030  f4415100          ORR      r1,r1,#0x2000
000034  6001              STR      r1,[r0,#0]
;;;32       // Разрешаем прерывание по приёму информации с RxD
;;;33       USART1->CR1 |= USART_CR1_RXNEIE;
000036  6801              LDR      r1,[r0,#0]
000038  f0410120          ORR      r1,r1,#0x20
00003c  6001              STR      r1,[r0,#0]
00003e  4906              LDR      r1,|L6.88|
000040  2020              MOVS     r0,#0x20
000042  6008              STR      r0,[r1,#0]
;;;34       // Назначаем обработчик для всех прерываний от USART1
;;;35       NVIC_EnableIRQ(USART1_IRQn);	
;;;36     	
;;;37     	prxBuffer = rxBuffer;
000044  4906              LDR      r1,|L6.96|
000046  4805              LDR      r0,|L6.92|
000048  6088              STR      r0,[r1,#8]  ; prxBuffer
;;;38     }
00004a  4770              BX       lr
;;;39     
                          ENDP

                  |L6.76|
                          DCD      0x40021000
                  |L6.80|
                          DCD      0x40010804
                  |L6.84|
                          DCD      0x40013808
                  |L6.88|
                          DCD      0xe000e104
                  |L6.92|
                          DCD      ||.bss||+0x20
                  |L6.96|
                          DCD      ||.data||

                          AREA ||i.GSM_UART_Resume||, CODE, READONLY, ALIGN=2

                  GSM_UART_Resume PROC
;;;110      */
;;;111    void GSM_UART_Resume(){
000000  4802              LDR      r0,|L7.12|
;;;112    	USART1->CR1 |= USART_CR1_UE;
000002  6801              LDR      r1,[r0,#0]
000004  f4415100          ORR      r1,r1,#0x2000
000008  6001              STR      r1,[r0,#0]
;;;113    }
00000a  4770              BX       lr
;;;114    
                          ENDP

                  |L7.12|
                          DCD      0x4001380c

                          AREA ||i.GSM_UART_SendATCommand||, CODE, READONLY, ALIGN=2

                  GSM_UART_SendATCommand PROC
;;;59       */
;;;60     enum reportForm GSM_UART_SendATCommand(uint32_t Timeout){
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
;;;61     	
;;;62     	uint32_t tickstart = 0U;
;;;63     	uint8_t commandLength = strlen(txBuffer);
000006  4815              LDR      r0,|L8.92|
000008  f7fffffe          BL       strlen
00000c  f00009ff          AND      r9,r0,#0xff
;;;64     	uint8_t length = 0;
000010  2300              MOVS     r3,#0
;;;65     	
;;;66     	report_form	= rfNone;
000012  4d13              LDR      r5,|L8.96|
000014  2000              MOVS     r0,#0
000016  7028              STRB     r0,[r5,#0]
;;;67     
;;;68     	tickstart = DWT->CYCCNT;
000018  4e12              LDR      r6,|L8.100|
00001a  6874              LDR      r4,[r6,#4]
00001c  f8df803c          LDR      r8,|L8.92|
;;;69     	
;;;70     	while(length < commandLength){
000020  e005              B        |L8.46|
                  |L8.34|
;;;71     		
;;;72     		gsm_usart_send_char(*(txBuffer+length));
000022  f8180003          LDRB     r0,[r8,r3]
000026  f7fffffe          BL       gsm_usart_send_char
;;;73     		length++;
00002a  1c5b              ADDS     r3,r3,#1
00002c  b2db              UXTB     r3,r3
                  |L8.46|
00002e  454b              CMP      r3,r9                 ;70
000030  d3f7              BCC      |L8.34|
;;;74     	}
;;;75     	uint32_t us_count_tic =  Timeout * (SystemCoreClock/1000);
000032  480d              LDR      r0,|L8.104|
000034  f44f717a          MOV      r1,#0x3e8
000038  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00003a  fbb0f1f1          UDIV     r1,r0,r1
00003e  4379              MULS     r1,r7,r1
;;;76     
;;;77     	while (report_form == rfNone){
000040  e006              B        |L8.80|
                  |L8.66|
;;;78     
;;;79     		uint32_t a = delta(tickstart, DWT->CYCCNT);
000042  6870              LDR      r0,[r6,#4]
000044  1b00              SUBS     r0,r0,r4
;;;80     		if (a > us_count_tic)
000046  4288              CMP      r0,r1
000048  d902              BLS      |L8.80|
;;;81     		{
;;;82     			return rfError;
00004a  2003              MOVS     r0,#3
                  |L8.76|
;;;83     		}
;;;84     	}
;;;85     	
;;;86     	return report_form;
;;;87     	
;;;88     }
00004c  e8bd87f0          POP      {r4-r10,pc}
                  |L8.80|
000050  7828              LDRB     r0,[r5,#0]            ;77  ; report_form
000052  2800              CMP      r0,#0                 ;77
000054  d0f5              BEQ      |L8.66|
000056  7828              LDRB     r0,[r5,#0]            ;86  ; report_form
000058  e7f8              B        |L8.76|
;;;89     
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      ||.bss||
                  |L8.96|
                          DCD      ||.data||
                  |L8.100|
                          DCD      0xe0001000
                  |L8.104|
                          DCD      SystemCoreClock

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;123      */
;;;124    void USART1_IRQHandler(void) {
000000  4810              LDR      r0,|L9.68|
;;;125      
;;;126    	static uint16_t symI = 0;
;;;127    
;;;128    	if (USART1->SR & USART_SR_RXNE){
000002  6801              LDR      r1,[r0,#0]
000004  0689              LSLS     r1,r1,#26
000006  d51b              BPL      |L9.64|
;;;129    			
;;;130    		// Сбрасываем флаг прерывания
;;;131    		USART1->SR &=	~USART_SR_RXNE;
000008  6801              LDR      r1,[r0,#0]
00000a  f0210120          BIC      r1,r1,#0x20
00000e  6001              STR      r1,[r0,#0]
;;;132    		uint8_t sym = (uint8_t)(USART1->DR & (uint16_t)0x00FF);
000010  1d00              ADDS     r0,r0,#4
000012  6800              LDR      r0,[r0,#0]
000014  b2c0              UXTB     r0,r0
;;;133    
;;;134    		if (sym == 0x4F){
;;;135    			symI = sym;
000016  4a0c              LDR      r2,|L9.72|
000018  284f              CMP      r0,#0x4f              ;134
00001a  d100              BNE      |L9.30|
00001c  8050              STRH     r0,[r2,#2]
                  |L9.30|
;;;136    		}
;;;137    		if (sym == 0x4B){
00001e  284b              CMP      r0,#0x4b
000020  d109              BNE      |L9.54|
;;;138    			symI |= (uint16_t)(sym<<8);
000022  8851              LDRH     r1,[r2,#2]  ; symI
000024  f4414196          ORR      r1,r1,#0x4b00
000028  8051              STRH     r1,[r2,#2]
;;;139    			if (symI == 0x4B4F){
00002a  f5a14396          SUB      r3,r1,#0x4b00
00002e  3b4f              SUBS     r3,r3,#0x4f
000030  d101              BNE      |L9.54|
;;;140    				report_form = rfOK;
000032  2101              MOVS     r1,#1
000034  7011              STRB     r1,[r2,#0]
                  |L9.54|
;;;141    			}
;;;142    		}
;;;143    		
;;;144    		*(prxBuffer + rxLength++) = sym;
000036  8891              LDRH     r1,[r2,#4]  ; rxLength
000038  1c4b              ADDS     r3,r1,#1
00003a  8093              STRH     r3,[r2,#4]
00003c  6892              LDR      r2,[r2,#8]  ; prxBuffer
00003e  5450              STRB     r0,[r2,r1]
                  |L9.64|
;;;145    	}
;;;146    }
000040  4770              BX       lr
;;;147    
                          ENDP

000042  0000              DCW      0x0000
                  |L9.68|
                          DCD      0x40013800
                  |L9.72|
                          DCD      ||.data||

                          AREA ||i.gsm_usart_send_char||, CODE, READONLY, ALIGN=2

                  gsm_usart_send_char PROC
;;;40     // отправить символ 
;;;41     void gsm_usart_send_char(char ch) {
000000  4903              LDR      r1,|L10.16|
                  |L10.2|
;;;42     	
;;;43       while(!(USART1->SR & USART_SR_TC));
000002  680a              LDR      r2,[r1,#0]
000004  0652              LSLS     r2,r2,#25
000006  d5fc              BPL      |L10.2|
;;;44       USART1->DR = ch;
000008  4901              LDR      r1,|L10.16|
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;45     	
;;;46     }
00000e  4770              BX       lr
;;;47     
                          ENDP

                  |L10.16|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  txBuffer
                          %        32
                  rxBuffer
                          %        128

                          AREA ||.data||, DATA, ALIGN=2

                  report_form
000000  0000              DCB      0x00,0x00
                  symI
000002  0000              DCW      0x0000
                  rxLength
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  prxBuffer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Hardware\\GSM_LIB\\USART\\gsm_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_gsm_usart_c_d24a68d9____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_gsm_usart_c_d24a68d9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_gsm_usart_c_d24a68d9____REVSH|
#line 402
|__asm___11_gsm_usart_c_d24a68d9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_gsm_usart_c_d24a68d9____RRX|
#line 587
|__asm___11_gsm_usart_c_d24a68d9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
