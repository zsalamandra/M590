; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -ogsm_stm32f103\stm32f1xx_hal_tim.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\stm32f1xx_hal_tim.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS -IE:\MC\2.STM32\STMProjects\GSM\M590\Project\Keil\gsm_stm32f103\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=gsm_stm32f103\stm32f1xx_hal_tim.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;245      */
;;;246    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248      /* Check the parameters */
;;;249      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;250    
;;;251      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;252    
;;;253      /* Disable the TIM Peripheral Clock */
;;;254      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L1.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L1.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L1.38|
;;;255    
;;;256      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;257      HAL_TIM_Base_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;258    
;;;259      /* Change TIM state */
;;;260      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;261    
;;;262      /* Release Lock */
;;;263      __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;264    
;;;265      return HAL_OK;
;;;266    }
000034  bd10              POP      {r4,pc}
;;;267    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4388     */
;;;4389   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4390   {
;;;4391     return htim->State;
;;;4392   }
000004  4770              BX       lr
;;;4393   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;207    {
000002  4604              MOV      r4,r0
;;;208      /* Check the TIM handle allocation */
;;;209      if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L3.16|
;;;210      {
;;;211        return HAL_ERROR;
;;;212      }
;;;213    
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;216      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;217      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;218      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;219    
;;;220      if(htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L3.20|
00000e  e007              B        |L3.32|
                  |L3.16|
000010  2001              MOVS     r0,#1                 ;211
;;;221      {
;;;222        /* Allocate lock resource and initialize it */
;;;223        htim->Lock = HAL_UNLOCKED;
;;;224        
;;;225        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;226        HAL_TIM_Base_MspInit(htim);
;;;227      }
;;;228    
;;;229      /* Set the TIM state */
;;;230      htim->State= HAL_TIM_STATE_BUSY;
;;;231    
;;;232      /* Set the Time Base configuration */
;;;233      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;234    
;;;235      /* Initialize the TIM state*/
;;;236      htim->State= HAL_TIM_STATE_READY;
;;;237    
;;;238      return HAL_OK;
;;;239    }
000012  bd10              POP      {r4,pc}
                  |L3.20|
000014  2000              MOVS     r0,#0                 ;223
000016  f884003c          STRB     r0,[r4,#0x3c]         ;223
00001a  4620              MOV      r0,r4                 ;226
00001c  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.32|
000020  2002              MOVS     r0,#2                 ;230
000022  f884003d          STRB     r0,[r4,#0x3d]         ;230
000026  1d21              ADDS     r1,r4,#4              ;233
000028  6820              LDR      r0,[r4,#0]            ;233
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;236
000030  f884003d          STRB     r0,[r4,#0x3d]         ;236
000034  2000              MOVS     r0,#0                 ;238
000036  bd10              POP      {r4,pc}
;;;240    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;286      */
;;;287    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;288    {
;;;289      /* Prevent unused argument(s) compilation warning */
;;;290      UNUSED(htim);
;;;291      /* NOTE : This function Should not be modified, when the callback is needed,
;;;292                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;293       */
;;;294    }
;;;295    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;272      */
;;;273    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(htim);
;;;277      /* NOTE : This function Should not be modified, when the callback is needed,
;;;278                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;279       */
;;;280    }
;;;281    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;301    */
;;;302    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;303    {
;;;304      /* Check the parameters */
;;;305      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;306    
;;;307      /* Set the TIM state */
;;;308      htim->State= HAL_TIM_STATE_BUSY;
000002  f880103d          STRB     r1,[r0,#0x3d]
;;;309    
;;;310      /* Enable the Peripheral */
;;;311      __HAL_TIM_ENABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
00000a  f0420201          ORR      r2,r2,#1
00000e  600a              STR      r2,[r1,#0]
;;;312    
;;;313      /* Change the TIM state*/
;;;314      htim->State= HAL_TIM_STATE_READY;
000010  2101              MOVS     r1,#1
000012  f880103d          STRB     r1,[r0,#0x3d]
;;;315    
;;;316      /* Return function status */
;;;317      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;318    }
000018  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;388    */
;;;389    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;390    {
000002  4604              MOV      r4,r0
000004  4613              MOV      r3,r2
;;;391      /* Check the parameters */
;;;392      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;393    
;;;394      if((htim->State == HAL_TIM_STATE_BUSY))
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L7.24|
;;;395      {
;;;396         return HAL_BUSY;
;;;397      }
;;;398      else if((htim->State == HAL_TIM_STATE_READY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2801              CMP      r0,#1
000014  d002              BEQ      |L7.28|
000016  e008              B        |L7.42|
                  |L7.24|
000018  2002              MOVS     r0,#2                 ;396
;;;399      {
;;;400        if((pData == 0U) && (Length > 0U))
;;;401        {
;;;402          return HAL_ERROR;
;;;403        }
;;;404        else
;;;405        {
;;;406          htim->State = HAL_TIM_STATE_BUSY;
;;;407        }
;;;408      }
;;;409      /* Set the DMA Period elapsed callback */
;;;410      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;411    
;;;412      /* Set the DMA error callback */
;;;413      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;414    
;;;415      /* Enable the DMA channel */
;;;416      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;417    
;;;418      /* Enable the TIM Update DMA request */
;;;419      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;420    
;;;421      /* Enable the Peripheral */
;;;422      __HAL_TIM_ENABLE(htim);
;;;423    
;;;424      /* Return function status */
;;;425      return HAL_OK;
;;;426    }
00001a  bd10              POP      {r4,pc}
                  |L7.28|
00001c  b911              CBNZ     r1,|L7.36|
00001e  b10b              CBZ      r3,|L7.36|
000020  2001              MOVS     r0,#1                 ;402
000022  bd10              POP      {r4,pc}
                  |L7.36|
000024  2002              MOVS     r0,#2                 ;406
000026  f884003d          STRB     r0,[r4,#0x3d]         ;406
                  |L7.42|
00002a  6a22              LDR      r2,[r4,#0x20]         ;410
00002c  480a              LDR      r0,|L7.88|
00002e  6290              STR      r0,[r2,#0x28]         ;410
000030  6a22              LDR      r2,[r4,#0x20]         ;413
000032  480a              LDR      r0,|L7.92|
000034  6310              STR      r0,[r2,#0x30]         ;413
000036  6822              LDR      r2,[r4,#0]            ;416
000038  6a20              LDR      r0,[r4,#0x20]         ;416
00003a  322c              ADDS     r2,r2,#0x2c           ;416
00003c  f7fffffe          BL       HAL_DMA_Start_IT
000040  6820              LDR      r0,[r4,#0]            ;419
000042  68c1              LDR      r1,[r0,#0xc]          ;419
000044  f4417180          ORR      r1,r1,#0x100          ;419
000048  60c1              STR      r1,[r0,#0xc]          ;419
00004a  6820              LDR      r0,[r4,#0]            ;422
00004c  6801              LDR      r1,[r0,#0]            ;422
00004e  f0410101          ORR      r1,r1,#1              ;422
000052  6001              STR      r1,[r0,#0]            ;422
000054  2000              MOVS     r0,#0                 ;425
000056  bd10              POP      {r4,pc}
;;;427    
                          ENDP

                  |L7.88|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.92|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;347    */
;;;348    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;349    {
;;;350      /* Check the parameters */
;;;351      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;352    
;;;353       /* Enable the TIM Update interrupt */
;;;354       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;355    
;;;356       /* Enable the Peripheral */
;;;357      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;358    
;;;359      /* Return function status */
;;;360      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;361    }
000016  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;324    */
;;;325    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;329    
;;;330      /* Set the TIM state */
;;;331      htim->State= HAL_TIM_STATE_BUSY;
000002  f880103d          STRB     r1,[r0,#0x3d]
;;;332    
;;;333      /* Disable the Peripheral */
;;;334      __HAL_TIM_DISABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  6a0a              LDR      r2,[r1,#0x20]
00000a  f2411311          MOV      r3,#0x1111
00000e  421a              TST      r2,r3
000010  d107              BNE      |L9.34|
000012  6a0a              LDR      r2,[r1,#0x20]
000014  109b              ASRS     r3,r3,#2
000016  421a              TST      r2,r3
000018  d103              BNE      |L9.34|
00001a  680a              LDR      r2,[r1,#0]
00001c  f0220201          BIC      r2,r2,#1
000020  600a              STR      r2,[r1,#0]
                  |L9.34|
;;;335    
;;;336      /* Change the TIM state*/
;;;337      htim->State= HAL_TIM_STATE_READY;
000022  2101              MOVS     r1,#1
000024  f880103d          STRB     r1,[r0,#0x3d]
;;;338    
;;;339      /* Return function status */
;;;340      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;341    }
00002a  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;432    */
;;;433    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;434    {
;;;435      /* Check the parameters */
;;;436      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;437    
;;;438      /* Disable the TIM Update DMA request */
;;;439      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227280          BIC      r2,r2,#0x100
000008  60ca              STR      r2,[r1,#0xc]
;;;440    
;;;441      /* Disable the Peripheral */
;;;442      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;443    
;;;444      /* Change the htim state */
;;;445      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  f880103d          STRB     r1,[r0,#0x3d]
;;;446    
;;;447      /* Return function status */
;;;448      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;449    }
00002e  4770              BX       lr
;;;450    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;367    */
;;;368    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;369    {
;;;370      /* Check the parameters */
;;;371      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;372      /* Disable the TIM Update interrupt */
;;;373      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;374    
;;;375      /* Disable the Peripheral */
;;;376      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;377    
;;;378      /* Return function status */
;;;379      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;380    }
000028  4770              BX       lr
;;;381    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3920     */ 
;;;3921   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;3922   {
000002  4604              MOV      r4,r0
;;;3923     uint32_t tmpsmcr = 0U;
;;;3924   
;;;3925     /* Process Locked */
;;;3926     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d017              BEQ      |L12.60|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;3927   
;;;3928     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;3929   
;;;3930     /* Check the parameters */
;;;3931     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3932   
;;;3933     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3934     tmpsmcr = htim->Instance->SMCR;
000018  6820              LDR      r0,[r4,#0]
00001a  6882              LDR      r2,[r0,#8]
;;;3935     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
00001c  f0220277          BIC      r2,r2,#0x77
;;;3936     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000020  f422427f          BIC      r2,r2,#0xff00
;;;3937     htim->Instance->SMCR = tmpsmcr;
000024  6082              STR      r2,[r0,#8]
;;;3938   
;;;3939     switch (sClockSourceConfig->ClockSource)
000026  6808              LDR      r0,[r1,#0]
000028  2850              CMP      r0,#0x50
00002a  d03a              BEQ      |L12.162|
00002c  dc0d              BGT      |L12.74|
00002e  2820              CMP      r0,#0x20
000030  d05f              BEQ      |L12.242|
000032  dc05              BGT      |L12.64|
000034  b3a0              CBZ      r0,|L12.160|
000036  2810              CMP      r0,#0x10
000038  d164              BNE      |L12.260|
00003a  e055              B        |L12.232|
                  |L12.60|
00003c  2002              MOVS     r0,#2                 ;3926
;;;3940     {
;;;3941     case TIM_CLOCKSOURCE_INTERNAL:
;;;3942       {
;;;3943         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3944         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3945         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3946       }
;;;3947       break;
;;;3948   
;;;3949     case TIM_CLOCKSOURCE_ETRMODE1:
;;;3950       {
;;;3951         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;3952         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;3953   
;;;3954         /* Check ETR input conditioning related parameters */
;;;3955         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3956         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3957         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3958         
;;;3959         /* Configure the ETR Clock source */
;;;3960         TIM_ETR_SetConfig(htim->Instance,
;;;3961                           sClockSourceConfig->ClockPrescaler,
;;;3962                           sClockSourceConfig->ClockPolarity,
;;;3963                           sClockSourceConfig->ClockFilter);
;;;3964         /* Get the TIMx SMCR register value */
;;;3965         tmpsmcr = htim->Instance->SMCR;
;;;3966         /* Reset the SMS and TS Bits */
;;;3967         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3968         /* Select the External clock mode1 and the ETRF trigger */
;;;3969         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3970         /* Write to TIMx SMCR */
;;;3971         htim->Instance->SMCR = tmpsmcr;
;;;3972       }
;;;3973       break;
;;;3974   
;;;3975     case TIM_CLOCKSOURCE_ETRMODE2:
;;;3976       {
;;;3977         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;3978         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;3979   
;;;3980         /* Check ETR input conditioning related parameters */
;;;3981         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3982         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3983         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3984         
;;;3985         /* Configure the ETR Clock source */
;;;3986         TIM_ETR_SetConfig(htim->Instance,
;;;3987                           sClockSourceConfig->ClockPrescaler,
;;;3988                           sClockSourceConfig->ClockPolarity,
;;;3989                           sClockSourceConfig->ClockFilter);
;;;3990         /* Enable the External clock mode2 */
;;;3991         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3992       }
;;;3993       break;
;;;3994   
;;;3995     case TIM_CLOCKSOURCE_TI1:
;;;3996       {
;;;3997         /* Check whether or not the timer instance supports external clock mode 1 */
;;;3998         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3999   
;;;4000         /* Check TI1 input conditioning related parameters */
;;;4001         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4002         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4003         
;;;4004         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4005                                  sClockSourceConfig->ClockPolarity,
;;;4006                                  sClockSourceConfig->ClockFilter);
;;;4007         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4008       }
;;;4009       break;
;;;4010     case TIM_CLOCKSOURCE_TI2:
;;;4011       {
;;;4012         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;4013         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4014   
;;;4015          /* Check TI2 input conditioning related parameters */
;;;4016         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4017         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4018   
;;;4019         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4020                                  sClockSourceConfig->ClockPolarity,
;;;4021                                  sClockSourceConfig->ClockFilter);
;;;4022         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4023       }
;;;4024       break;
;;;4025     case TIM_CLOCKSOURCE_TI1ED:
;;;4026       {
;;;4027         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4028         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4029   
;;;4030         /* Check TI1 input conditioning related parameters */
;;;4031         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4032         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4033   
;;;4034         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4035                                  sClockSourceConfig->ClockPolarity,
;;;4036                                  sClockSourceConfig->ClockFilter);
;;;4037         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4038       }
;;;4039       break;
;;;4040     case TIM_CLOCKSOURCE_ITR0:
;;;4041       {
;;;4042         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4043         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4044   
;;;4045         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4046       }
;;;4047       break;
;;;4048     case TIM_CLOCKSOURCE_ITR1:
;;;4049       {
;;;4050         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4051         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4052   
;;;4053         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4054       }
;;;4055       break;
;;;4056     case TIM_CLOCKSOURCE_ITR2:
;;;4057       {
;;;4058         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4059         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4060   
;;;4061         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4062       }
;;;4063       break;
;;;4064     case TIM_CLOCKSOURCE_ITR3:
;;;4065       {
;;;4066         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4067         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4068   
;;;4069         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4070       }
;;;4071       break;
;;;4072   
;;;4073     default:
;;;4074       break;
;;;4075     }
;;;4076     htim->State = HAL_TIM_STATE_READY;
;;;4077   
;;;4078     __HAL_UNLOCK(htim);
;;;4079   
;;;4080     return HAL_OK;
;;;4081   }
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2830              CMP      r0,#0x30              ;3939
000042  d05b              BEQ      |L12.252|
000044  2840              CMP      r0,#0x40              ;3939
000046  d15d              BNE      |L12.260|
000048  e03f              B        |L12.202|
                  |L12.74|
00004a  2860              CMP      r0,#0x60              ;3939
00004c  d033              BEQ      |L12.182|
00004e  2870              CMP      r0,#0x70              ;3939
000050  d00c              BEQ      |L12.108|
000052  f5b05f80          CMP      r0,#0x1000            ;3939
000056  d003              BEQ      |L12.96|
000058  f5b05f00          CMP      r0,#0x2000            ;3939
00005c  d152              BNE      |L12.260|
00005e  e013              B        |L12.136|
                  |L12.96|
000060  6820              LDR      r0,[r4,#0]            ;3945
000062  6881              LDR      r1,[r0,#8]            ;3945
000064  f0210107          BIC      r1,r1,#7              ;3945
000068  6081              STR      r1,[r0,#8]            ;3945
00006a  e04b              B        |L12.260|
                  |L12.108|
00006c  68cb              LDR      r3,[r1,#0xc]          ;3960
00006e  e9d12101          LDRD     r2,r1,[r1,#4]         ;3960
000072  6820              LDR      r0,[r4,#0]            ;3960
000074  f7fffffe          BL       TIM_ETR_SetConfig
000078  6820              LDR      r0,[r4,#0]            ;3965
00007a  6881              LDR      r1,[r0,#8]            ;3965
00007c  f0210177          BIC      r1,r1,#0x77           ;3967
000080  f0410177          ORR      r1,r1,#0x77           ;3969
000084  6081              STR      r1,[r0,#8]            ;3971
000086  e03d              B        |L12.260|
                  |L12.136|
000088  68cb              LDR      r3,[r1,#0xc]          ;3986
00008a  e9d12101          LDRD     r2,r1,[r1,#4]         ;3986
00008e  6820              LDR      r0,[r4,#0]            ;3986
000090  f7fffffe          BL       TIM_ETR_SetConfig
000094  6820              LDR      r0,[r4,#0]            ;3991
000096  6881              LDR      r1,[r0,#8]            ;3991
000098  f4414180          ORR      r1,r1,#0x4000         ;3991
00009c  6081              STR      r1,[r0,#8]            ;3991
00009e  e031              B        |L12.260|
                  |L12.160|
0000a0  e01d              B        |L12.222|
                  |L12.162|
0000a2  68ca              LDR      r2,[r1,#0xc]          ;4004
0000a4  6849              LDR      r1,[r1,#4]            ;4004
0000a6  6820              LDR      r0,[r4,#0]            ;4004
0000a8  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000ac  2150              MOVS     r1,#0x50              ;4007
0000ae  6820              LDR      r0,[r4,#0]            ;4007
0000b0  f7fffffe          BL       TIM_ITRx_SetConfig
0000b4  e026              B        |L12.260|
                  |L12.182|
0000b6  68ca              LDR      r2,[r1,#0xc]          ;4019
0000b8  6849              LDR      r1,[r1,#4]            ;4019
0000ba  6820              LDR      r0,[r4,#0]            ;4019
0000bc  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000c0  2160              MOVS     r1,#0x60              ;4022
0000c2  6820              LDR      r0,[r4,#0]            ;4022
0000c4  f7fffffe          BL       TIM_ITRx_SetConfig
0000c8  e01c              B        |L12.260|
                  |L12.202|
0000ca  68ca              LDR      r2,[r1,#0xc]          ;4034
0000cc  6849              LDR      r1,[r1,#4]            ;4034
0000ce  6820              LDR      r0,[r4,#0]            ;4034
0000d0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000d4  2140              MOVS     r1,#0x40              ;4037
0000d6  6820              LDR      r0,[r4,#0]            ;4037
0000d8  f7fffffe          BL       TIM_ITRx_SetConfig
0000dc  e012              B        |L12.260|
                  |L12.222|
0000de  2100              MOVS     r1,#0                 ;4045
0000e0  6820              LDR      r0,[r4,#0]            ;4045
0000e2  f7fffffe          BL       TIM_ITRx_SetConfig
0000e6  e00d              B        |L12.260|
                  |L12.232|
0000e8  2110              MOVS     r1,#0x10              ;4053
0000ea  6820              LDR      r0,[r4,#0]            ;4053
0000ec  f7fffffe          BL       TIM_ITRx_SetConfig
0000f0  e008              B        |L12.260|
                  |L12.242|
0000f2  2120              MOVS     r1,#0x20              ;4061
0000f4  6820              LDR      r0,[r4,#0]            ;4061
0000f6  f7fffffe          BL       TIM_ITRx_SetConfig
0000fa  e003              B        |L12.260|
                  |L12.252|
0000fc  2130              MOVS     r1,#0x30              ;4069
0000fe  6820              LDR      r0,[r4,#0]            ;4069
000100  f7fffffe          BL       TIM_ITRx_SetConfig
                  |L12.260|
000104  343c              ADDS     r4,r4,#0x3c           ;4076
000106  7065              STRB     r5,[r4,#1]            ;4076
000108  2000              MOVS     r0,#0                 ;4078
00010a  7020              STRB     r0,[r4,#0]            ;4078
00010c  bd70              POP      {r4-r6,pc}
;;;4082   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3799     */ 
;;;3800   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3801   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;3802     uint32_t tmpsmcr = 0U;
00000a  2100              MOVS     r1,#0
;;;3803   
;;;3804     /* Check the parameters */
;;;3805     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3806     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3807     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3808     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3809     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3810   
;;;3811     /* Process Locked */
;;;3812     __HAL_LOCK(htim);
00000c  f894003c          LDRB     r0,[r4,#0x3c]
000010  2801              CMP      r0,#1
000012  d00a              BEQ      |L13.42|
000014  2701              MOVS     r7,#1
000016  f884703c          STRB     r7,[r4,#0x3c]
;;;3813   
;;;3814     htim->State = HAL_TIM_STATE_BUSY;
00001a  2002              MOVS     r0,#2
00001c  f884003d          STRB     r0,[r4,#0x3d]
000020  6868              LDR      r0,[r5,#4]            ;3812
000022  b128              CBZ      r0,|L13.48|
;;;3815   
;;;3816     switch (sClearInputConfig->ClearInputSource)
000024  2801              CMP      r0,#1
000026  d10c              BNE      |L13.66|
000028  e005              B        |L13.54|
                  |L13.42|
00002a  2002              MOVS     r0,#2                 ;3812
                  |L13.44|
;;;3817     {
;;;3818       case TIM_CLEARINPUTSOURCE_NONE:
;;;3819       {
;;;3820   
;;;3821         /* Clear the ETR Bits */
;;;3822         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3823   
;;;3824         /* Set TIMx_SMCR */
;;;3825         htim->Instance->SMCR = tmpsmcr;
;;;3826      }
;;;3827       break;
;;;3828   
;;;3829       case TIM_CLEARINPUTSOURCE_ETR:
;;;3830       {
;;;3831         TIM_ETR_SetConfig(htim->Instance,
;;;3832                           sClearInputConfig->ClearInputPrescaler,
;;;3833                           sClearInputConfig->ClearInputPolarity,
;;;3834                           sClearInputConfig->ClearInputFilter);
;;;3835   
;;;3836       }
;;;3837       break;
;;;3838       default:
;;;3839       break;
;;;3840     }
;;;3841   
;;;3842     switch (Channel)
;;;3843     {
;;;3844       case TIM_CHANNEL_1:
;;;3845         {
;;;3846           if(sClearInputConfig->ClearInputState != RESET)
;;;3847           {
;;;3848             /* Enable the Ocref clear feature for Channel 1 */
;;;3849             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3850           }
;;;3851           else
;;;3852           {
;;;3853             /* Disable the Ocref clear feature for Channel 1 */
;;;3854           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3855           }
;;;3856         }
;;;3857         break;
;;;3858       case TIM_CHANNEL_2:
;;;3859         {
;;;3860           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3861           if(sClearInputConfig->ClearInputState != RESET)
;;;3862           {
;;;3863             /* Enable the Ocref clear feature for Channel 2 */
;;;3864             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3865           }
;;;3866           else
;;;3867           {
;;;3868             /* Disable the Ocref clear feature for Channel 2 */
;;;3869             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3870           }
;;;3871         }
;;;3872       break;
;;;3873       case TIM_CHANNEL_3:
;;;3874         {
;;;3875           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3876           if(sClearInputConfig->ClearInputState != RESET)
;;;3877           {
;;;3878             /* Enable the Ocref clear feature for Channel 3 */
;;;3879             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3880           }
;;;3881           else
;;;3882           {
;;;3883             /* Disable the Ocref clear feature for Channel 3 */
;;;3884           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3885           }
;;;3886         }
;;;3887       break;
;;;3888       case TIM_CHANNEL_4:
;;;3889         {
;;;3890           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3891           if(sClearInputConfig->ClearInputState != RESET)
;;;3892           {
;;;3893             /* Enable the Ocref clear feature for Channel 4 */
;;;3894             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3895           }
;;;3896           else
;;;3897           {
;;;3898             /* Disable the Ocref clear feature for Channel 4 */
;;;3899           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3900           }
;;;3901         }
;;;3902       break;
;;;3903       default:
;;;3904       break;
;;;3905     }
;;;3906   
;;;3907     htim->State = HAL_TIM_STATE_READY;
;;;3908   
;;;3909     __HAL_UNLOCK(htim);
;;;3910   
;;;3911     return HAL_OK;
;;;3912   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.48|
000030  6820              LDR      r0,[r4,#0]            ;3825
000032  6081              STR      r1,[r0,#8]            ;3825
000034  e005              B        |L13.66|
                  |L13.54|
000036  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;3831
00003a  68aa              LDR      r2,[r5,#8]            ;3831
00003c  6820              LDR      r0,[r4,#0]            ;3831
00003e  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.66|
000042  b136              CBZ      r6,|L13.82|
000044  2e04              CMP      r6,#4                 ;3842
000046  d012              BEQ      |L13.110|
000048  2e08              CMP      r6,#8                 ;3842
00004a  d01e              BEQ      |L13.138|
00004c  2e0c              CMP      r6,#0xc               ;3842
00004e  d137              BNE      |L13.192|
000050  e029              B        |L13.166|
                  |L13.82|
000052  6828              LDR      r0,[r5,#0]            ;3846
000054  b128              CBZ      r0,|L13.98|
000056  6820              LDR      r0,[r4,#0]            ;3849
000058  6981              LDR      r1,[r0,#0x18]         ;3849
00005a  f0410180          ORR      r1,r1,#0x80           ;3849
00005e  6181              STR      r1,[r0,#0x18]         ;3849
000060  e02e              B        |L13.192|
                  |L13.98|
000062  6820              LDR      r0,[r4,#0]            ;3854
000064  6981              LDR      r1,[r0,#0x18]         ;3854
000066  f0210180          BIC      r1,r1,#0x80           ;3854
00006a  6181              STR      r1,[r0,#0x18]         ;3854
00006c  e028              B        |L13.192|
                  |L13.110|
00006e  6828              LDR      r0,[r5,#0]            ;3861
000070  b128              CBZ      r0,|L13.126|
000072  6820              LDR      r0,[r4,#0]            ;3864
000074  6981              LDR      r1,[r0,#0x18]         ;3864
000076  f4414100          ORR      r1,r1,#0x8000         ;3864
00007a  6181              STR      r1,[r0,#0x18]         ;3864
00007c  e020              B        |L13.192|
                  |L13.126|
00007e  6820              LDR      r0,[r4,#0]            ;3869
000080  6981              LDR      r1,[r0,#0x18]         ;3869
000082  f4214100          BIC      r1,r1,#0x8000         ;3869
000086  6181              STR      r1,[r0,#0x18]         ;3869
000088  e01a              B        |L13.192|
                  |L13.138|
00008a  6828              LDR      r0,[r5,#0]            ;3876
00008c  b128              CBZ      r0,|L13.154|
00008e  6820              LDR      r0,[r4,#0]            ;3879
000090  69c1              LDR      r1,[r0,#0x1c]         ;3879
000092  f0410180          ORR      r1,r1,#0x80           ;3879
000096  61c1              STR      r1,[r0,#0x1c]         ;3879
000098  e012              B        |L13.192|
                  |L13.154|
00009a  6820              LDR      r0,[r4,#0]            ;3884
00009c  69c1              LDR      r1,[r0,#0x1c]         ;3884
00009e  f0210180          BIC      r1,r1,#0x80           ;3884
0000a2  61c1              STR      r1,[r0,#0x1c]         ;3884
0000a4  e00c              B        |L13.192|
                  |L13.166|
0000a6  6828              LDR      r0,[r5,#0]            ;3891
0000a8  b128              CBZ      r0,|L13.182|
0000aa  6820              LDR      r0,[r4,#0]            ;3894
0000ac  69c1              LDR      r1,[r0,#0x1c]         ;3894
0000ae  f4414100          ORR      r1,r1,#0x8000         ;3894
0000b2  61c1              STR      r1,[r0,#0x1c]         ;3894
0000b4  e004              B        |L13.192|
                  |L13.182|
0000b6  6820              LDR      r0,[r4,#0]            ;3899
0000b8  69c1              LDR      r1,[r0,#0x1c]         ;3899
0000ba  f4214100          BIC      r1,r1,#0x8000         ;3899
0000be  61c1              STR      r1,[r0,#0x1c]         ;3899
                  |L13.192|
0000c0  343c              ADDS     r4,r4,#0x3c           ;3907
0000c2  7067              STRB     r7,[r4,#1]            ;3907
0000c4  2000              MOVS     r0,#0                 ;3909
0000c6  7020              STRB     r0,[r4,#0]            ;3909
0000c8  e7b0              B        |L13.44|
;;;3913   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4094     */
;;;4095   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6800              LDR      r0,[r0,#0]
;;;4096   {
;;;4097     uint32_t tmpcr2 = 0U;
;;;4098   
;;;4099     /* Check the parameters */
;;;4100     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4101     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4102   
;;;4103     /* Get the TIMx CR2 register value */
;;;4104     tmpcr2 = htim->Instance->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;4105   
;;;4106     /* Reset the TI1 selection */
;;;4107     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0220280          BIC      r2,r2,#0x80
;;;4108   
;;;4109     /* Set the the TI1 selection */
;;;4110     tmpcr2 |= TI1_Selection;
000008  430a              ORRS     r2,r2,r1
;;;4111   
;;;4112     /* Write to TIMxCR2 */
;;;4113     htim->Instance->CR2 = tmpcr2;
00000a  6042              STR      r2,[r0,#4]
;;;4114   
;;;4115     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4116   }
00000e  4770              BX       lr
;;;4117   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3558     */
;;;3559   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3560                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3561   {
000004  4615              MOV      r5,r2
000006  9e06              LDR      r6,[sp,#0x18]
000008  4604              MOV      r4,r0
00000a  4688              MOV      r8,r1
00000c  461a              MOV      r2,r3
;;;3562     /* Check the parameters */
;;;3563     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3564     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3565     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3566     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3567   
;;;3568     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2802              CMP      r0,#2
000014  d004              BEQ      |L15.32|
;;;3569     {
;;;3570        return HAL_BUSY;
;;;3571     }
;;;3572     else if((htim->State == HAL_TIM_STATE_READY))
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2801              CMP      r0,#1
00001c  d003              BEQ      |L15.38|
00001e  e009              B        |L15.52|
                  |L15.32|
000020  2002              MOVS     r0,#2                 ;3570
                  |L15.34|
;;;3573     {
;;;3574       if((BurstBuffer == 0U) && (BurstLength > 0U))
;;;3575       {
;;;3576         return HAL_ERROR;
;;;3577       }
;;;3578       else
;;;3579       {
;;;3580         htim->State = HAL_TIM_STATE_BUSY;
;;;3581       }
;;;3582     }
;;;3583     switch(BurstRequestSrc)
;;;3584     {
;;;3585       case TIM_DMA_UPDATE:
;;;3586       {
;;;3587         /* Set the DMA Period elapsed callback */
;;;3588         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3589   
;;;3590         /* Set the DMA error callback */
;;;3591         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3592   
;;;3593         /* Enable the DMA channel */
;;;3594          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3595       }
;;;3596       break;
;;;3597       case TIM_DMA_CC1:
;;;3598       {
;;;3599         /* Set the DMA Period elapsed callback */
;;;3600         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3601   
;;;3602         /* Set the DMA error callback */
;;;3603         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3604   
;;;3605         /* Enable the DMA channel */
;;;3606         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3607       }
;;;3608       break;
;;;3609       case TIM_DMA_CC2:
;;;3610       {
;;;3611         /* Set the DMA Period elapsed callback */
;;;3612         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3613   
;;;3614         /* Set the DMA error callback */
;;;3615         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3616   
;;;3617         /* Enable the DMA channel */
;;;3618         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3619       }
;;;3620       break;
;;;3621       case TIM_DMA_CC3:
;;;3622       {
;;;3623         /* Set the DMA Period elapsed callback */
;;;3624         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3625   
;;;3626         /* Set the DMA error callback */
;;;3627         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3628   
;;;3629         /* Enable the DMA channel */
;;;3630         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3631       }
;;;3632       break;
;;;3633       case TIM_DMA_CC4:
;;;3634       {
;;;3635         /* Set the DMA Period elapsed callback */
;;;3636         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3637   
;;;3638         /* Set the DMA error callback */
;;;3639         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3640   
;;;3641         /* Enable the DMA channel */
;;;3642         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3643       }
;;;3644       break;
;;;3645       case TIM_DMA_COM:
;;;3646       {
;;;3647         /* Set the DMA Period elapsed callback */
;;;3648         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3649   
;;;3650         /* Set the DMA error callback */
;;;3651         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3652   
;;;3653         /* Enable the DMA channel */
;;;3654         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3655       }
;;;3656       break;
;;;3657       case TIM_DMA_TRIGGER:
;;;3658       {
;;;3659         /* Set the DMA Period elapsed callback */
;;;3660         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3661   
;;;3662         /* Set the DMA error callback */
;;;3663         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3664   
;;;3665         /* Enable the DMA channel */
;;;3666         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3667       }
;;;3668       break;
;;;3669       default:
;;;3670       break;
;;;3671     }
;;;3672   
;;;3673     /* configure the DMA Burst Mode */
;;;3674     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3675   
;;;3676     /* Enable the TIM DMA Request */
;;;3677     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3678   
;;;3679     htim->State = HAL_TIM_STATE_READY;
;;;3680   
;;;3681     /* Return function status */
;;;3682     return HAL_OK;
;;;3683   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L15.38|
000026  b912              CBNZ     r2,|L15.46|
000028  b10e              CBZ      r6,|L15.46|
00002a  2001              MOVS     r0,#1                 ;3576
00002c  e7f9              B        |L15.34|
                  |L15.46|
00002e  2002              MOVS     r0,#2                 ;3580
000030  f884003d          STRB     r0,[r4,#0x3d]         ;3580
                  |L15.52|
000034  2701              MOVS     r7,#1                 ;3576
000036  483f              LDR      r0,|L15.308|
000038  493f              LDR      r1,|L15.312|
00003a  eb072316          ADD      r3,r7,r6,LSR #8       ;3594
00003e  f5b56f00          CMP      r5,#0x800             ;3583
000042  d039              BEQ      |L15.184|
000044  dc09              BGT      |L15.90|
000046  f5b57f80          CMP      r5,#0x100             ;3583
00004a  d010              BEQ      |L15.110|
00004c  f5b57f00          CMP      r5,#0x200             ;3583
000050  d01a              BEQ      |L15.136|
000052  f5b56f80          CMP      r5,#0x400             ;3583
000056  d160              BNE      |L15.282|
000058  e022              B        |L15.160|
                  |L15.90|
00005a  f5b55f80          CMP      r5,#0x1000            ;3583
00005e  d037              BEQ      |L15.208|
000060  f5b55f00          CMP      r5,#0x2000            ;3583
000064  d040              BEQ      |L15.232|
000066  f5b54f80          CMP      r5,#0x4000            ;3583
00006a  d156              BNE      |L15.282|
00006c  e049              B        |L15.258|
                  |L15.110|
00006e  f8d4c020          LDR      r12,[r4,#0x20]        ;3588
000072  4932              LDR      r1,|L15.316|
000074  f8cc1028          STR      r1,[r12,#0x28]        ;3588
000078  6a21              LDR      r1,[r4,#0x20]         ;3591
00007a  6308              STR      r0,[r1,#0x30]         ;3591
00007c  6821              LDR      r1,[r4,#0]            ;3594
00007e  6a20              LDR      r0,[r4,#0x20]         ;3594
000080  314c              ADDS     r1,r1,#0x4c           ;3594
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  e048              B        |L15.282|
                  |L15.136|
000088  f8d4c024          LDR      r12,[r4,#0x24]        ;3600
00008c  f8cc1028          STR      r1,[r12,#0x28]        ;3600
000090  6a61              LDR      r1,[r4,#0x24]         ;3603
000092  6308              STR      r0,[r1,#0x30]         ;3603
000094  6821              LDR      r1,[r4,#0]            ;3606
000096  6a60              LDR      r0,[r4,#0x24]         ;3606
000098  314c              ADDS     r1,r1,#0x4c           ;3606
00009a  f7fffffe          BL       HAL_DMA_Start_IT
00009e  e03c              B        |L15.282|
                  |L15.160|
0000a0  f8d4c028          LDR      r12,[r4,#0x28]        ;3612
0000a4  f8cc1028          STR      r1,[r12,#0x28]        ;3612
0000a8  6aa1              LDR      r1,[r4,#0x28]         ;3615
0000aa  6308              STR      r0,[r1,#0x30]         ;3615
0000ac  6821              LDR      r1,[r4,#0]            ;3618
0000ae  6aa0              LDR      r0,[r4,#0x28]         ;3618
0000b0  314c              ADDS     r1,r1,#0x4c           ;3618
0000b2  f7fffffe          BL       HAL_DMA_Start_IT
0000b6  e030              B        |L15.282|
                  |L15.184|
0000b8  f8d4c02c          LDR      r12,[r4,#0x2c]        ;3624
0000bc  f8cc1028          STR      r1,[r12,#0x28]        ;3624
0000c0  6ae1              LDR      r1,[r4,#0x2c]         ;3627
0000c2  6308              STR      r0,[r1,#0x30]         ;3627
0000c4  6821              LDR      r1,[r4,#0]            ;3630
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3630
0000c8  314c              ADDS     r1,r1,#0x4c           ;3630
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  e024              B        |L15.282|
                  |L15.208|
0000d0  f8d4c030          LDR      r12,[r4,#0x30]        ;3636
0000d4  f8cc1028          STR      r1,[r12,#0x28]        ;3636
0000d8  6b21              LDR      r1,[r4,#0x30]         ;3639
0000da  6308              STR      r0,[r1,#0x30]         ;3639
0000dc  6821              LDR      r1,[r4,#0]            ;3642
0000de  6b20              LDR      r0,[r4,#0x30]         ;3642
0000e0  314c              ADDS     r1,r1,#0x4c           ;3642
0000e2  f7fffffe          BL       HAL_DMA_Start_IT
0000e6  e018              B        |L15.282|
                  |L15.232|
0000e8  f8d4c034          LDR      r12,[r4,#0x34]        ;3648
0000ec  4914              LDR      r1,|L15.320|
0000ee  f8cc1028          STR      r1,[r12,#0x28]        ;3648
0000f2  6b61              LDR      r1,[r4,#0x34]         ;3651
0000f4  6308              STR      r0,[r1,#0x30]         ;3651
0000f6  6821              LDR      r1,[r4,#0]            ;3654
0000f8  6b60              LDR      r0,[r4,#0x34]         ;3654
0000fa  314c              ADDS     r1,r1,#0x4c           ;3654
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  e00b              B        |L15.282|
                  |L15.258|
000102  f8d4c038          LDR      r12,[r4,#0x38]        ;3660
000106  490f              LDR      r1,|L15.324|
000108  f8cc1028          STR      r1,[r12,#0x28]        ;3660
00010c  6ba1              LDR      r1,[r4,#0x38]         ;3663
00010e  6308              STR      r0,[r1,#0x30]         ;3663
000110  6821              LDR      r1,[r4,#0]            ;3666
000112  6ba0              LDR      r0,[r4,#0x38]         ;3666
000114  314c              ADDS     r1,r1,#0x4c           ;3666
000116  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.282|
00011a  6820              LDR      r0,[r4,#0]            ;3674
00011c  ea480806          ORR      r8,r8,r6              ;3674
000120  f8c08048          STR      r8,[r0,#0x48]         ;3674
000124  6820              LDR      r0,[r4,#0]            ;3677
000126  68c1              LDR      r1,[r0,#0xc]          ;3677
000128  4329              ORRS     r1,r1,r5              ;3677
00012a  60c1              STR      r1,[r0,#0xc]          ;3677
00012c  f884703d          STRB     r7,[r4,#0x3d]         ;3679
000130  2000              MOVS     r0,#0                 ;3682
000132  e776              B        |L15.34|
;;;3684   
                          ENDP

                  |L15.308|
                          DCD      TIM_DMAError
                  |L15.312|
                          DCD      TIM_DMACaptureCplt
                  |L15.316|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.320|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.324|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3690     */
;;;3691   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3692   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3693     /* Check the parameters */
;;;3694     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3695   
;;;3696     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3697     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L16.78|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L16.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d125              BNE      |L16.108|
000020  e011              B        |L16.70|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L16.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L16.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11b              BNE      |L16.108|
000034  e017              B        |L16.102|
                  |L16.54|
;;;3698     {
;;;3699       case TIM_DMA_UPDATE:
;;;3700       {
;;;3701         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3702       }
;;;3703       break;
00003c  e016              B        |L16.108|
                  |L16.62|
;;;3704       case TIM_DMA_CC1:
;;;3705       {
;;;3706         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a60              LDR      r0,[r4,#0x24]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3707       }
;;;3708       break;
000044  e012              B        |L16.108|
                  |L16.70|
;;;3709       case TIM_DMA_CC2:
;;;3710       {
;;;3711         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3712       }
;;;3713       break;
00004c  e00e              B        |L16.108|
                  |L16.78|
;;;3714       case TIM_DMA_CC3:
;;;3715       {
;;;3716         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3717       }
;;;3718       break;
000054  e00a              B        |L16.108|
                  |L16.86|
;;;3719       case TIM_DMA_CC4:
;;;3720       {
;;;3721         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6b20              LDR      r0,[r4,#0x30]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3722       }
;;;3723       break;
00005c  e006              B        |L16.108|
                  |L16.94|
;;;3724       case TIM_DMA_COM:
;;;3725       {
;;;3726         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3727       }
;;;3728       break;
000064  e002              B        |L16.108|
                  |L16.102|
;;;3729       case TIM_DMA_TRIGGER:
;;;3730       {
;;;3731         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6ba0              LDR      r0,[r4,#0x38]
000068  f7fffffe          BL       HAL_DMA_Abort
                  |L16.108|
;;;3732       }
;;;3733       break;
;;;3734       default:
;;;3735       break;
;;;3736     }
;;;3737   
;;;3738     /* Disable the TIM Update DMA request */
;;;3739     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
00006c  6820              LDR      r0,[r4,#0]
00006e  68c1              LDR      r1,[r0,#0xc]
000070  43a9              BICS     r1,r1,r5
000072  60c1              STR      r1,[r0,#0xc]
;;;3740   
;;;3741     /* Return function status */
;;;3742     return HAL_OK;
000074  2000              MOVS     r0,#0
;;;3743   }
000076  bd70              POP      {r4-r6,pc}
;;;3744   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3335     */
;;;3336   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3337                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3338   {
000004  4688              MOV      r8,r1
000006  9e06              LDR      r6,[sp,#0x18]
000008  4604              MOV      r4,r0
00000a  4615              MOV      r5,r2
00000c  4619              MOV      r1,r3
;;;3339     /* Check the parameters */
;;;3340     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3341     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3342     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3343     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3344   
;;;3345     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2802              CMP      r0,#2
000014  d004              BEQ      |L17.32|
;;;3346     {
;;;3347        return HAL_BUSY;
;;;3348     }
;;;3349     else if((htim->State == HAL_TIM_STATE_READY))
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2801              CMP      r0,#1
00001c  d003              BEQ      |L17.38|
00001e  e009              B        |L17.52|
                  |L17.32|
000020  2002              MOVS     r0,#2                 ;3347
                  |L17.34|
;;;3350     {
;;;3351       if((BurstBuffer == 0U) && (BurstLength > 0U))
;;;3352       {
;;;3353         return HAL_ERROR;
;;;3354       }
;;;3355       else
;;;3356       {
;;;3357         htim->State = HAL_TIM_STATE_BUSY;
;;;3358       }
;;;3359     }
;;;3360     switch(BurstRequestSrc)
;;;3361     {
;;;3362       case TIM_DMA_UPDATE:
;;;3363       {
;;;3364         /* Set the DMA Period elapsed callback */
;;;3365         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3366   
;;;3367         /* Set the DMA error callback */
;;;3368         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3369   
;;;3370         /* Enable the DMA channel */
;;;3371         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3372       }
;;;3373       break;
;;;3374       case TIM_DMA_CC1:
;;;3375       {
;;;3376         /* Set the DMA Period elapsed callback */
;;;3377         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3378   
;;;3379         /* Set the DMA error callback */
;;;3380         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3381   
;;;3382         /* Enable the DMA channel */
;;;3383         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3384       }
;;;3385       break;
;;;3386       case TIM_DMA_CC2:
;;;3387       {
;;;3388         /* Set the DMA Period elapsed callback */
;;;3389         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3390   
;;;3391         /* Set the DMA error callback */
;;;3392         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3393   
;;;3394         /* Enable the DMA channel */
;;;3395         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3396       }
;;;3397       break;
;;;3398       case TIM_DMA_CC3:
;;;3399       {
;;;3400         /* Set the DMA Period elapsed callback */
;;;3401         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3402   
;;;3403         /* Set the DMA error callback */
;;;3404         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3405   
;;;3406         /* Enable the DMA channel */
;;;3407         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3408       }
;;;3409       break;
;;;3410       case TIM_DMA_CC4:
;;;3411       {
;;;3412         /* Set the DMA Period elapsed callback */
;;;3413         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3414   
;;;3415         /* Set the DMA error callback */
;;;3416         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3417   
;;;3418         /* Enable the DMA channel */
;;;3419         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3420       }
;;;3421       break;
;;;3422       case TIM_DMA_COM:
;;;3423       {
;;;3424         /* Set the DMA Period elapsed callback */
;;;3425         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3426   
;;;3427         /* Set the DMA error callback */
;;;3428         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3429   
;;;3430         /* Enable the DMA channel */
;;;3431         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3432       }
;;;3433       break;
;;;3434       case TIM_DMA_TRIGGER:
;;;3435       {
;;;3436         /* Set the DMA Period elapsed callback */
;;;3437         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3438   
;;;3439         /* Set the DMA error callback */
;;;3440         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3441   
;;;3442         /* Enable the DMA channel */
;;;3443         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3444       }
;;;3445       break;
;;;3446       default:
;;;3447       break;
;;;3448     }
;;;3449      /* configure the DMA Burst Mode */
;;;3450      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3451   
;;;3452      /* Enable the TIM DMA Request */
;;;3453      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3454   
;;;3455      htim->State = HAL_TIM_STATE_READY;
;;;3456   
;;;3457     /* Return function status */
;;;3458     return HAL_OK;
;;;3459   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L17.38|
000026  b911              CBNZ     r1,|L17.46|
000028  b10e              CBZ      r6,|L17.46|
00002a  2001              MOVS     r0,#1                 ;3353
00002c  e7f9              B        |L17.34|
                  |L17.46|
00002e  2002              MOVS     r0,#2                 ;3357
000030  f884003d          STRB     r0,[r4,#0x3d]         ;3357
                  |L17.52|
000034  2701              MOVS     r7,#1                 ;3353
000036  483f              LDR      r0,|L17.308|
000038  4a3f              LDR      r2,|L17.312|
00003a  eb072316          ADD      r3,r7,r6,LSR #8       ;3371
00003e  f5b56f00          CMP      r5,#0x800             ;3360
000042  d039              BEQ      |L17.184|
000044  dc09              BGT      |L17.90|
000046  f5b57f80          CMP      r5,#0x100             ;3360
00004a  d010              BEQ      |L17.110|
00004c  f5b57f00          CMP      r5,#0x200             ;3360
000050  d01a              BEQ      |L17.136|
000052  f5b56f80          CMP      r5,#0x400             ;3360
000056  d160              BNE      |L17.282|
000058  e022              B        |L17.160|
                  |L17.90|
00005a  f5b55f80          CMP      r5,#0x1000            ;3360
00005e  d037              BEQ      |L17.208|
000060  f5b55f00          CMP      r5,#0x2000            ;3360
000064  d040              BEQ      |L17.232|
000066  f5b54f80          CMP      r5,#0x4000            ;3360
00006a  d156              BNE      |L17.282|
00006c  e049              B        |L17.258|
                  |L17.110|
00006e  f8d4c020          LDR      r12,[r4,#0x20]        ;3365
000072  4a32              LDR      r2,|L17.316|
000074  f8cc2028          STR      r2,[r12,#0x28]        ;3365
000078  6a22              LDR      r2,[r4,#0x20]         ;3368
00007a  6310              STR      r0,[r2,#0x30]         ;3368
00007c  6822              LDR      r2,[r4,#0]            ;3371
00007e  6a20              LDR      r0,[r4,#0x20]         ;3371
000080  324c              ADDS     r2,r2,#0x4c           ;3371
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  e048              B        |L17.282|
                  |L17.136|
000088  f8d4c024          LDR      r12,[r4,#0x24]        ;3377
00008c  f8cc2028          STR      r2,[r12,#0x28]        ;3377
000090  6a62              LDR      r2,[r4,#0x24]         ;3380
000092  6310              STR      r0,[r2,#0x30]         ;3380
000094  6822              LDR      r2,[r4,#0]            ;3383
000096  6a60              LDR      r0,[r4,#0x24]         ;3383
000098  324c              ADDS     r2,r2,#0x4c           ;3383
00009a  f7fffffe          BL       HAL_DMA_Start_IT
00009e  e03c              B        |L17.282|
                  |L17.160|
0000a0  f8d4c028          LDR      r12,[r4,#0x28]        ;3389
0000a4  f8cc2028          STR      r2,[r12,#0x28]        ;3389
0000a8  6aa2              LDR      r2,[r4,#0x28]         ;3392
0000aa  6310              STR      r0,[r2,#0x30]         ;3392
0000ac  6822              LDR      r2,[r4,#0]            ;3395
0000ae  6aa0              LDR      r0,[r4,#0x28]         ;3395
0000b0  324c              ADDS     r2,r2,#0x4c           ;3395
0000b2  f7fffffe          BL       HAL_DMA_Start_IT
0000b6  e030              B        |L17.282|
                  |L17.184|
0000b8  f8d4c02c          LDR      r12,[r4,#0x2c]        ;3401
0000bc  f8cc2028          STR      r2,[r12,#0x28]        ;3401
0000c0  6ae2              LDR      r2,[r4,#0x2c]         ;3404
0000c2  6310              STR      r0,[r2,#0x30]         ;3404
0000c4  6822              LDR      r2,[r4,#0]            ;3407
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3407
0000c8  324c              ADDS     r2,r2,#0x4c           ;3407
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  e024              B        |L17.282|
                  |L17.208|
0000d0  f8d4c030          LDR      r12,[r4,#0x30]        ;3413
0000d4  f8cc2028          STR      r2,[r12,#0x28]        ;3413
0000d8  6b22              LDR      r2,[r4,#0x30]         ;3416
0000da  6310              STR      r0,[r2,#0x30]         ;3416
0000dc  6822              LDR      r2,[r4,#0]            ;3419
0000de  6b20              LDR      r0,[r4,#0x30]         ;3419
0000e0  324c              ADDS     r2,r2,#0x4c           ;3419
0000e2  f7fffffe          BL       HAL_DMA_Start_IT
0000e6  e018              B        |L17.282|
                  |L17.232|
0000e8  f8d4c034          LDR      r12,[r4,#0x34]        ;3425
0000ec  4a14              LDR      r2,|L17.320|
0000ee  f8cc2028          STR      r2,[r12,#0x28]        ;3425
0000f2  6b62              LDR      r2,[r4,#0x34]         ;3428
0000f4  6310              STR      r0,[r2,#0x30]         ;3428
0000f6  6822              LDR      r2,[r4,#0]            ;3431
0000f8  6b60              LDR      r0,[r4,#0x34]         ;3431
0000fa  324c              ADDS     r2,r2,#0x4c           ;3431
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  e00b              B        |L17.282|
                  |L17.258|
000102  f8d4c038          LDR      r12,[r4,#0x38]        ;3437
000106  4a0f              LDR      r2,|L17.324|
000108  f8cc2028          STR      r2,[r12,#0x28]        ;3437
00010c  6ba2              LDR      r2,[r4,#0x38]         ;3440
00010e  6310              STR      r0,[r2,#0x30]         ;3440
000110  6822              LDR      r2,[r4,#0]            ;3443
000112  6ba0              LDR      r0,[r4,#0x38]         ;3443
000114  324c              ADDS     r2,r2,#0x4c           ;3443
000116  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.282|
00011a  6820              LDR      r0,[r4,#0]            ;3450
00011c  ea480806          ORR      r8,r8,r6              ;3450
000120  f8c08048          STR      r8,[r0,#0x48]         ;3450
000124  6820              LDR      r0,[r4,#0]            ;3453
000126  68c1              LDR      r1,[r0,#0xc]          ;3453
000128  4329              ORRS     r1,r1,r5              ;3453
00012a  60c1              STR      r1,[r0,#0xc]          ;3453
00012c  f884703d          STRB     r7,[r4,#0x3d]         ;3455
000130  2000              MOVS     r0,#0                 ;3458
000132  e776              B        |L17.34|
;;;3460   
                          ENDP

                  |L17.308|
                          DCD      TIM_DMAError
                  |L17.312|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.316|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.320|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.324|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3466     */
;;;3467   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3468   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3469     /* Check the parameters */
;;;3470     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3471   
;;;3472     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3473     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L18.78|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L18.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d125              BNE      |L18.108|
000020  e011              B        |L18.70|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L18.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L18.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11b              BNE      |L18.108|
000034  e017              B        |L18.102|
                  |L18.54|
;;;3474     {
;;;3475       case TIM_DMA_UPDATE:
;;;3476       {
;;;3477         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3478       }
;;;3479       break;
00003c  e016              B        |L18.108|
                  |L18.62|
;;;3480       case TIM_DMA_CC1:
;;;3481       {
;;;3482         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a60              LDR      r0,[r4,#0x24]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3483       }
;;;3484       break;
000044  e012              B        |L18.108|
                  |L18.70|
;;;3485       case TIM_DMA_CC2:
;;;3486       {
;;;3487         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3488       }
;;;3489       break;
00004c  e00e              B        |L18.108|
                  |L18.78|
;;;3490       case TIM_DMA_CC3:
;;;3491       {
;;;3492         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3493       }
;;;3494       break;
000054  e00a              B        |L18.108|
                  |L18.86|
;;;3495       case TIM_DMA_CC4:
;;;3496       {
;;;3497         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6b20              LDR      r0,[r4,#0x30]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3498       }
;;;3499       break;
00005c  e006              B        |L18.108|
                  |L18.94|
;;;3500       case TIM_DMA_COM:
;;;3501       {
;;;3502         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3503       }
;;;3504       break;
000064  e002              B        |L18.108|
                  |L18.102|
;;;3505       case TIM_DMA_TRIGGER:
;;;3506       {
;;;3507         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6ba0              LDR      r0,[r4,#0x38]
000068  f7fffffe          BL       HAL_DMA_Abort
                  |L18.108|
;;;3508       }
;;;3509       break;
;;;3510       default:
;;;3511       break;
;;;3512     }
;;;3513   
;;;3514     /* Disable the TIM Update DMA request */
;;;3515     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
00006c  6820              LDR      r0,[r4,#0]
00006e  68c1              LDR      r1,[r0,#0xc]
000070  43a9              BICS     r1,r1,r5
000072  60c1              STR      r1,[r0,#0xc]
;;;3516   
;;;3517     /* Return function status */
;;;3518     return HAL_OK;
000074  2000              MOVS     r0,#0
;;;3519   }
000076  bd70              POP      {r4-r6,pc}
;;;3520   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2344     */
;;;2345   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2346   {
000002  4604              MOV      r4,r0
;;;2347     /* Check the parameters */
;;;2348     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2349   
;;;2350     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2351   
;;;2352     /* Disable the TIM Peripheral Clock */
;;;2353     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L19.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L19.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L19.38|
;;;2354   
;;;2355     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2356     HAL_TIM_Encoder_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2357   
;;;2358     /* Change TIM state */
;;;2359     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;2360   
;;;2361     /* Release Lock */
;;;2362     __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;2363   
;;;2364     return HAL_OK;
;;;2365   }
000034  bd10              POP      {r4,pc}
;;;2366   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4438     */
;;;4439   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4440   {
;;;4441     return htim->State;
;;;4442   }
000004  4770              BX       lr
;;;4443   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2251     */
;;;2252   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2253   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2254     uint32_t tmpsmcr = 0U;
;;;2255     uint32_t tmpccmr1 = 0U;
;;;2256     uint32_t tmpccer = 0U;
;;;2257   
;;;2258     /* Check the TIM handle allocation */
;;;2259     if(htim == NULL)
000008  2c00              CMP      r4,#0
00000a  d003              BEQ      |L21.20|
;;;2260     {
;;;2261       return HAL_ERROR;
;;;2262     }
;;;2263   
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2266     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2267     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2268     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2269     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2270     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2271     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2272     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2273     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2274     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2275     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2276     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2277     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2278   
;;;2279     if(htim->State == HAL_TIM_STATE_RESET)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  b118              CBZ      r0,|L21.26|
000012  e008              B        |L21.38|
                  |L21.20|
000014  2001              MOVS     r0,#1                 ;2261
                  |L21.22|
;;;2280     {
;;;2281       /* Allocate lock resource and initialize it */
;;;2282       htim->Lock = HAL_UNLOCKED;
;;;2283       
;;;2284       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2285       HAL_TIM_Encoder_MspInit(htim);
;;;2286     }
;;;2287   
;;;2288     /* Set the TIM state */
;;;2289     htim->State= HAL_TIM_STATE_BUSY;
;;;2290   
;;;2291     /* Reset the SMS bits */
;;;2292     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2293   
;;;2294     /* Configure the Time base in the Encoder Mode */
;;;2295     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2296   
;;;2297     /* Get the TIMx SMCR register value */
;;;2298     tmpsmcr = htim->Instance->SMCR;
;;;2299   
;;;2300     /* Get the TIMx CCMR1 register value */
;;;2301     tmpccmr1 = htim->Instance->CCMR1;
;;;2302   
;;;2303     /* Get the TIMx CCER register value */
;;;2304     tmpccer = htim->Instance->CCER;
;;;2305   
;;;2306     /* Set the encoder Mode */
;;;2307     tmpsmcr |= sConfig->EncoderMode;
;;;2308   
;;;2309     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2310     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2311     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2312   
;;;2313     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2314     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2315     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2316     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2317     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2318   
;;;2319     /* Set the TI1 and the TI2 Polarities */
;;;2320     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2321     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2322     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2323   
;;;2324     /* Write to TIMx SMCR */
;;;2325     htim->Instance->SMCR = tmpsmcr;
;;;2326   
;;;2327     /* Write to TIMx CCMR1 */
;;;2328     htim->Instance->CCMR1 = tmpccmr1;
;;;2329   
;;;2330     /* Write to TIMx CCER */
;;;2331     htim->Instance->CCER = tmpccer;
;;;2332   
;;;2333     /* Initialize the TIM state*/
;;;2334     htim->State= HAL_TIM_STATE_READY;
;;;2335   
;;;2336     return HAL_OK;
;;;2337   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L21.26|
00001a  2000              MOVS     r0,#0                 ;2282
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;2282
000020  4620              MOV      r0,r4                 ;2285
000022  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.38|
000026  2002              MOVS     r0,#2                 ;2289
000028  f884003d          STRB     r0,[r4,#0x3d]         ;2289
00002c  6820              LDR      r0,[r4,#0]            ;2292
00002e  6881              LDR      r1,[r0,#8]            ;2292
000030  f0210107          BIC      r1,r1,#7              ;2292
000034  6081              STR      r1,[r0,#8]            ;2292
000036  1d21              ADDS     r1,r4,#4              ;2295
000038  6820              LDR      r0,[r4,#0]            ;2295
00003a  f7fffffe          BL       TIM_Base_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;2298
000040  6881              LDR      r1,[r0,#8]            ;2298
000042  6982              LDR      r2,[r0,#0x18]         ;2301
000044  6a06              LDR      r6,[r0,#0x20]         ;2304
000046  682b              LDR      r3,[r5,#0]            ;2307
000048  430b              ORRS     r3,r3,r1              ;2307
00004a  f2403103          MOV      r1,#0x303             ;2310
00004e  438a              BICS     r2,r2,r1              ;2310
000050  69af              LDR      r7,[r5,#0x18]         ;2311
000052  68a9              LDR      r1,[r5,#8]            ;2311
000054  ea422207          ORR      r2,r2,r7,LSL #8       ;2311
000058  4311              ORRS     r1,r1,r2              ;2311
00005a  f640420c          MOV      r2,#0xc0c             ;2314
00005e  4391              BICS     r1,r1,r2              ;2314
000060  f24f02f0          MOV      r2,#0xf0f0            ;2315
000064  4391              BICS     r1,r1,r2              ;2315
000066  69ef              LDR      r7,[r5,#0x1c]         ;2316
000068  68ea              LDR      r2,[r5,#0xc]          ;2316
00006a  ea412107          ORR      r1,r1,r7,LSL #8       ;2316
00006e  430a              ORRS     r2,r2,r1              ;2316
000070  6929              LDR      r1,[r5,#0x10]         ;2317
000072  6a2f              LDR      r7,[r5,#0x20]         ;2317
000074  0109              LSLS     r1,r1,#4              ;2317
000076  ea413107          ORR      r1,r1,r7,LSL #12      ;2317
00007a  4311              ORRS     r1,r1,r2              ;2317
00007c  f0260222          BIC      r2,r6,#0x22           ;2320
000080  f0220688          BIC      r6,r2,#0x88           ;2321
000084  686a              LDR      r2,[r5,#4]            ;2322
000086  696d              LDR      r5,[r5,#0x14]         ;2322
000088  ea461505          ORR      r5,r6,r5,LSL #4       ;2322
00008c  432a              ORRS     r2,r2,r5              ;2322
00008e  6083              STR      r3,[r0,#8]            ;2325
000090  6820              LDR      r0,[r4,#0]            ;2328
000092  6181              STR      r1,[r0,#0x18]         ;2328
000094  6820              LDR      r0,[r4,#0]            ;2331
000096  6202              STR      r2,[r0,#0x20]         ;2331
000098  2001              MOVS     r0,#1                 ;2334
00009a  f884003d          STRB     r0,[r4,#0x3d]         ;2334
00009e  2000              MOVS     r0,#0                 ;2336
0000a0  e7b9              B        |L21.22|
;;;2338   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2385     */
;;;2386   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2387   {
;;;2388     /* Prevent unused argument(s) compilation warning */
;;;2389     UNUSED(htim);
;;;2390     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2391               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2392      */
;;;2393   }
;;;2394   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2371     */
;;;2372   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2373   {
;;;2374     /* Prevent unused argument(s) compilation warning */
;;;2375     UNUSED(htim);
;;;2376     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2377               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2378      */
;;;2379   }
;;;2380   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2404   */
;;;2405   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2406   {
000002  4604              MOV      r4,r0
;;;2407     /* Check the parameters */
;;;2408     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2409   
;;;2410     /* Enable the encoder interface channels */
;;;2411     switch (Channel)
000004  2900              CMP      r1,#0
;;;2412     {
;;;2413       case TIM_CHANNEL_1:
;;;2414     {
;;;2415       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000006  6820              LDR      r0,[r4,#0]
000008  d011              BEQ      |L24.46|
00000a  2904              CMP      r1,#4                 ;2411
00000c  d014              BEQ      |L24.56|
;;;2416         break;
;;;2417     }
;;;2418       case TIM_CHANNEL_2:
;;;2419     {
;;;2420       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2421         break;
;;;2422     }
;;;2423       default :
;;;2424     {
;;;2425        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2426        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000016  2201              MOVS     r2,#1
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
                  |L24.32|
;;;2427        break;
;;;2428       }
;;;2429     }
;;;2430     /* Enable the Peripheral */
;;;2431     __HAL_TIM_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0410101          ORR      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
;;;2432   
;;;2433     /* Return function status */
;;;2434     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2435   }
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  2201              MOVS     r2,#1                 ;2415
000030  2100              MOVS     r1,#0                 ;2415
000032  f7fffffe          BL       TIM_CCxChannelCmd
000036  e7f3              B        |L24.32|
                  |L24.56|
000038  2201              MOVS     r2,#1                 ;2420
00003a  2104              MOVS     r1,#4                 ;2420
00003c  f7fffffe          BL       TIM_CCxChannelCmd
000040  e7ee              B        |L24.32|
;;;2436   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2592   */
;;;2593   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2594   {
000004  4604              MOV      r4,r0
000006  9d06              LDR      r5,[sp,#0x18]
000008  461e              MOV      r6,r3
;;;2595     /* Check the parameters */
;;;2596     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2597   
;;;2598     if((htim->State == HAL_TIM_STATE_BUSY))
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2802              CMP      r0,#2
000010  d004              BEQ      |L25.28|
;;;2599     {
;;;2600        return HAL_BUSY;
;;;2601     }
;;;2602     else if((htim->State == HAL_TIM_STATE_READY))
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2801              CMP      r0,#1
000018  d003              BEQ      |L25.34|
00001a  e00a              B        |L25.50|
                  |L25.28|
00001c  2002              MOVS     r0,#2                 ;2600
                  |L25.30|
;;;2603     {
;;;2604       if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
;;;2605       {
;;;2606         return HAL_ERROR;
;;;2607       }
;;;2608       else
;;;2609       {
;;;2610         htim->State = HAL_TIM_STATE_BUSY;
;;;2611       }
;;;2612     }
;;;2613   
;;;2614     switch (Channel)
;;;2615     {
;;;2616       case TIM_CHANNEL_1:
;;;2617       {
;;;2618         /* Set the DMA Period elapsed callback */
;;;2619         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2620   
;;;2621         /* Set the DMA error callback */
;;;2622         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2623   
;;;2624         /* Enable the DMA channel */
;;;2625         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2626   
;;;2627         /* Enable the TIM Input Capture DMA request */
;;;2628         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2629   
;;;2630         /* Enable the Peripheral */
;;;2631         __HAL_TIM_ENABLE(htim);
;;;2632   
;;;2633         /* Enable the Capture compare channel */
;;;2634         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2635       }
;;;2636       break;
;;;2637   
;;;2638       case TIM_CHANNEL_2:
;;;2639       {
;;;2640         /* Set the DMA Period elapsed callback */
;;;2641         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2642   
;;;2643         /* Set the DMA error callback */
;;;2644         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2645         /* Enable the DMA channel */
;;;2646         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2647   
;;;2648         /* Enable the TIM Input Capture  DMA request */
;;;2649         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2650   
;;;2651         /* Enable the Peripheral */
;;;2652         __HAL_TIM_ENABLE(htim);
;;;2653   
;;;2654         /* Enable the Capture compare channel */
;;;2655         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2656       }
;;;2657       break;
;;;2658   
;;;2659       case TIM_CHANNEL_ALL:
;;;2660       {
;;;2661         /* Set the DMA Period elapsed callback */
;;;2662         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2663   
;;;2664         /* Set the DMA error callback */
;;;2665         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2666   
;;;2667         /* Enable the DMA channel */
;;;2668         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2669   
;;;2670         /* Set the DMA Period elapsed callback */
;;;2671         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2672   
;;;2673         /* Set the DMA error callback */
;;;2674         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2675   
;;;2676         /* Enable the DMA channel */
;;;2677         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2678   
;;;2679        /* Enable the Peripheral */
;;;2680         __HAL_TIM_ENABLE(htim);
;;;2681   
;;;2682         /* Enable the Capture compare channel */
;;;2683         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2684         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2685   
;;;2686         /* Enable the TIM Input Capture  DMA request */
;;;2687         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2688         /* Enable the TIM Input Capture  DMA request */
;;;2689         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2690       }
;;;2691       break;
;;;2692   
;;;2693       default:
;;;2694       break;
;;;2695     }
;;;2696     /* Return function status */
;;;2697     return HAL_OK;
;;;2698   }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L25.34|
000022  b102              CBZ      r2,|L25.38|
000024  b916              CBNZ     r6,|L25.44|
                  |L25.38|
000026  b10d              CBZ      r5,|L25.44|
000028  2001              MOVS     r0,#1                 ;2606
00002a  e7f8              B        |L25.30|
                  |L25.44|
00002c  2002              MOVS     r0,#2                 ;2610
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;2610
                  |L25.50|
000032  4f39              LDR      r7,|L25.280|
000034  f8df80e4          LDR      r8,|L25.284|
000038  b121              CBZ      r1,|L25.68|
00003a  2904              CMP      r1,#4                 ;2614
00003c  d01d              BEQ      |L25.122|
00003e  2918              CMP      r1,#0x18              ;2614
000040  d167              BNE      |L25.274|
000042  e036              B        |L25.178|
                  |L25.68|
000044  6a60              LDR      r0,[r4,#0x24]         ;2619
000046  6287              STR      r7,[r0,#0x28]         ;2619
000048  6a60              LDR      r0,[r4,#0x24]         ;2622
00004a  f8c08030          STR      r8,[r0,#0x30]         ;2622
00004e  6821              LDR      r1,[r4,#0]            ;2625
000050  462b              MOV      r3,r5                 ;2625
000052  3134              ADDS     r1,r1,#0x34           ;2625
000054  6a60              LDR      r0,[r4,#0x24]         ;2625
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;2628
00005c  68c1              LDR      r1,[r0,#0xc]          ;2628
00005e  f4417100          ORR      r1,r1,#0x200          ;2628
000062  60c1              STR      r1,[r0,#0xc]          ;2628
000064  6820              LDR      r0,[r4,#0]            ;2631
000066  6801              LDR      r1,[r0,#0]            ;2631
000068  f0410101          ORR      r1,r1,#1              ;2631
00006c  6001              STR      r1,[r0,#0]            ;2631
00006e  2201              MOVS     r2,#1                 ;2634
000070  2100              MOVS     r1,#0                 ;2634
000072  6820              LDR      r0,[r4,#0]            ;2634
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  e04b              B        |L25.274|
                  |L25.122|
00007a  6aa0              LDR      r0,[r4,#0x28]         ;2641
00007c  6287              STR      r7,[r0,#0x28]         ;2641
00007e  6aa0              LDR      r0,[r4,#0x28]         ;2644
000080  f8c08030          STR      r8,[r0,#0x30]         ;2644
000084  6821              LDR      r1,[r4,#0]            ;2646
000086  462b              MOV      r3,r5                 ;2646
000088  3138              ADDS     r1,r1,#0x38           ;2646
00008a  4632              MOV      r2,r6                 ;2646
00008c  6aa0              LDR      r0,[r4,#0x28]         ;2646
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;2649
000094  68c1              LDR      r1,[r0,#0xc]          ;2649
000096  f4416180          ORR      r1,r1,#0x400          ;2649
00009a  60c1              STR      r1,[r0,#0xc]          ;2649
00009c  6820              LDR      r0,[r4,#0]            ;2652
00009e  6801              LDR      r1,[r0,#0]            ;2652
0000a0  f0410101          ORR      r1,r1,#1              ;2652
0000a4  6001              STR      r1,[r0,#0]            ;2652
0000a6  2201              MOVS     r2,#1                 ;2655
0000a8  2104              MOVS     r1,#4                 ;2655
0000aa  6820              LDR      r0,[r4,#0]            ;2655
0000ac  f7fffffe          BL       TIM_CCxChannelCmd
0000b0  e02f              B        |L25.274|
                  |L25.178|
0000b2  6a60              LDR      r0,[r4,#0x24]         ;2662
0000b4  6287              STR      r7,[r0,#0x28]         ;2662
0000b6  6a60              LDR      r0,[r4,#0x24]         ;2665
0000b8  f8c08030          STR      r8,[r0,#0x30]         ;2665
0000bc  6821              LDR      r1,[r4,#0]            ;2668
0000be  462b              MOV      r3,r5                 ;2668
0000c0  3134              ADDS     r1,r1,#0x34           ;2668
0000c2  6a60              LDR      r0,[r4,#0x24]         ;2668
0000c4  f7fffffe          BL       HAL_DMA_Start_IT
0000c8  6aa0              LDR      r0,[r4,#0x28]         ;2671
0000ca  6287              STR      r7,[r0,#0x28]         ;2671
0000cc  6aa0              LDR      r0,[r4,#0x28]         ;2674
0000ce  f8c08030          STR      r8,[r0,#0x30]         ;2674
0000d2  6821              LDR      r1,[r4,#0]            ;2677
0000d4  462b              MOV      r3,r5                 ;2677
0000d6  3138              ADDS     r1,r1,#0x38           ;2677
0000d8  4632              MOV      r2,r6                 ;2677
0000da  6aa0              LDR      r0,[r4,#0x28]         ;2677
0000dc  f7fffffe          BL       HAL_DMA_Start_IT
0000e0  6820              LDR      r0,[r4,#0]            ;2680
0000e2  6801              LDR      r1,[r0,#0]            ;2680
0000e4  f0410101          ORR      r1,r1,#1              ;2680
0000e8  6001              STR      r1,[r0,#0]            ;2680
0000ea  2201              MOVS     r2,#1                 ;2683
0000ec  2100              MOVS     r1,#0                 ;2683
0000ee  6820              LDR      r0,[r4,#0]            ;2683
0000f0  f7fffffe          BL       TIM_CCxChannelCmd
0000f4  2201              MOVS     r2,#1                 ;2684
0000f6  2104              MOVS     r1,#4                 ;2684
0000f8  6820              LDR      r0,[r4,#0]            ;2684
0000fa  f7fffffe          BL       TIM_CCxChannelCmd
0000fe  6820              LDR      r0,[r4,#0]            ;2687
000100  68c1              LDR      r1,[r0,#0xc]          ;2687
000102  f4417100          ORR      r1,r1,#0x200          ;2687
000106  60c1              STR      r1,[r0,#0xc]          ;2687
000108  6820              LDR      r0,[r4,#0]            ;2689
00010a  68c1              LDR      r1,[r0,#0xc]          ;2689
00010c  f4416180          ORR      r1,r1,#0x400          ;2689
000110  60c1              STR      r1,[r0,#0xc]          ;2689
                  |L25.274|
000112  2000              MOVS     r0,#0                 ;2697
000114  e783              B        |L25.30|
;;;2699   
                          ENDP

000116  0000              DCW      0x0000
                  |L25.280|
                          DCD      TIM_DMACaptureCplt
                  |L25.284|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2490   */
;;;2491   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2492   {
000002  4604              MOV      r4,r0
;;;2493     /* Check the parameters */
;;;2494     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2495   
;;;2496     /* Enable the encoder interface channels */
;;;2497     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2498     switch (Channel)
000004  2900              CMP      r1,#0
;;;2499     {
;;;2500       case TIM_CHANNEL_1:
;;;2501     {
;;;2502       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000006  6820              LDR      r0,[r4,#0]
000008  d01b              BEQ      |L26.66|
00000a  2904              CMP      r1,#4                 ;2498
00000c  d023              BEQ      |L26.86|
;;;2503       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2504         break;
;;;2505     }
;;;2506       case TIM_CHANNEL_2:
;;;2507     {
;;;2508       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2509       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2510         break;
;;;2511     }
;;;2512       default :
;;;2513     {
;;;2514        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2515        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000016  2201              MOVS     r2,#1
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2516        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0410102          ORR      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
;;;2517        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f0410104          ORR      r1,r1,#4
000032  60c1              STR      r1,[r0,#0xc]
                  |L26.52|
;;;2518        break;
;;;2519       }
;;;2520     }
;;;2521   
;;;2522     /* Enable the Peripheral */
;;;2523     __HAL_TIM_ENABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6801              LDR      r1,[r0,#0]
000038  f0410101          ORR      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
;;;2524   
;;;2525     /* Return function status */
;;;2526     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2527   }
000040  bd10              POP      {r4,pc}
                  |L26.66|
000042  2201              MOVS     r2,#1                 ;2502
000044  2100              MOVS     r1,#0                 ;2502
000046  f7fffffe          BL       TIM_CCxChannelCmd
00004a  6820              LDR      r0,[r4,#0]            ;2503
00004c  68c1              LDR      r1,[r0,#0xc]          ;2503
00004e  f0410102          ORR      r1,r1,#2              ;2503
000052  60c1              STR      r1,[r0,#0xc]          ;2503
000054  e7ee              B        |L26.52|
                  |L26.86|
000056  2201              MOVS     r2,#1                 ;2508
000058  2104              MOVS     r1,#4                 ;2508
00005a  f7fffffe          BL       TIM_CCxChannelCmd
00005e  6820              LDR      r0,[r4,#0]            ;2509
000060  68c1              LDR      r1,[r0,#0xc]          ;2509
000062  f0410104          ORR      r1,r1,#4              ;2509
000066  60c1              STR      r1,[r0,#0xc]          ;2509
000068  e7e4              B        |L26.52|
;;;2528   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2446   */
;;;2447   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2448   {
000002  4604              MOV      r4,r0
;;;2449     /* Check the parameters */
;;;2450       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2451   
;;;2452      /* Disable the Input Capture channels 1 and 2
;;;2453       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2454     switch (Channel)
000004  2900              CMP      r1,#0
;;;2455     {
;;;2456       case TIM_CHANNEL_1:
;;;2457     {
;;;2458        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  6820              LDR      r0,[r4,#0]
000008  d01a              BEQ      |L27.64|
00000a  2904              CMP      r1,#4                 ;2454
00000c  d01d              BEQ      |L27.74|
;;;2459         break;
;;;2460     }
;;;2461       case TIM_CHANNEL_2:
;;;2462     {
;;;2463       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2464         break;
;;;2465     }
;;;2466       default :
;;;2467     {
;;;2468       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2469       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
                  |L27.32|
;;;2470        break;
;;;2471       }
;;;2472     }
;;;2473   
;;;2474     /* Disable the Peripheral */
;;;2475     __HAL_TIM_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a01              LDR      r1,[r0,#0x20]
000024  f2411211          MOV      r2,#0x1111
000028  4211              TST      r1,r2
00002a  d107              BNE      |L27.60|
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  1092              ASRS     r2,r2,#2
000030  4211              TST      r1,r2
000032  d103              BNE      |L27.60|
000034  6801              LDR      r1,[r0,#0]
000036  f0210101          BIC      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L27.60|
;;;2476   
;;;2477     /* Return function status */
;;;2478     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2479   }
00003e  bd10              POP      {r4,pc}
                  |L27.64|
000040  2200              MOVS     r2,#0                 ;2458
000042  4611              MOV      r1,r2                 ;2458
000044  f7fffffe          BL       TIM_CCxChannelCmd
000048  e7ea              B        |L27.32|
                  |L27.74|
00004a  2200              MOVS     r2,#0                 ;2463
00004c  2104              MOVS     r1,#4                 ;2463
00004e  f7fffffe          BL       TIM_CCxChannelCmd
000052  e7e5              B        |L27.32|
;;;2480   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2709   */
;;;2710   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2711   {
000002  4604              MOV      r4,r0
;;;2712     /* Check the parameters */
;;;2713     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2714   
;;;2715     /* Disable the Input Capture channels 1 and 2
;;;2716       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2717     if(Channel == TIM_CHANNEL_1)
000004  2900              CMP      r1,#0
;;;2718     {
;;;2719       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  6820              LDR      r0,[r4,#0]
000008  d027              BEQ      |L28.90|
;;;2720   
;;;2721       /* Disable the capture compare DMA Request 1 */
;;;2722       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2723     }
;;;2724     else if(Channel == TIM_CHANNEL_2)
00000a  2904              CMP      r1,#4
00000c  d02f              BEQ      |L28.110|
;;;2725     {
;;;2726       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2727   
;;;2728       /* Disable the capture compare DMA Request 2 */
;;;2729       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2730     }
;;;2731     else
;;;2732     {
;;;2733       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2734       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2735   
;;;2736       /* Disable the capture compare DMA Request 1 and 2 */
;;;2737       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f4217100          BIC      r1,r1,#0x200
000028  60c1              STR      r1,[r0,#0xc]
;;;2738       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f4216180          BIC      r1,r1,#0x400
000032  60c1              STR      r1,[r0,#0xc]
                  |L28.52|
;;;2739     }
;;;2740   
;;;2741     /* Disable the Peripheral */
;;;2742     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L28.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L28.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L28.80|
;;;2743   
;;;2744     /* Change the htim state */
;;;2745     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f884003d          STRB     r0,[r4,#0x3d]
;;;2746   
;;;2747     /* Return function status */
;;;2748     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2749   }
000058  bd10              POP      {r4,pc}
                  |L28.90|
00005a  2200              MOVS     r2,#0                 ;2719
00005c  4611              MOV      r1,r2                 ;2719
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2722
000064  68c1              LDR      r1,[r0,#0xc]          ;2722
000066  f4217100          BIC      r1,r1,#0x200          ;2722
00006a  60c1              STR      r1,[r0,#0xc]          ;2722
00006c  e7e2              B        |L28.52|
                  |L28.110|
00006e  2200              MOVS     r2,#0                 ;2726
000070  2104              MOVS     r1,#4                 ;2726
000072  f7fffffe          BL       TIM_CCxChannelCmd
000076  6820              LDR      r0,[r4,#0]            ;2729
000078  68c1              LDR      r1,[r0,#0xc]          ;2729
00007a  f4216180          BIC      r1,r1,#0x400          ;2729
00007e  60c1              STR      r1,[r0,#0xc]          ;2729
000080  e7d8              B        |L28.52|
;;;2750   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2538   */
;;;2539   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2540   {
000002  4604              MOV      r4,r0
;;;2541     /* Check the parameters */
;;;2542     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2543   
;;;2544     /* Disable the Input Capture channels 1 and 2
;;;2545       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2546     if(Channel == TIM_CHANNEL_1)
000004  2900              CMP      r1,#0
;;;2547     {
;;;2548       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  6820              LDR      r0,[r4,#0]
000008  d027              BEQ      |L29.90|
;;;2549   
;;;2550       /* Disable the capture compare Interrupts 1 */
;;;2551     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2552     }
;;;2553     else if(Channel == TIM_CHANNEL_2)
00000a  2904              CMP      r1,#4
00000c  d02f              BEQ      |L29.110|
;;;2554     {
;;;2555       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2556   
;;;2557       /* Disable the capture compare Interrupts 2 */
;;;2558     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2559     }
;;;2560     else
;;;2561     {
;;;2562       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2563       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2564   
;;;2565       /* Disable the capture compare Interrupts 1 and 2 */
;;;2566       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0210102          BIC      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
;;;2567       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f0210104          BIC      r1,r1,#4
000032  60c1              STR      r1,[r0,#0xc]
                  |L29.52|
;;;2568     }
;;;2569   
;;;2570     /* Disable the Peripheral */
;;;2571     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L29.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L29.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L29.80|
;;;2572   
;;;2573     /* Change the htim state */
;;;2574     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f884003d          STRB     r0,[r4,#0x3d]
;;;2575   
;;;2576     /* Return function status */
;;;2577     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2578   }
000058  bd10              POP      {r4,pc}
                  |L29.90|
00005a  2200              MOVS     r2,#0                 ;2548
00005c  4611              MOV      r1,r2                 ;2548
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2551
000064  68c1              LDR      r1,[r0,#0xc]          ;2551
000066  f0210102          BIC      r1,r1,#2              ;2551
00006a  60c1              STR      r1,[r0,#0xc]          ;2551
00006c  e7e2              B        |L29.52|
                  |L29.110|
00006e  2200              MOVS     r2,#0                 ;2555
000070  2104              MOVS     r1,#4                 ;2555
000072  f7fffffe          BL       TIM_CCxChannelCmd
000076  6820              LDR      r0,[r4,#0]            ;2558
000078  68c1              LDR      r1,[r0,#0xc]          ;2558
00007a  f0210104          BIC      r1,r1,#4              ;2558
00007e  60c1              STR      r1,[r0,#0xc]          ;2558
000080  e7d8              B        |L29.52|
;;;2579   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4355     */
;;;4356   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4357   {
;;;4358     /* Prevent unused argument(s) compilation warning */
;;;4359     UNUSED(htim);
;;;4360     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4361               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4362      */
;;;4363   }
;;;4364   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3762   
;;;3763   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  f890203c          LDRB     r2,[r0,#0x3c]
;;;3764   {
;;;3765     /* Check the parameters */
;;;3766     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3767     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3768   
;;;3769     /* Process Locked */
;;;3770     __HAL_LOCK(htim);
000004  2a01              CMP      r2,#1
000006  d00c              BEQ      |L31.34|
000008  2201              MOVS     r2,#1
00000a  f8002f3c          STRB     r2,[r0,#0x3c]!
;;;3771   
;;;3772     /* Change the TIM state */
;;;3773     htim->State = HAL_TIM_STATE_BUSY;
00000e  2302              MOVS     r3,#2
000010  7043              STRB     r3,[r0,#1]
;;;3774   
;;;3775     /* Set the event sources */
;;;3776     htim->Instance->EGR = EventSource;
000012  f8503c3c          LDR      r3,[r0,#-0x3c]
000016  6159              STR      r1,[r3,#0x14]
;;;3777   
;;;3778     /* Change the TIM state */
;;;3779     htim->State = HAL_TIM_STATE_READY;
000018  7042              STRB     r2,[r0,#1]
;;;3780   
;;;3781     __HAL_UNLOCK(htim);
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;3782   
;;;3783     /* Return function status */
;;;3784     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;3785   }
000020  4770              BX       lr
                  |L31.34|
000022  2002              MOVS     r0,#2                 ;3770
000024  4770              BX       lr
;;;3786   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4313     */
;;;4314   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4315   {
;;;4316     /* Prevent unused argument(s) compilation warning */
;;;4317     UNUSED(htim);
;;;4318     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4319               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4320      */
;;;4321   }
;;;4322   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3003     */
;;;3004   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3005   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3006     /* Check the parameters */
;;;3007     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3008     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3009     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3010     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3011     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3012   
;;;3013     __HAL_LOCK(htim);
000006  f894003c          LDRB     r0,[r4,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d020              BEQ      |L33.80|
00000e  2601              MOVS     r6,#1
000010  f884603c          STRB     r6,[r4,#0x3c]
;;;3014   
;;;3015     htim->State = HAL_TIM_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f884003d          STRB     r0,[r4,#0x3d]
00001a  b1da              CBZ      r2,|L33.84|
;;;3016   
;;;3017     if (Channel == TIM_CHANNEL_1)
;;;3018     {
;;;3019       /* TI1 Configuration */
;;;3020       TIM_TI1_SetConfig(htim->Instance,
;;;3021                  sConfig->ICPolarity,
;;;3022                  sConfig->ICSelection,
;;;3023                  sConfig->ICFilter);
;;;3024   
;;;3025       /* Reset the IC1PSC Bits */
;;;3026       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3027   
;;;3028       /* Set the IC1PSC value */
;;;3029       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3030     }
;;;3031     else if (Channel == TIM_CHANNEL_2)
00001c  2a04              CMP      r2,#4
00001e  d02a              BEQ      |L33.118|
;;;3032     {
;;;3033       /* TI2 Configuration */
;;;3034       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3035   
;;;3036       TIM_TI2_SetConfig(htim->Instance,
;;;3037                         sConfig->ICPolarity,
;;;3038                         sConfig->ICSelection,
;;;3039                         sConfig->ICFilter);
;;;3040   
;;;3041       /* Reset the IC2PSC Bits */
;;;3042       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3043   
;;;3044       /* Set the IC2PSC value */
;;;3045       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3046     }
;;;3047     else if (Channel == TIM_CHANNEL_3)
000020  2a08              CMP      r2,#8
000022  d03a              BEQ      |L33.154|
;;;3048     {
;;;3049       /* TI3 Configuration */
;;;3050       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3051   
;;;3052       TIM_TI3_SetConfig(htim->Instance,
;;;3053                  sConfig->ICPolarity,
;;;3054                  sConfig->ICSelection,
;;;3055                  sConfig->ICFilter);
;;;3056   
;;;3057       /* Reset the IC3PSC Bits */
;;;3058       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3059   
;;;3060       /* Set the IC3PSC value */
;;;3061       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3062     }
;;;3063     else
;;;3064     {
;;;3065       /* TI4 Configuration */
;;;3066       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3067   
;;;3068       TIM_TI4_SetConfig(htim->Instance,
000024  e9d51200          LDRD     r1,r2,[r5,#0]
000028  68eb              LDR      r3,[r5,#0xc]
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_TI4_SetConfig
;;;3069                  sConfig->ICPolarity,
;;;3070                  sConfig->ICSelection,
;;;3071                  sConfig->ICFilter);
;;;3072   
;;;3073       /* Reset the IC4PSC Bits */
;;;3074       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
000030  6820              LDR      r0,[r4,#0]
000032  69c1              LDR      r1,[r0,#0x1c]
000034  f4216140          BIC      r1,r1,#0xc00
000038  61c1              STR      r1,[r0,#0x1c]
;;;3075   
;;;3076       /* Set the IC4PSC value */
;;;3077       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
00003a  6820              LDR      r0,[r4,#0]
00003c  69c1              LDR      r1,[r0,#0x1c]
00003e  68aa              LDR      r2,[r5,#8]
000040  ea412102          ORR      r1,r1,r2,LSL #8
000044  61c1              STR      r1,[r0,#0x1c]
                  |L33.70|
;;;3078     }
;;;3079   
;;;3080     htim->State = HAL_TIM_STATE_READY;
000046  343c              ADDS     r4,r4,#0x3c
000048  7066              STRB     r6,[r4,#1]
;;;3081   
;;;3082     __HAL_UNLOCK(htim);
00004a  2000              MOVS     r0,#0
00004c  7020              STRB     r0,[r4,#0]
;;;3083   
;;;3084     return HAL_OK;
;;;3085   }
00004e  bd70              POP      {r4-r6,pc}
                  |L33.80|
000050  2002              MOVS     r0,#2                 ;3013
000052  bd70              POP      {r4-r6,pc}
                  |L33.84|
000054  e9d51200          LDRD     r1,r2,[r5,#0]         ;3020
000058  68eb              LDR      r3,[r5,#0xc]          ;3020
00005a  6820              LDR      r0,[r4,#0]            ;3020
00005c  f7fffffe          BL       TIM_TI1_SetConfig
000060  6820              LDR      r0,[r4,#0]            ;3026
000062  6981              LDR      r1,[r0,#0x18]         ;3026
000064  f021010c          BIC      r1,r1,#0xc            ;3026
000068  6181              STR      r1,[r0,#0x18]         ;3026
00006a  6820              LDR      r0,[r4,#0]            ;3029
00006c  6981              LDR      r1,[r0,#0x18]         ;3029
00006e  68aa              LDR      r2,[r5,#8]            ;3029
000070  4311              ORRS     r1,r1,r2              ;3029
000072  6181              STR      r1,[r0,#0x18]         ;3029
000074  e7e7              B        |L33.70|
                  |L33.118|
000076  e9d51200          LDRD     r1,r2,[r5,#0]         ;3036
00007a  68eb              LDR      r3,[r5,#0xc]          ;3036
00007c  6820              LDR      r0,[r4,#0]            ;3036
00007e  f7fffffe          BL       TIM_TI2_SetConfig
000082  6820              LDR      r0,[r4,#0]            ;3042
000084  6981              LDR      r1,[r0,#0x18]         ;3042
000086  f4216140          BIC      r1,r1,#0xc00          ;3042
00008a  6181              STR      r1,[r0,#0x18]         ;3042
00008c  6820              LDR      r0,[r4,#0]            ;3045
00008e  6981              LDR      r1,[r0,#0x18]         ;3045
000090  68aa              LDR      r2,[r5,#8]            ;3045
000092  ea412102          ORR      r1,r1,r2,LSL #8       ;3045
000096  6181              STR      r1,[r0,#0x18]         ;3045
000098  e7d5              B        |L33.70|
                  |L33.154|
00009a  e9d51200          LDRD     r1,r2,[r5,#0]         ;3052
00009e  68eb              LDR      r3,[r5,#0xc]          ;3052
0000a0  6820              LDR      r0,[r4,#0]            ;3052
0000a2  f7fffffe          BL       TIM_TI3_SetConfig
0000a6  6820              LDR      r0,[r4,#0]            ;3058
0000a8  69c1              LDR      r1,[r0,#0x1c]         ;3058
0000aa  f021010c          BIC      r1,r1,#0xc            ;3058
0000ae  61c1              STR      r1,[r0,#0x1c]         ;3058
0000b0  6820              LDR      r0,[r4,#0]            ;3061
0000b2  69c1              LDR      r1,[r0,#0x1c]         ;3061
0000b4  68aa              LDR      r2,[r5,#8]            ;3061
0000b6  4311              ORRS     r1,r1,r2              ;3061
0000b8  61c1              STR      r1,[r0,#0x1c]         ;3061
0000ba  e7c4              B        |L33.70|
;;;3086   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1534     */
;;;1535   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1536   {
000002  4604              MOV      r4,r0
;;;1537     /* Check the parameters */
;;;1538     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1539   
;;;1540     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1541   
;;;1542     /* Disable the TIM Peripheral Clock */
;;;1543     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L34.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L34.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L34.38|
;;;1544   
;;;1545     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1546     HAL_TIM_IC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1547   
;;;1548     /* Change TIM state */
;;;1549     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;1550   
;;;1551     /* Release Lock */
;;;1552     __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;1553   
;;;1554     return HAL_OK;
;;;1555   }
000034  bd10              POP      {r4,pc}
;;;1556   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4418     */
;;;4419   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4420   {
;;;4421     return htim->State;
;;;4422   }
000004  4770              BX       lr
;;;4423   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1494     */
;;;1495   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1496   {
000002  4604              MOV      r4,r0
;;;1497     /* Check the TIM handle allocation */
;;;1498     if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L36.16|
;;;1499     {
;;;1500       return HAL_ERROR;
;;;1501     }
;;;1502   
;;;1503     /* Check the parameters */
;;;1504     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1505     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1506     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1507     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1508   
;;;1509     if(htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L36.20|
00000e  e007              B        |L36.32|
                  |L36.16|
000010  2001              MOVS     r0,#1                 ;1500
;;;1510     {
;;;1511       /* Allocate lock resource and initialize it */
;;;1512       htim->Lock = HAL_UNLOCKED;
;;;1513       
;;;1514       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1515       HAL_TIM_IC_MspInit(htim);
;;;1516     }
;;;1517   
;;;1518     /* Set the TIM state */
;;;1519     htim->State= HAL_TIM_STATE_BUSY;
;;;1520   
;;;1521     /* Init the base time for the input capture */
;;;1522     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1523   
;;;1524     /* Initialize the TIM state*/
;;;1525     htim->State= HAL_TIM_STATE_READY;
;;;1526   
;;;1527     return HAL_OK;
;;;1528   }
000012  bd10              POP      {r4,pc}
                  |L36.20|
000014  2000              MOVS     r0,#0                 ;1512
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1512
00001a  4620              MOV      r0,r4                 ;1515
00001c  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.32|
000020  2002              MOVS     r0,#2                 ;1519
000022  f884003d          STRB     r0,[r4,#0x3d]         ;1519
000026  1d21              ADDS     r1,r4,#4              ;1522
000028  6820              LDR      r0,[r4,#0]            ;1522
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;1525
000030  f884003d          STRB     r0,[r4,#0x3d]         ;1525
000034  2000              MOVS     r0,#0                 ;1527
000036  bd10              POP      {r4,pc}
;;;1529   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1575     */
;;;1576   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1577   {
;;;1578     /* Prevent unused argument(s) compilation warning */
;;;1579     UNUSED(htim);
;;;1580     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1581               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1582      */
;;;1583   }
;;;1584   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1561     */
;;;1562   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1563   {
;;;1564     /* Prevent unused argument(s) compilation warning */
;;;1565     UNUSED(htim);
;;;1566     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1567               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1568      */
;;;1569   }
;;;1570   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1595   */
;;;1596   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1597   {
000002  4604              MOV      r4,r0
;;;1598     /* Check the parameters */
;;;1599     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1600   
;;;1601     /* Enable the Input Capture channel */
;;;1602     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  2201              MOVS     r2,#1
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1603   
;;;1604     /* Enable the Peripheral */
;;;1605     __HAL_TIM_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0410101          ORR      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;1606   
;;;1607     /* Return function status */
;;;1608     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1609   }
000018  bd10              POP      {r4,pc}
;;;1610   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1768   */
;;;1769   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1770   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1771     /* Check the parameters */
;;;1772     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1773     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1774   
;;;1775     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L40.24|
;;;1776     {
;;;1777        return HAL_BUSY;
;;;1778     }
;;;1779     else if((htim->State == HAL_TIM_STATE_READY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2801              CMP      r0,#1
000014  d002              BEQ      |L40.28|
000016  e008              B        |L40.42|
                  |L40.24|
000018  2002              MOVS     r0,#2                 ;1777
;;;1780     {
;;;1781       if((pData == 0U) && (Length > 0U))
;;;1782       {
;;;1783         return HAL_ERROR;
;;;1784       }
;;;1785       else
;;;1786       {
;;;1787         htim->State = HAL_TIM_STATE_BUSY;
;;;1788       }
;;;1789     }
;;;1790   
;;;1791     switch (Channel)
;;;1792     {
;;;1793       case TIM_CHANNEL_1:
;;;1794       {
;;;1795         /* Set the DMA Period elapsed callback */
;;;1796         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1797   
;;;1798         /* Set the DMA error callback */
;;;1799         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1800   
;;;1801         /* Enable the DMA channel */
;;;1802         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1803   
;;;1804         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1805         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1806       }
;;;1807       break;
;;;1808   
;;;1809       case TIM_CHANNEL_2:
;;;1810       {
;;;1811         /* Set the DMA Period elapsed callback */
;;;1812         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1813   
;;;1814         /* Set the DMA error callback */
;;;1815         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1816   
;;;1817         /* Enable the DMA channel */
;;;1818         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1819   
;;;1820         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1821         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1822       }
;;;1823       break;
;;;1824   
;;;1825       case TIM_CHANNEL_3:
;;;1826       {
;;;1827         /* Set the DMA Period elapsed callback */
;;;1828         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1829   
;;;1830         /* Set the DMA error callback */
;;;1831         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1832   
;;;1833         /* Enable the DMA channel */
;;;1834         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1835   
;;;1836         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1837         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1838       }
;;;1839       break;
;;;1840   
;;;1841       case TIM_CHANNEL_4:
;;;1842       {
;;;1843         /* Set the DMA Period elapsed callback */
;;;1844         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1845   
;;;1846         /* Set the DMA error callback */
;;;1847         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1848   
;;;1849         /* Enable the DMA channel */
;;;1850         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1851   
;;;1852         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1853         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1854       }
;;;1855       break;
;;;1856   
;;;1857       default:
;;;1858       break;
;;;1859     }
;;;1860   
;;;1861     /* Enable the Input Capture channel */
;;;1862     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1863   
;;;1864     /* Enable the Peripheral */
;;;1865     __HAL_TIM_ENABLE(htim);
;;;1866   
;;;1867     /* Return function status */
;;;1868     return HAL_OK;
;;;1869   }
00001a  bd70              POP      {r4-r6,pc}
                  |L40.28|
00001c  b912              CBNZ     r2,|L40.36|
00001e  b10b              CBZ      r3,|L40.36|
000020  2001              MOVS     r0,#1                 ;1783
000022  bd70              POP      {r4-r6,pc}
                  |L40.36|
000024  2002              MOVS     r0,#2                 ;1787
000026  f884003d          STRB     r0,[r4,#0x3d]         ;1787
                  |L40.42|
00002a  4828              LDR      r0,|L40.204|
00002c  4928              LDR      r1,|L40.208|
00002e  b135              CBZ      r5,|L40.62|
000030  2d04              CMP      r5,#4                 ;1791
000032  d013              BEQ      |L40.92|
000034  2d08              CMP      r5,#8                 ;1791
000036  d020              BEQ      |L40.122|
000038  2d0c              CMP      r5,#0xc               ;1791
00003a  d13b              BNE      |L40.180|
00003c  e02c              B        |L40.152|
                  |L40.62|
00003e  6a66              LDR      r6,[r4,#0x24]         ;1796
000040  62b0              STR      r0,[r6,#0x28]         ;1796
000042  6a60              LDR      r0,[r4,#0x24]         ;1799
000044  6301              STR      r1,[r0,#0x30]         ;1799
000046  6821              LDR      r1,[r4,#0]            ;1802
000048  6a60              LDR      r0,[r4,#0x24]         ;1802
00004a  3134              ADDS     r1,r1,#0x34           ;1802
00004c  f7fffffe          BL       HAL_DMA_Start_IT
000050  6820              LDR      r0,[r4,#0]            ;1805
000052  68c1              LDR      r1,[r0,#0xc]          ;1805
000054  f4417100          ORR      r1,r1,#0x200          ;1805
000058  60c1              STR      r1,[r0,#0xc]          ;1805
00005a  e02b              B        |L40.180|
                  |L40.92|
00005c  6aa6              LDR      r6,[r4,#0x28]         ;1812
00005e  62b0              STR      r0,[r6,#0x28]         ;1812
000060  6aa0              LDR      r0,[r4,#0x28]         ;1815
000062  6301              STR      r1,[r0,#0x30]         ;1815
000064  6821              LDR      r1,[r4,#0]            ;1818
000066  6aa0              LDR      r0,[r4,#0x28]         ;1818
000068  3138              ADDS     r1,r1,#0x38           ;1818
00006a  f7fffffe          BL       HAL_DMA_Start_IT
00006e  6820              LDR      r0,[r4,#0]            ;1821
000070  68c1              LDR      r1,[r0,#0xc]          ;1821
000072  f4416180          ORR      r1,r1,#0x400          ;1821
000076  60c1              STR      r1,[r0,#0xc]          ;1821
000078  e01c              B        |L40.180|
                  |L40.122|
00007a  6ae6              LDR      r6,[r4,#0x2c]         ;1828
00007c  62b0              STR      r0,[r6,#0x28]         ;1828
00007e  6ae0              LDR      r0,[r4,#0x2c]         ;1831
000080  6301              STR      r1,[r0,#0x30]         ;1831
000082  6821              LDR      r1,[r4,#0]            ;1834
000084  6ae0              LDR      r0,[r4,#0x2c]         ;1834
000086  313c              ADDS     r1,r1,#0x3c           ;1834
000088  f7fffffe          BL       HAL_DMA_Start_IT
00008c  6820              LDR      r0,[r4,#0]            ;1837
00008e  68c1              LDR      r1,[r0,#0xc]          ;1837
000090  f4416100          ORR      r1,r1,#0x800          ;1837
000094  60c1              STR      r1,[r0,#0xc]          ;1837
000096  e00d              B        |L40.180|
                  |L40.152|
000098  6b26              LDR      r6,[r4,#0x30]         ;1844
00009a  62b0              STR      r0,[r6,#0x28]         ;1844
00009c  6b20              LDR      r0,[r4,#0x30]         ;1847
00009e  6301              STR      r1,[r0,#0x30]         ;1847
0000a0  6821              LDR      r1,[r4,#0]            ;1850
0000a2  6b20              LDR      r0,[r4,#0x30]         ;1850
0000a4  3140              ADDS     r1,r1,#0x40           ;1850
0000a6  f7fffffe          BL       HAL_DMA_Start_IT
0000aa  6820              LDR      r0,[r4,#0]            ;1853
0000ac  68c1              LDR      r1,[r0,#0xc]          ;1853
0000ae  f4415180          ORR      r1,r1,#0x1000         ;1853
0000b2  60c1              STR      r1,[r0,#0xc]          ;1853
                  |L40.180|
0000b4  2201              MOVS     r2,#1                 ;1862
0000b6  4629              MOV      r1,r5                 ;1862
0000b8  6820              LDR      r0,[r4,#0]            ;1862
0000ba  f7fffffe          BL       TIM_CCxChannelCmd
0000be  6820              LDR      r0,[r4,#0]            ;1865
0000c0  6801              LDR      r1,[r0,#0]            ;1865
0000c2  f0410101          ORR      r1,r1,#1              ;1865
0000c6  6001              STR      r1,[r0,#0]            ;1865
0000c8  2000              MOVS     r0,#0                 ;1868
0000ca  bd70              POP      {r4-r6,pc}
;;;1870   
                          ENDP

                  |L40.204|
                          DCD      TIM_DMACaptureCplt
                  |L40.208|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1647   */
;;;1648   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1649   {
000002  4604              MOV      r4,r0
;;;1650     /* Check the parameters */
;;;1651     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1652   
;;;1653     switch (Channel)
000004  2900              CMP      r1,#0
;;;1654     {
;;;1655       case TIM_CHANNEL_1:
;;;1656       {
;;;1657         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1658         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L41.24|
00000a  2904              CMP      r1,#4                 ;1653
00000c  d009              BEQ      |L41.34|
00000e  2908              CMP      r1,#8                 ;1653
000010  d00c              BEQ      |L41.44|
000012  290c              CMP      r1,#0xc               ;1653
000014  d113              BNE      |L41.62|
000016  e00e              B        |L41.54|
                  |L41.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;1659       }
;;;1660       break;
000020  e00d              B        |L41.62|
                  |L41.34|
;;;1661   
;;;1662       case TIM_CHANNEL_2:
;;;1663       {
;;;1664         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1665         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;1666       }
;;;1667       break;
00002a  e008              B        |L41.62|
                  |L41.44|
;;;1668   
;;;1669       case TIM_CHANNEL_3:
;;;1670       {
;;;1671         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1672         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0400008          ORR      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;1673       }
;;;1674       break;
000034  e003              B        |L41.62|
                  |L41.54|
;;;1675   
;;;1676       case TIM_CHANNEL_4:
;;;1677       {
;;;1678         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1679         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0400010          ORR      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L41.62|
;;;1680       }
;;;1681       break;
;;;1682   
;;;1683       default:
;;;1684       break;
;;;1685     }
;;;1686     /* Enable the Input Capture channel */
;;;1687     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;1688   
;;;1689     /* Enable the Peripheral */
;;;1690     __HAL_TIM_ENABLE(htim);
000046  6820              LDR      r0,[r4,#0]
000048  6801              LDR      r1,[r0,#0]
00004a  f0410101          ORR      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
;;;1691   
;;;1692     /* Return function status */
;;;1693     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1694   }
000052  bd10              POP      {r4,pc}
;;;1695   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1621   */
;;;1622   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1623   {
000002  4604              MOV      r4,r0
;;;1624     /* Check the parameters */
;;;1625     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1626   
;;;1627     /* Disable the Input Capture channel */
;;;1628     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1629   
;;;1630     /* Disable the Peripheral */
;;;1631     __HAL_TIM_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4211              TST      r1,r2
000016  d107              BNE      |L42.40|
000018  6a01              LDR      r1,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4211              TST      r1,r2
00001e  d103              BNE      |L42.40|
000020  6801              LDR      r1,[r0,#0]
000022  f0210101          BIC      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
                  |L42.40|
;;;1632   
;;;1633     /* Return function status */
;;;1634     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1635   }
00002a  bd10              POP      {r4,pc}
;;;1636   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1881   */
;;;1882   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1883   {
000002  4604              MOV      r4,r0
;;;1884     /* Check the parameters */
;;;1885     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1886     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1887   
;;;1888     switch (Channel)
000004  2900              CMP      r1,#0
;;;1889     {
;;;1890       case TIM_CHANNEL_1:
;;;1891       {
;;;1892         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1893         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L43.24|
00000a  2904              CMP      r1,#4                 ;1888
00000c  d009              BEQ      |L43.34|
00000e  2908              CMP      r1,#8                 ;1888
000010  d00c              BEQ      |L43.44|
000012  290c              CMP      r1,#0xc               ;1888
000014  d113              BNE      |L43.62|
000016  e00e              B        |L43.54|
                  |L43.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  60d0              STR      r0,[r2,#0xc]
;;;1894       }
;;;1895       break;
000020  e00d              B        |L43.62|
                  |L43.34|
;;;1896   
;;;1897       case TIM_CHANNEL_2:
;;;1898       {
;;;1899         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1900         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f4206080          BIC      r0,r0,#0x400
000028  60d0              STR      r0,[r2,#0xc]
;;;1901       }
;;;1902       break;
00002a  e008              B        |L43.62|
                  |L43.44|
;;;1903   
;;;1904       case TIM_CHANNEL_3:
;;;1905       {
;;;1906         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1907         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f4206000          BIC      r0,r0,#0x800
000032  60d0              STR      r0,[r2,#0xc]
;;;1908       }
;;;1909       break;
000034  e003              B        |L43.62|
                  |L43.54|
;;;1910   
;;;1911       case TIM_CHANNEL_4:
;;;1912       {
;;;1913         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1914         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f4205080          BIC      r0,r0,#0x1000
00003c  60d0              STR      r0,[r2,#0xc]
                  |L43.62|
;;;1915       }
;;;1916       break;
;;;1917   
;;;1918       default:
;;;1919       break;
;;;1920     }
;;;1921   
;;;1922     /* Disable the Input Capture channel */
;;;1923     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;1924   
;;;1925     /* Disable the Peripheral */
;;;1926     __HAL_TIM_DISABLE(htim);
000046  6820              LDR      r0,[r4,#0]
000048  6a01              LDR      r1,[r0,#0x20]
00004a  f2411211          MOV      r2,#0x1111
00004e  4211              TST      r1,r2
000050  d107              BNE      |L43.98|
000052  6a01              LDR      r1,[r0,#0x20]
000054  1092              ASRS     r2,r2,#2
000056  4211              TST      r1,r2
000058  d103              BNE      |L43.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L43.98|
;;;1927   
;;;1928     /* Change the htim state */
;;;1929     htim->State = HAL_TIM_STATE_READY;
000062  2001              MOVS     r0,#1
000064  f884003d          STRB     r0,[r4,#0x3d]
;;;1930   
;;;1931     /* Return function status */
;;;1932     return HAL_OK;
000068  2000              MOVS     r0,#0
;;;1933   }
00006a  bd10              POP      {r4,pc}
;;;1934   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1706   */
;;;1707   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1708   {
000002  4604              MOV      r4,r0
;;;1709     /* Check the parameters */
;;;1710     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1711   
;;;1712     switch (Channel)
000004  2900              CMP      r1,#0
;;;1713     {
;;;1714       case TIM_CHANNEL_1:
;;;1715       {
;;;1716         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1717         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L44.24|
00000a  2904              CMP      r1,#4                 ;1712
00000c  d009              BEQ      |L44.34|
00000e  2908              CMP      r1,#8                 ;1712
000010  d00c              BEQ      |L44.44|
000012  290c              CMP      r1,#0xc               ;1712
000014  d113              BNE      |L44.62|
000016  e00e              B        |L44.54|
                  |L44.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;1718       }
;;;1719       break;
000020  e00d              B        |L44.62|
                  |L44.34|
;;;1720   
;;;1721       case TIM_CHANNEL_2:
;;;1722       {
;;;1723         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1724         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;1725       }
;;;1726       break;
00002a  e008              B        |L44.62|
                  |L44.44|
;;;1727   
;;;1728       case TIM_CHANNEL_3:
;;;1729       {
;;;1730         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1731         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0200008          BIC      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;1732       }
;;;1733       break;
000034  e003              B        |L44.62|
                  |L44.54|
;;;1734   
;;;1735       case TIM_CHANNEL_4:
;;;1736       {
;;;1737         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1738         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0200010          BIC      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L44.62|
;;;1739       }
;;;1740       break;
;;;1741   
;;;1742       default:
;;;1743       break;
;;;1744     }
;;;1745   
;;;1746     /* Disable the Input Capture channel */
;;;1747     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;1748   
;;;1749     /* Disable the Peripheral */
;;;1750     __HAL_TIM_DISABLE(htim);
000046  6820              LDR      r0,[r4,#0]
000048  6a01              LDR      r1,[r0,#0x20]
00004a  f2411211          MOV      r2,#0x1111
00004e  4211              TST      r1,r2
000050  d107              BNE      |L44.98|
000052  6a01              LDR      r1,[r0,#0x20]
000054  1092              ASRS     r2,r2,#2
000056  4211              TST      r1,r2
000058  d103              BNE      |L44.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L44.98|
;;;1751   
;;;1752     /* Return function status */
;;;1753     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1754   }
000064  bd10              POP      {r4,pc}
;;;1755   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2771     */
;;;2772   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2773   {
000002  4604              MOV      r4,r0
;;;2774     /* Capture compare 1 event */
;;;2775     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  43c9              MVNS     r1,r1
00000e  0789              LSLS     r1,r1,#30
000010  d416              BMI      |L45.64|
;;;2776     {
;;;2777       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000012  68c1              LDR      r1,[r0,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d412              BMI      |L45.64|
;;;2778       {
;;;2779         {
;;;2780           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  1ee9              SUBS     r1,r5,#3
00001c  6101              STR      r1,[r0,#0x10]
;;;2781           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00001e  2001              MOVS     r0,#1
000020  7720              STRB     r0,[r4,#0x1c]
;;;2782   
;;;2783           /* Input capture event */
;;;2784           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000022  6820              LDR      r0,[r4,#0]
000024  6980              LDR      r0,[r0,#0x18]
000026  0780              LSLS     r0,r0,#30
000028  d003              BEQ      |L45.50|
;;;2785           {
;;;2786             HAL_TIM_IC_CaptureCallback(htim);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000030  e005              B        |L45.62|
                  |L45.50|
;;;2787           }
;;;2788           /* Output compare event */
;;;2789           else
;;;2790           {
;;;2791             HAL_TIM_OC_DelayElapsedCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2792             HAL_TIM_PWM_PulseFinishedCallback(htim);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.62|
;;;2793           }
;;;2794           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  7725              STRB     r5,[r4,#0x1c]
                  |L45.64|
;;;2795         }
;;;2796       }
;;;2797     }
;;;2798     /* Capture compare 2 event */
;;;2799     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000040  6820              LDR      r0,[r4,#0]
000042  6901              LDR      r1,[r0,#0x10]
000044  43c9              MVNS     r1,r1
000046  0749              LSLS     r1,r1,#29
000048  d418              BMI      |L45.124|
;;;2800     {
;;;2801       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
00004a  68c1              LDR      r1,[r0,#0xc]
00004c  43c9              MVNS     r1,r1
00004e  0749              LSLS     r1,r1,#29
000050  d414              BMI      |L45.124|
;;;2802       {
;;;2803         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000052  f06f0104          MVN      r1,#4
000056  6101              STR      r1,[r0,#0x10]
;;;2804         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000058  2002              MOVS     r0,#2
00005a  7720              STRB     r0,[r4,#0x1c]
;;;2805         /* Input capture event */
;;;2806         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
00005c  6820              LDR      r0,[r4,#0]
00005e  6980              LDR      r0,[r0,#0x18]
000060  f4107f40          TST      r0,#0x300
000064  d003              BEQ      |L45.110|
;;;2807         {
;;;2808           HAL_TIM_IC_CaptureCallback(htim);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006c  e005              B        |L45.122|
                  |L45.110|
;;;2809         }
;;;2810         /* Output compare event */
;;;2811         else
;;;2812         {
;;;2813           HAL_TIM_OC_DelayElapsedCallback(htim);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2814           HAL_TIM_PWM_PulseFinishedCallback(htim);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.122|
;;;2815         }
;;;2816         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00007a  7725              STRB     r5,[r4,#0x1c]
                  |L45.124|
;;;2817       }
;;;2818     }
;;;2819     /* Capture compare 3 event */
;;;2820     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00007c  6820              LDR      r0,[r4,#0]
00007e  6901              LDR      r1,[r0,#0x10]
000080  43c9              MVNS     r1,r1
000082  0709              LSLS     r1,r1,#28
000084  d417              BMI      |L45.182|
;;;2821     {
;;;2822       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000086  68c1              LDR      r1,[r0,#0xc]
000088  43c9              MVNS     r1,r1
00008a  0709              LSLS     r1,r1,#28
00008c  d413              BMI      |L45.182|
;;;2823       {
;;;2824         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008e  f06f0108          MVN      r1,#8
000092  6101              STR      r1,[r0,#0x10]
;;;2825         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000094  2004              MOVS     r0,#4
000096  7720              STRB     r0,[r4,#0x1c]
;;;2826         /* Input capture event */
;;;2827         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
000098  6820              LDR      r0,[r4,#0]
00009a  69c0              LDR      r0,[r0,#0x1c]
00009c  0780              LSLS     r0,r0,#30
00009e  d003              BEQ      |L45.168|
;;;2828         {
;;;2829           HAL_TIM_IC_CaptureCallback(htim);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a6  e005              B        |L45.180|
                  |L45.168|
;;;2830         }
;;;2831         /* Output compare event */
;;;2832         else
;;;2833         {
;;;2834           HAL_TIM_OC_DelayElapsedCallback(htim);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2835           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.180|
;;;2836         }
;;;2837         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000b4  7725              STRB     r5,[r4,#0x1c]
                  |L45.182|
;;;2838       }
;;;2839     }
;;;2840     /* Capture compare 4 event */
;;;2841     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6901              LDR      r1,[r0,#0x10]
0000ba  43c9              MVNS     r1,r1
0000bc  06c9              LSLS     r1,r1,#27
0000be  d418              BMI      |L45.242|
;;;2842     {
;;;2843       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000c0  68c1              LDR      r1,[r0,#0xc]
0000c2  43c9              MVNS     r1,r1
0000c4  06c9              LSLS     r1,r1,#27
0000c6  d414              BMI      |L45.242|
;;;2844       {
;;;2845         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c8  f06f0110          MVN      r1,#0x10
0000cc  6101              STR      r1,[r0,#0x10]
;;;2846         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000ce  2008              MOVS     r0,#8
0000d0  7720              STRB     r0,[r4,#0x1c]
;;;2847         /* Input capture event */
;;;2848         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000d2  6820              LDR      r0,[r4,#0]
0000d4  69c0              LDR      r0,[r0,#0x1c]
0000d6  f4107f40          TST      r0,#0x300
0000da  d003              BEQ      |L45.228|
;;;2849         {
;;;2850           HAL_TIM_IC_CaptureCallback(htim);
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000e2  e005              B        |L45.240|
                  |L45.228|
;;;2851         }
;;;2852         /* Output compare event */
;;;2853         else
;;;2854         {
;;;2855           HAL_TIM_OC_DelayElapsedCallback(htim);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2856           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.240|
;;;2857         }
;;;2858         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000f0  7725              STRB     r5,[r4,#0x1c]
                  |L45.242|
;;;2859       }
;;;2860     }
;;;2861     /* TIM Update event */
;;;2862     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6901              LDR      r1,[r0,#0x10]
0000f6  43c9              MVNS     r1,r1
0000f8  07c9              LSLS     r1,r1,#31
0000fa  d108              BNE      |L45.270|
;;;2863     {
;;;2864       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000fc  68c1              LDR      r1,[r0,#0xc]
0000fe  43c9              MVNS     r1,r1
000100  07c9              LSLS     r1,r1,#31
000102  d104              BNE      |L45.270|
;;;2865       {
;;;2866         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000104  1e89              SUBS     r1,r1,#2
000106  6101              STR      r1,[r0,#0x10]
;;;2867         HAL_TIM_PeriodElapsedCallback(htim);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.270|
;;;2868       }
;;;2869     }
;;;2870     /* TIM Break input event */
;;;2871     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00010e  6820              LDR      r0,[r4,#0]
000110  6901              LDR      r1,[r0,#0x10]
000112  43c9              MVNS     r1,r1
000114  0609              LSLS     r1,r1,#24
000116  d409              BMI      |L45.300|
;;;2872     {
;;;2873       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000118  68c1              LDR      r1,[r0,#0xc]
00011a  43c9              MVNS     r1,r1
00011c  0609              LSLS     r1,r1,#24
00011e  d405              BMI      |L45.300|
;;;2874       {
;;;2875         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000120  f06f0180          MVN      r1,#0x80
000124  6101              STR      r1,[r0,#0x10]
;;;2876         HAL_TIMEx_BreakCallback(htim);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.300|
;;;2877       }
;;;2878     }
;;;2879     /* TIM Trigger detection event */
;;;2880     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
00012c  6820              LDR      r0,[r4,#0]
00012e  6901              LDR      r1,[r0,#0x10]
000130  43c9              MVNS     r1,r1
000132  0649              LSLS     r1,r1,#25
000134  d409              BMI      |L45.330|
;;;2881     {
;;;2882       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
000136  68c1              LDR      r1,[r0,#0xc]
000138  43c9              MVNS     r1,r1
00013a  0649              LSLS     r1,r1,#25
00013c  d405              BMI      |L45.330|
;;;2883       {
;;;2884         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
00013e  f06f0140          MVN      r1,#0x40
000142  6101              STR      r1,[r0,#0x10]
;;;2885         HAL_TIM_TriggerCallback(htim);
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.330|
;;;2886       }
;;;2887     }
;;;2888     /* TIM commutation event */
;;;2889     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
00014a  6820              LDR      r0,[r4,#0]
00014c  6901              LDR      r1,[r0,#0x10]
00014e  43c9              MVNS     r1,r1
000150  0689              LSLS     r1,r1,#26
000152  d40b              BMI      |L45.364|
;;;2890     {
;;;2891       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
000154  68c1              LDR      r1,[r0,#0xc]
000156  43c9              MVNS     r1,r1
000158  0689              LSLS     r1,r1,#26
00015a  d407              BMI      |L45.364|
;;;2892       {
;;;2893         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
00015c  f06f0120          MVN      r1,#0x20
000160  6101              STR      r1,[r0,#0x10]
;;;2894         HAL_TIMEx_CommutationCallback(htim);
000162  4620              MOV      r0,r4
000164  e8bd4070          POP      {r4-r6,lr}
000168  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
                  |L45.364|
;;;2895       }
;;;2896     }
;;;2897   }
00016c  bd70              POP      {r4-r6,pc}
;;;2898   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2934     */
;;;2935   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2936   {
000002  4604              MOV      r4,r0
;;;2937     /* Check the parameters */
;;;2938     assert_param(IS_TIM_CHANNELS(Channel));
;;;2939     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2940     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2941   
;;;2942     /* Check input state */
;;;2943     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d00d              BEQ      |L46.40|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;2944   
;;;2945     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
000018  b142              CBZ      r2,|L46.44|
;;;2946   
;;;2947     switch (Channel)
00001a  2a04              CMP      r2,#4
00001c  d00a              BEQ      |L46.52|
00001e  2a08              CMP      r2,#8
000020  d00c              BEQ      |L46.60|
000022  2a0c              CMP      r2,#0xc
000024  d111              BNE      |L46.74|
000026  e00d              B        |L46.68|
                  |L46.40|
000028  2002              MOVS     r0,#2                 ;2943
;;;2948     {
;;;2949       case TIM_CHANNEL_1:
;;;2950       {
;;;2951         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2952         /* Configure the TIM Channel 1 in Output Compare */
;;;2953         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2954       }
;;;2955       break;
;;;2956   
;;;2957       case TIM_CHANNEL_2:
;;;2958       {
;;;2959         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2960         /* Configure the TIM Channel 2 in Output Compare */
;;;2961         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2962       }
;;;2963       break;
;;;2964   
;;;2965       case TIM_CHANNEL_3:
;;;2966       {
;;;2967          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2968         /* Configure the TIM Channel 3 in Output Compare */
;;;2969         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2970       }
;;;2971       break;
;;;2972   
;;;2973       case TIM_CHANNEL_4:
;;;2974       {
;;;2975         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2976          /* Configure the TIM Channel 4 in Output Compare */
;;;2977          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2978       }
;;;2979       break;
;;;2980   
;;;2981       default:
;;;2982       break;
;;;2983     }
;;;2984     htim->State = HAL_TIM_STATE_READY;
;;;2985   
;;;2986     __HAL_UNLOCK(htim);
;;;2987   
;;;2988     return HAL_OK;
;;;2989   }
00002a  bd70              POP      {r4-r6,pc}
                  |L46.44|
00002c  6820              LDR      r0,[r4,#0]            ;2953
00002e  f7fffffe          BL       TIM_OC1_SetConfig
000032  e00a              B        |L46.74|
                  |L46.52|
000034  6820              LDR      r0,[r4,#0]            ;2961
000036  f7fffffe          BL       TIM_OC2_SetConfig
00003a  e006              B        |L46.74|
                  |L46.60|
00003c  6820              LDR      r0,[r4,#0]            ;2969
00003e  f7fffffe          BL       TIM_OC3_SetConfig
000042  e002              B        |L46.74|
                  |L46.68|
000044  6820              LDR      r0,[r4,#0]            ;2977
000046  f7fffffe          BL       TIM_OC4_SetConfig
                  |L46.74|
00004a  343c              ADDS     r4,r4,#0x3c           ;2984
00004c  7065              STRB     r5,[r4,#1]            ;2984
00004e  2000              MOVS     r0,#0                 ;2986
000050  7020              STRB     r0,[r4,#0]            ;2986
000052  bd70              POP      {r4-r6,pc}
;;;2990   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;521      */
;;;522    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;526    
;;;527       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;528    
;;;529      /* Disable the TIM Peripheral Clock */
;;;530      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L47.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L47.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L47.38|
;;;531    
;;;532      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;533      HAL_TIM_OC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;534    
;;;535      /* Change TIM state */
;;;536      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;537    
;;;538      /* Release Lock */
;;;539      __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;540    
;;;541      return HAL_OK;
;;;542    }
000034  bd10              POP      {r4,pc}
;;;543    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4300     */
;;;4301   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4302   {
;;;4303     /* Prevent unused argument(s) compilation warning */
;;;4304     UNUSED(htim);
;;;4305     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4306               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4307      */
;;;4308   }
;;;4309   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4398     */
;;;4399   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4400   {
;;;4401     return htim->State;
;;;4402   }
000004  4770              BX       lr
;;;4403   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;481      */
;;;482    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;483    {
000002  4604              MOV      r4,r0
;;;484      /* Check the TIM handle allocation */
;;;485      if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L50.16|
;;;486      {
;;;487        return HAL_ERROR;
;;;488      }
;;;489    
;;;490      /* Check the parameters */
;;;491      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;492      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;493      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;494      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;495    
;;;496      if(htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L50.20|
00000e  e007              B        |L50.32|
                  |L50.16|
000010  2001              MOVS     r0,#1                 ;487
;;;497      {
;;;498        /* Allocate lock resource and initialize it */
;;;499        htim->Lock = HAL_UNLOCKED;
;;;500        
;;;501        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;502        HAL_TIM_OC_MspInit(htim);
;;;503      }
;;;504    
;;;505      /* Set the TIM state */
;;;506      htim->State= HAL_TIM_STATE_BUSY;
;;;507    
;;;508      /* Init the base time for the Output Compare */
;;;509      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;510    
;;;511      /* Initialize the TIM state*/
;;;512      htim->State= HAL_TIM_STATE_READY;
;;;513    
;;;514      return HAL_OK;
;;;515    }
000012  bd10              POP      {r4,pc}
                  |L50.20|
000014  2000              MOVS     r0,#0                 ;499
000016  f884003c          STRB     r0,[r4,#0x3c]         ;499
00001a  4620              MOV      r0,r4                 ;502
00001c  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.32|
000020  2002              MOVS     r0,#2                 ;506
000022  f884003d          STRB     r0,[r4,#0x3d]         ;506
000026  1d21              ADDS     r1,r4,#4              ;509
000028  6820              LDR      r0,[r4,#0]            ;509
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;512
000030  f884003d          STRB     r0,[r4,#0x3d]         ;512
000034  2000              MOVS     r0,#0                 ;514
000036  bd10              POP      {r4,pc}
;;;516    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;562      */
;;;563    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;564    {
;;;565      /* Prevent unused argument(s) compilation warning */
;;;566      UNUSED(htim);
;;;567      /* NOTE : This function Should not be modified, when the callback is needed,
;;;568                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;569       */
;;;570    }
;;;571    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;548      */
;;;549    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;550    {
;;;551      /* Prevent unused argument(s) compilation warning */
;;;552      UNUSED(htim);
;;;553      /* NOTE : This function Should not be modified, when the callback is needed,
;;;554                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;555       */
;;;556    }
;;;557    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;582    */
;;;583    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;584    {
000002  4604              MOV      r4,r0
;;;585      /* Check the parameters */
;;;586      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;587    
;;;588      /* Enable the Output compare channel */
;;;589      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  2201              MOVS     r2,#1
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;590    
;;;591      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4907              LDR      r1,|L53.44|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d103              BNE      |L53.28|
;;;592      {
;;;593        /* Enable the main output */
;;;594        __HAL_TIM_MOE_ENABLE(htim);
000014  6c41              LDR      r1,[r0,#0x44]
000016  f4414100          ORR      r1,r1,#0x8000
00001a  6441              STR      r1,[r0,#0x44]
                  |L53.28|
;;;595      }
;;;596    
;;;597      /* Enable the Peripheral */
;;;598      __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410101          ORR      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
;;;599    
;;;600      /* Return function status */
;;;601      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;602    }
000028  bd10              POP      {r4,pc}
;;;603    
                          ENDP

00002a  0000              DCW      0x0000
                  |L53.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;780    */
;;;781    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;782    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  4611              MOV      r1,r2
;;;783      /* Check the parameters */
;;;784      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;785    
;;;786      if((htim->State == HAL_TIM_STATE_BUSY))
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2802              CMP      r0,#2
00000e  d004              BEQ      |L54.26|
;;;787      {
;;;788         return HAL_BUSY;
;;;789      }
;;;790      else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L54.30|
000018  e008              B        |L54.44|
                  |L54.26|
00001a  2002              MOVS     r0,#2                 ;788
;;;791      {
;;;792        if(((uint32_t)pData == 0U) && (Length > 0U))
;;;793        {
;;;794          return HAL_ERROR;
;;;795        }
;;;796        else
;;;797        {
;;;798          htim->State = HAL_TIM_STATE_BUSY;
;;;799        }
;;;800      }
;;;801      switch (Channel)
;;;802      {
;;;803        case TIM_CHANNEL_1:
;;;804        {
;;;805          /* Set the DMA Period elapsed callback */
;;;806          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;807    
;;;808          /* Set the DMA error callback */
;;;809          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;810    
;;;811          /* Enable the DMA channel */
;;;812          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;813    
;;;814          /* Enable the TIM Capture/Compare 1 DMA request */
;;;815          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;816        }
;;;817        break;
;;;818    
;;;819        case TIM_CHANNEL_2:
;;;820        {
;;;821          /* Set the DMA Period elapsed callback */
;;;822          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;823    
;;;824          /* Set the DMA error callback */
;;;825          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;826    
;;;827          /* Enable the DMA channel */
;;;828          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;829    
;;;830          /* Enable the TIM Capture/Compare 2 DMA request */
;;;831          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;832        }
;;;833        break;
;;;834    
;;;835        case TIM_CHANNEL_3:
;;;836        {
;;;837          /* Set the DMA Period elapsed callback */
;;;838          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;839    
;;;840          /* Set the DMA error callback */
;;;841          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;842    
;;;843          /* Enable the DMA channel */
;;;844          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;845    
;;;846          /* Enable the TIM Capture/Compare 3 DMA request */
;;;847          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;848        }
;;;849        break;
;;;850    
;;;851        case TIM_CHANNEL_4:
;;;852        {
;;;853         /* Set the DMA Period elapsed callback */
;;;854          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;855    
;;;856          /* Set the DMA error callback */
;;;857          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;858    
;;;859          /* Enable the DMA channel */
;;;860          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;861    
;;;862          /* Enable the TIM Capture/Compare 4 DMA request */
;;;863          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;864        }
;;;865        break;
;;;866    
;;;867        default:
;;;868        break;
;;;869      }
;;;870    
;;;871      /* Enable the Output compare channel */
;;;872      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;873    
;;;874      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;875      {
;;;876        /* Enable the main output */
;;;877        __HAL_TIM_MOE_ENABLE(htim);
;;;878      }
;;;879    
;;;880      /* Enable the Peripheral */
;;;881      __HAL_TIM_ENABLE(htim);
;;;882    
;;;883      /* Return function status */
;;;884      return HAL_OK;
;;;885    }
00001c  bd70              POP      {r4-r6,pc}
                  |L54.30|
00001e  b911              CBNZ     r1,|L54.38|
000020  b10b              CBZ      r3,|L54.38|
000022  2001              MOVS     r0,#1                 ;794
000024  bd70              POP      {r4-r6,pc}
                  |L54.38|
000026  2002              MOVS     r0,#2                 ;798
000028  f884003d          STRB     r0,[r4,#0x3d]         ;798
                  |L54.44|
00002c  482c              LDR      r0,|L54.224|
00002e  4a2d              LDR      r2,|L54.228|
000030  b135              CBZ      r5,|L54.64|
000032  2d04              CMP      r5,#4                 ;801
000034  d013              BEQ      |L54.94|
000036  2d08              CMP      r5,#8                 ;801
000038  d020              BEQ      |L54.124|
00003a  2d0c              CMP      r5,#0xc               ;801
00003c  d13b              BNE      |L54.182|
00003e  e02c              B        |L54.154|
                  |L54.64|
000040  6a66              LDR      r6,[r4,#0x24]         ;806
000042  62b0              STR      r0,[r6,#0x28]         ;806
000044  6a60              LDR      r0,[r4,#0x24]         ;809
000046  6302              STR      r2,[r0,#0x30]         ;809
000048  6822              LDR      r2,[r4,#0]            ;812
00004a  6a60              LDR      r0,[r4,#0x24]         ;812
00004c  3234              ADDS     r2,r2,#0x34           ;812
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;815
000054  68c1              LDR      r1,[r0,#0xc]          ;815
000056  f4417100          ORR      r1,r1,#0x200          ;815
00005a  60c1              STR      r1,[r0,#0xc]          ;815
00005c  e02b              B        |L54.182|
                  |L54.94|
00005e  6aa6              LDR      r6,[r4,#0x28]         ;822
000060  62b0              STR      r0,[r6,#0x28]         ;822
000062  6aa0              LDR      r0,[r4,#0x28]         ;825
000064  6302              STR      r2,[r0,#0x30]         ;825
000066  6822              LDR      r2,[r4,#0]            ;828
000068  6aa0              LDR      r0,[r4,#0x28]         ;828
00006a  3238              ADDS     r2,r2,#0x38           ;828
00006c  f7fffffe          BL       HAL_DMA_Start_IT
000070  6820              LDR      r0,[r4,#0]            ;831
000072  68c1              LDR      r1,[r0,#0xc]          ;831
000074  f4416180          ORR      r1,r1,#0x400          ;831
000078  60c1              STR      r1,[r0,#0xc]          ;831
00007a  e01c              B        |L54.182|
                  |L54.124|
00007c  6ae6              LDR      r6,[r4,#0x2c]         ;838
00007e  62b0              STR      r0,[r6,#0x28]         ;838
000080  6ae0              LDR      r0,[r4,#0x2c]         ;841
000082  6302              STR      r2,[r0,#0x30]         ;841
000084  6822              LDR      r2,[r4,#0]            ;844
000086  6ae0              LDR      r0,[r4,#0x2c]         ;844
000088  323c              ADDS     r2,r2,#0x3c           ;844
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  6820              LDR      r0,[r4,#0]            ;847
000090  68c1              LDR      r1,[r0,#0xc]          ;847
000092  f4416100          ORR      r1,r1,#0x800          ;847
000096  60c1              STR      r1,[r0,#0xc]          ;847
000098  e00d              B        |L54.182|
                  |L54.154|
00009a  6b26              LDR      r6,[r4,#0x30]         ;854
00009c  62b0              STR      r0,[r6,#0x28]         ;854
00009e  6b20              LDR      r0,[r4,#0x30]         ;857
0000a0  6302              STR      r2,[r0,#0x30]         ;857
0000a2  6822              LDR      r2,[r4,#0]            ;860
0000a4  6b20              LDR      r0,[r4,#0x30]         ;860
0000a6  3240              ADDS     r2,r2,#0x40           ;860
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  6820              LDR      r0,[r4,#0]            ;863
0000ae  68c1              LDR      r1,[r0,#0xc]          ;863
0000b0  f4415180          ORR      r1,r1,#0x1000         ;863
0000b4  60c1              STR      r1,[r0,#0xc]          ;863
                  |L54.182|
0000b6  2201              MOVS     r2,#1                 ;872
0000b8  4629              MOV      r1,r5                 ;872
0000ba  6820              LDR      r0,[r4,#0]            ;872
0000bc  f7fffffe          BL       TIM_CCxChannelCmd
0000c0  4909              LDR      r1,|L54.232|
0000c2  6820              LDR      r0,[r4,#0]            ;874
0000c4  4288              CMP      r0,r1                 ;874
0000c6  d103              BNE      |L54.208|
0000c8  6c41              LDR      r1,[r0,#0x44]         ;877
0000ca  f4414100          ORR      r1,r1,#0x8000         ;877
0000ce  6441              STR      r1,[r0,#0x44]         ;877
                  |L54.208|
0000d0  6820              LDR      r0,[r4,#0]            ;881
0000d2  6801              LDR      r1,[r0,#0]            ;881
0000d4  f0410101          ORR      r1,r1,#1              ;881
0000d8  6001              STR      r1,[r0,#0]            ;881
0000da  2000              MOVS     r0,#0                 ;884
0000dc  bd70              POP      {r4-r6,pc}
;;;886    
                          ENDP

0000de  0000              DCW      0x0000
                  |L54.224|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.228|
                          DCD      TIM_DMAError
                  |L54.232|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;646    */
;;;647    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;648    {
000002  4604              MOV      r4,r0
;;;649      /* Check the parameters */
;;;650      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;651    
;;;652      switch (Channel)
000004  2900              CMP      r1,#0
;;;653      {
;;;654        case TIM_CHANNEL_1:
;;;655        {
;;;656          /* Enable the TIM Capture/Compare 1 interrupt */
;;;657          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L55.24|
00000a  2904              CMP      r1,#4                 ;652
00000c  d009              BEQ      |L55.34|
00000e  2908              CMP      r1,#8                 ;652
000010  d00c              BEQ      |L55.44|
000012  290c              CMP      r1,#0xc               ;652
000014  d113              BNE      |L55.62|
000016  e00e              B        |L55.54|
                  |L55.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;658        }
;;;659        break;
000020  e00d              B        |L55.62|
                  |L55.34|
;;;660    
;;;661        case TIM_CHANNEL_2:
;;;662        {
;;;663          /* Enable the TIM Capture/Compare 2 interrupt */
;;;664          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;665        }
;;;666        break;
00002a  e008              B        |L55.62|
                  |L55.44|
;;;667    
;;;668        case TIM_CHANNEL_3:
;;;669        {
;;;670          /* Enable the TIM Capture/Compare 3 interrupt */
;;;671          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0400008          ORR      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;672        }
;;;673        break;
000034  e003              B        |L55.62|
                  |L55.54|
;;;674    
;;;675        case TIM_CHANNEL_4:
;;;676        {
;;;677          /* Enable the TIM Capture/Compare 4 interrupt */
;;;678          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0400010          ORR      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L55.62|
;;;679        }
;;;680        break;
;;;681    
;;;682        default:
;;;683        break;
;;;684      }
;;;685    
;;;686      /* Enable the Output compare channel */
;;;687      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;688    
;;;689      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000046  4907              LDR      r1,|L55.100|
000048  6820              LDR      r0,[r4,#0]
00004a  4288              CMP      r0,r1
00004c  d103              BNE      |L55.86|
;;;690      {
;;;691        /* Enable the main output */
;;;692        __HAL_TIM_MOE_ENABLE(htim);
00004e  6c41              LDR      r1,[r0,#0x44]
000050  f4414100          ORR      r1,r1,#0x8000
000054  6441              STR      r1,[r0,#0x44]
                  |L55.86|
;;;693      }
;;;694    
;;;695      /* Enable the Peripheral */
;;;696      __HAL_TIM_ENABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6801              LDR      r1,[r0,#0]
00005a  f0410101          ORR      r1,r1,#1
00005e  6001              STR      r1,[r0,#0]
;;;697    
;;;698      /* Return function status */
;;;699      return HAL_OK;
000060  2000              MOVS     r0,#0
;;;700    }
000062  bd10              POP      {r4,pc}
;;;701    
                          ENDP

                  |L55.100|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;614    */
;;;615    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;616    {
000002  4604              MOV      r4,r0
;;;617      /* Check the parameters */
;;;618      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;619    
;;;620      /* Disable the Output compare channel */
;;;621      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;622    
;;;623      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  480e              LDR      r0,|L56.72|
;;;624      {
;;;625        /* Disable the Main Ouput */
;;;626        __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411211          MOV      r2,#0x1111
000012  6821              LDR      r1,[r4,#0]            ;623
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;623
000018  d109              BNE      |L56.46|
00001a  6a08              LDR      r0,[r1,#0x20]
00001c  4210              TST      r0,r2
00001e  d106              BNE      |L56.46|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4218              TST      r0,r3
000024  d103              BNE      |L56.46|
000026  6c48              LDR      r0,[r1,#0x44]
000028  f4204000          BIC      r0,r0,#0x8000
00002c  6448              STR      r0,[r1,#0x44]
                  |L56.46|
;;;627      }
;;;628    
;;;629      /* Disable the Peripheral */
;;;630      __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d106              BNE      |L56.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4219              TST      r1,r3
00003a  d103              BNE      |L56.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L56.68|
;;;631    
;;;632      /* Return function status */
;;;633      return HAL_OK;
000044  2000              MOVS     r0,#0
;;;634    }
000046  bd10              POP      {r4,pc}
;;;635    
                          ENDP

                  |L56.72|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;897    */
;;;898    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;899    {
000002  4604              MOV      r4,r0
;;;900      /* Check the parameters */
;;;901      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;902    
;;;903      switch (Channel)
000004  2900              CMP      r1,#0
;;;904      {
;;;905        case TIM_CHANNEL_1:
;;;906        {
;;;907          /* Disable the TIM Capture/Compare 1 DMA request */
;;;908          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L57.24|
00000a  2904              CMP      r1,#4                 ;903
00000c  d009              BEQ      |L57.34|
00000e  2908              CMP      r1,#8                 ;903
000010  d00c              BEQ      |L57.44|
000012  290c              CMP      r1,#0xc               ;903
000014  d113              BNE      |L57.62|
000016  e00e              B        |L57.54|
                  |L57.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  60d0              STR      r0,[r2,#0xc]
;;;909        }
;;;910        break;
000020  e00d              B        |L57.62|
                  |L57.34|
;;;911    
;;;912        case TIM_CHANNEL_2:
;;;913        {
;;;914          /* Disable the TIM Capture/Compare 2 DMA request */
;;;915          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f4206080          BIC      r0,r0,#0x400
000028  60d0              STR      r0,[r2,#0xc]
;;;916        }
;;;917        break;
00002a  e008              B        |L57.62|
                  |L57.44|
;;;918    
;;;919        case TIM_CHANNEL_3:
;;;920        {
;;;921          /* Disable the TIM Capture/Compare 3 DMA request */
;;;922          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f4206000          BIC      r0,r0,#0x800
000032  60d0              STR      r0,[r2,#0xc]
;;;923        }
;;;924        break;
000034  e003              B        |L57.62|
                  |L57.54|
;;;925    
;;;926        case TIM_CHANNEL_4:
;;;927        {
;;;928          /* Disable the TIM Capture/Compare 4 interrupt */
;;;929          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f4205080          BIC      r0,r0,#0x1000
00003c  60d0              STR      r0,[r2,#0xc]
                  |L57.62|
;;;930        }
;;;931        break;
;;;932    
;;;933        default:
;;;934        break;
;;;935      }
;;;936    
;;;937      /* Disable the Output compare channel */
;;;938      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;939    
;;;940      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000046  4b10              LDR      r3,|L57.136|
;;;941      {
;;;942        /* Disable the Main Ouput */
;;;943        __HAL_TIM_MOE_DISABLE(htim);
000048  f2411211          MOV      r2,#0x1111
00004c  6820              LDR      r0,[r4,#0]            ;940
00004e  1091              ASRS     r1,r2,#2
000050  4298              CMP      r0,r3                 ;940
000052  d109              BNE      |L57.104|
000054  6a03              LDR      r3,[r0,#0x20]
000056  4213              TST      r3,r2
000058  d106              BNE      |L57.104|
00005a  6a03              LDR      r3,[r0,#0x20]
00005c  420b              TST      r3,r1
00005e  d103              BNE      |L57.104|
000060  6c43              LDR      r3,[r0,#0x44]
000062  f4234300          BIC      r3,r3,#0x8000
000066  6443              STR      r3,[r0,#0x44]
                  |L57.104|
;;;944      }
;;;945    
;;;946      /* Disable the Peripheral */
;;;947      __HAL_TIM_DISABLE(htim);
000068  6820              LDR      r0,[r4,#0]
00006a  6a03              LDR      r3,[r0,#0x20]
00006c  4213              TST      r3,r2
00006e  d106              BNE      |L57.126|
000070  6a02              LDR      r2,[r0,#0x20]
000072  420a              TST      r2,r1
000074  d103              BNE      |L57.126|
000076  6801              LDR      r1,[r0,#0]
000078  f0210101          BIC      r1,r1,#1
00007c  6001              STR      r1,[r0,#0]
                  |L57.126|
;;;948    
;;;949      /* Change the htim state */
;;;950      htim->State = HAL_TIM_STATE_READY;
00007e  2001              MOVS     r0,#1
000080  f884003d          STRB     r0,[r4,#0x3d]
;;;951    
;;;952      /* Return function status */
;;;953      return HAL_OK;
000084  2000              MOVS     r0,#0
;;;954    }
000086  bd10              POP      {r4,pc}
;;;955    
                          ENDP

                  |L57.136|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;712    */
;;;713    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;714    {
000002  4604              MOV      r4,r0
;;;715      /* Check the parameters */
;;;716      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;717    
;;;718      switch (Channel)
000004  2900              CMP      r1,#0
;;;719      {
;;;720        case TIM_CHANNEL_1:
;;;721        {
;;;722          /* Disable the TIM Capture/Compare 1 interrupt */
;;;723          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L58.24|
00000a  2904              CMP      r1,#4                 ;718
00000c  d009              BEQ      |L58.34|
00000e  2908              CMP      r1,#8                 ;718
000010  d00c              BEQ      |L58.44|
000012  290c              CMP      r1,#0xc               ;718
000014  d113              BNE      |L58.62|
000016  e00e              B        |L58.54|
                  |L58.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;724        }
;;;725        break;
000020  e00d              B        |L58.62|
                  |L58.34|
;;;726    
;;;727        case TIM_CHANNEL_2:
;;;728        {
;;;729          /* Disable the TIM Capture/Compare 2 interrupt */
;;;730          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;731        }
;;;732        break;
00002a  e008              B        |L58.62|
                  |L58.44|
;;;733    
;;;734        case TIM_CHANNEL_3:
;;;735        {
;;;736          /* Disable the TIM Capture/Compare 3 interrupt */
;;;737          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0200008          BIC      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;738        }
;;;739        break;
000034  e003              B        |L58.62|
                  |L58.54|
;;;740    
;;;741        case TIM_CHANNEL_4:
;;;742        {
;;;743          /* Disable the TIM Capture/Compare 4 interrupt */
;;;744          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0200010          BIC      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L58.62|
;;;745        }
;;;746        break;
;;;747    
;;;748        default:
;;;749        break;
;;;750      }
;;;751    
;;;752      /* Disable the Output compare channel */
;;;753      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;754    
;;;755      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000046  480f              LDR      r0,|L58.132|
;;;756      {
;;;757        /* Disable the Main Ouput */
;;;758        __HAL_TIM_MOE_DISABLE(htim);
000048  f2411211          MOV      r2,#0x1111
00004c  6821              LDR      r1,[r4,#0]            ;755
00004e  1093              ASRS     r3,r2,#2
000050  4281              CMP      r1,r0                 ;755
000052  d109              BNE      |L58.104|
000054  6a08              LDR      r0,[r1,#0x20]
000056  4210              TST      r0,r2
000058  d106              BNE      |L58.104|
00005a  6a08              LDR      r0,[r1,#0x20]
00005c  4218              TST      r0,r3
00005e  d103              BNE      |L58.104|
000060  6c48              LDR      r0,[r1,#0x44]
000062  f4204000          BIC      r0,r0,#0x8000
000066  6448              STR      r0,[r1,#0x44]
                  |L58.104|
;;;759      }
;;;760    
;;;761      /* Disable the Peripheral */
;;;762      __HAL_TIM_DISABLE(htim);
000068  6820              LDR      r0,[r4,#0]
00006a  6a01              LDR      r1,[r0,#0x20]
00006c  4211              TST      r1,r2
00006e  d106              BNE      |L58.126|
000070  6a01              LDR      r1,[r0,#0x20]
000072  4219              TST      r1,r3
000074  d103              BNE      |L58.126|
000076  6801              LDR      r1,[r0,#0]
000078  f0210101          BIC      r1,r1,#1
00007c  6001              STR      r1,[r0,#0]
                  |L58.126|
;;;763    
;;;764      /* Return function status */
;;;765      return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;766    }
000080  bd10              POP      {r4,pc}
;;;767    
                          ENDP

000082  0000              DCW      0x0000
                  |L58.132|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3199     */
;;;3200   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3201   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  461f              MOV      r7,r3
;;;3202     TIM_OC_InitTypeDef temp1;
;;;3203   
;;;3204     /* Check the parameters */
;;;3205     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3206     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3207   
;;;3208     if(OutputChannel != InputChannel)
00000a  42ba              CMP      r2,r7
00000c  d06b              BEQ      |L59.230|
;;;3209     {
;;;3210     __HAL_LOCK(htim);
00000e  f894003c          LDRB     r0,[r4,#0x3c]
000012  2801              CMP      r0,#1
000014  d015              BEQ      |L59.66|
000016  2601              MOVS     r6,#1
000018  f884603c          STRB     r6,[r4,#0x3c]
;;;3211   
;;;3212     htim->State = HAL_TIM_STATE_BUSY;
00001c  2002              MOVS     r0,#2
00001e  f884003d          STRB     r0,[r4,#0x3d]
;;;3213   
;;;3214     /* Extract the Ouput compare configuration from sConfig structure */
;;;3215     temp1.OCMode = sConfig->OCMode;
000022  6828              LDR      r0,[r5,#0]
000024  9000              STR      r0,[sp,#0]
;;;3216     temp1.Pulse = sConfig->Pulse;
000026  6868              LDR      r0,[r5,#4]
000028  9001              STR      r0,[sp,#4]
;;;3217     temp1.OCPolarity = sConfig->OCPolarity;
00002a  68a8              LDR      r0,[r5,#8]
00002c  9002              STR      r0,[sp,#8]
;;;3218     temp1.OCNPolarity = sConfig->OCNPolarity;
00002e  68e8              LDR      r0,[r5,#0xc]
000030  9003              STR      r0,[sp,#0xc]
;;;3219     temp1.OCIdleState = sConfig->OCIdleState;
000032  6928              LDR      r0,[r5,#0x10]
000034  9005              STR      r0,[sp,#0x14]
;;;3220     temp1.OCNIdleState = sConfig->OCNIdleState;
000036  6968              LDR      r0,[r5,#0x14]
000038  9006              STR      r0,[sp,#0x18]
00003a  b12a              CBZ      r2,|L59.72|
;;;3221   
;;;3222       switch (OutputChannel)
00003c  2a04              CMP      r2,#4
00003e  d10c              BNE      |L59.90|
000040  e007              B        |L59.82|
                  |L59.66|
000042  2002              MOVS     r0,#2                 ;3210
                  |L59.68|
;;;3223     {
;;;3224       case TIM_CHANNEL_1:
;;;3225       {
;;;3226           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3227   
;;;3228         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3229       }
;;;3230       break;
;;;3231       case TIM_CHANNEL_2:
;;;3232       {
;;;3233           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3234   
;;;3235         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3236       }
;;;3237       break;
;;;3238       default:
;;;3239       break;
;;;3240     }
;;;3241     switch (InputChannel)
;;;3242     {
;;;3243       case TIM_CHANNEL_1:
;;;3244       {
;;;3245         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3246   
;;;3247         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3248                           sConfig->ICSelection, sConfig->ICFilter);
;;;3249   
;;;3250         /* Reset the IC1PSC Bits */
;;;3251       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3252   
;;;3253         /* Select the Trigger source */
;;;3254           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3255         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3256   
;;;3257         /* Select the Slave Mode */
;;;3258           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3259         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3260       }
;;;3261       break;
;;;3262       case TIM_CHANNEL_2:
;;;3263       {
;;;3264         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3265   
;;;3266         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3267                    sConfig->ICSelection, sConfig->ICFilter);
;;;3268   
;;;3269         /* Reset the IC2PSC Bits */
;;;3270           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3271   
;;;3272         /* Select the Trigger source */
;;;3273           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3274         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3275   
;;;3276         /* Select the Slave Mode */
;;;3277           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3278         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3279       }
;;;3280       break;
;;;3281   
;;;3282       default:
;;;3283       break;
;;;3284     }
;;;3285   
;;;3286     htim->State = HAL_TIM_STATE_READY;
;;;3287   
;;;3288     __HAL_UNLOCK(htim);
;;;3289   
;;;3290     return HAL_OK;
;;;3291   }
;;;3292     else
;;;3293     {
;;;3294       return HAL_ERROR;
;;;3295     }
;;;3296   }
000044  b007              ADD      sp,sp,#0x1c
000046  bdf0              POP      {r4-r7,pc}
                  |L59.72|
000048  4669              MOV      r1,sp                 ;3228
00004a  6820              LDR      r0,[r4,#0]            ;3228
00004c  f7fffffe          BL       TIM_OC1_SetConfig
000050  e003              B        |L59.90|
                  |L59.82|
000052  4669              MOV      r1,sp                 ;3235
000054  6820              LDR      r0,[r4,#0]            ;3235
000056  f7fffffe          BL       TIM_OC2_SetConfig
                  |L59.90|
00005a  b117              CBZ      r7,|L59.98|
00005c  2f04              CMP      r7,#4                 ;3241
00005e  d13d              BNE      |L59.220|
000060  e01e              B        |L59.160|
                  |L59.98|
000062  3518              ADDS     r5,r5,#0x18           ;3247
000064  6820              LDR      r0,[r4,#0]            ;3247
000066  cd0e              LDM      r5!,{r1-r3}           ;3247
000068  f7fffffe          BL       TIM_TI1_SetConfig
00006c  6820              LDR      r0,[r4,#0]            ;3251
00006e  6981              LDR      r1,[r0,#0x18]         ;3251
000070  f021010c          BIC      r1,r1,#0xc            ;3251
000074  6181              STR      r1,[r0,#0x18]         ;3251
000076  6820              LDR      r0,[r4,#0]            ;3254
000078  6881              LDR      r1,[r0,#8]            ;3254
00007a  f0210170          BIC      r1,r1,#0x70           ;3254
00007e  6081              STR      r1,[r0,#8]            ;3254
000080  6820              LDR      r0,[r4,#0]            ;3255
000082  6881              LDR      r1,[r0,#8]            ;3255
000084  f0410150          ORR      r1,r1,#0x50           ;3255
000088  6081              STR      r1,[r0,#8]            ;3255
00008a  6820              LDR      r0,[r4,#0]            ;3258
00008c  6881              LDR      r1,[r0,#8]            ;3258
00008e  f0210107          BIC      r1,r1,#7              ;3258
000092  6081              STR      r1,[r0,#8]            ;3258
000094  6820              LDR      r0,[r4,#0]            ;3259
000096  6881              LDR      r1,[r0,#8]            ;3259
000098  f0410106          ORR      r1,r1,#6              ;3259
00009c  6081              STR      r1,[r0,#8]            ;3259
00009e  e01d              B        |L59.220|
                  |L59.160|
0000a0  3518              ADDS     r5,r5,#0x18           ;3266
0000a2  6820              LDR      r0,[r4,#0]            ;3266
0000a4  cd0e              LDM      r5!,{r1-r3}           ;3266
0000a6  f7fffffe          BL       TIM_TI2_SetConfig
0000aa  6820              LDR      r0,[r4,#0]            ;3270
0000ac  6981              LDR      r1,[r0,#0x18]         ;3270
0000ae  f4216140          BIC      r1,r1,#0xc00          ;3270
0000b2  6181              STR      r1,[r0,#0x18]         ;3270
0000b4  6820              LDR      r0,[r4,#0]            ;3273
0000b6  6881              LDR      r1,[r0,#8]            ;3273
0000b8  f0210170          BIC      r1,r1,#0x70           ;3273
0000bc  6081              STR      r1,[r0,#8]            ;3273
0000be  6820              LDR      r0,[r4,#0]            ;3274
0000c0  6881              LDR      r1,[r0,#8]            ;3274
0000c2  f0410160          ORR      r1,r1,#0x60           ;3274
0000c6  6081              STR      r1,[r0,#8]            ;3274
0000c8  6820              LDR      r0,[r4,#0]            ;3277
0000ca  6881              LDR      r1,[r0,#8]            ;3277
0000cc  f0210107          BIC      r1,r1,#7              ;3277
0000d0  6081              STR      r1,[r0,#8]            ;3277
0000d2  6820              LDR      r0,[r4,#0]            ;3278
0000d4  6881              LDR      r1,[r0,#8]            ;3278
0000d6  f0410106          ORR      r1,r1,#6              ;3278
0000da  6081              STR      r1,[r0,#8]            ;3278
                  |L59.220|
0000dc  343c              ADDS     r4,r4,#0x3c           ;3286
0000de  7066              STRB     r6,[r4,#1]            ;3286
0000e0  2000              MOVS     r0,#0                 ;3288
0000e2  7020              STRB     r0,[r4,#0]            ;3288
0000e4  e7ae              B        |L59.68|
                  |L59.230|
0000e6  2001              MOVS     r0,#1                 ;3294
0000e8  e7ac              B        |L59.68|
;;;3297   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2015     */
;;;2016   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2017   {
000002  4604              MOV      r4,r0
;;;2018     /* Check the parameters */
;;;2019     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2020   
;;;2021     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2022   
;;;2023     /* Disable the TIM Peripheral Clock */
;;;2024     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L60.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L60.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L60.38|
;;;2025   
;;;2026     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2027     HAL_TIM_OnePulse_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2028   
;;;2029     /* Change TIM state */
;;;2030     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;2031   
;;;2032     /* Release Lock */
;;;2033     __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;2034   
;;;2035     return HAL_OK;
;;;2036   }
000034  bd10              POP      {r4,pc}
;;;2037   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4428     */
;;;4429   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4430   {
;;;4431     return htim->State;
;;;4432   }
000004  4770              BX       lr
;;;4433   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1968     */
;;;1969   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1970   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1971     /* Check the TIM handle allocation */
;;;1972     if(htim == NULL)
000006  2c00              CMP      r4,#0
000008  d003              BEQ      |L62.18|
;;;1973     {
;;;1974       return HAL_ERROR;
;;;1975     }
;;;1976   
;;;1977     /* Check the parameters */
;;;1978     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1979     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1980     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1981     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1982     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1983   
;;;1984     if(htim->State == HAL_TIM_STATE_RESET)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  b110              CBZ      r0,|L62.22|
000010  e007              B        |L62.34|
                  |L62.18|
000012  2001              MOVS     r0,#1                 ;1974
;;;1985     {
;;;1986       /* Allocate lock resource and initialize it */
;;;1987       htim->Lock = HAL_UNLOCKED;
;;;1988       
;;;1989       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1990       HAL_TIM_OnePulse_MspInit(htim);
;;;1991     }
;;;1992   
;;;1993     /* Set the TIM state */
;;;1994     htim->State= HAL_TIM_STATE_BUSY;
;;;1995   
;;;1996     /* Configure the Time base in the One Pulse Mode */
;;;1997     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1998   
;;;1999     /* Reset the OPM Bit */
;;;2000     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2001   
;;;2002     /* Configure the OPM Mode */
;;;2003     htim->Instance->CR1 |= OnePulseMode;
;;;2004   
;;;2005     /* Initialize the TIM state*/
;;;2006     htim->State= HAL_TIM_STATE_READY;
;;;2007   
;;;2008     return HAL_OK;
;;;2009   }
000014  bd70              POP      {r4-r6,pc}
                  |L62.22|
000016  2000              MOVS     r0,#0                 ;1987
000018  f884003c          STRB     r0,[r4,#0x3c]         ;1987
00001c  4620              MOV      r0,r4                 ;1990
00001e  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.34|
000022  2002              MOVS     r0,#2                 ;1994
000024  f884003d          STRB     r0,[r4,#0x3d]         ;1994
000028  1d21              ADDS     r1,r4,#4              ;1997
00002a  6820              LDR      r0,[r4,#0]            ;1997
00002c  f7fffffe          BL       TIM_Base_SetConfig
000030  6820              LDR      r0,[r4,#0]            ;2000
000032  6801              LDR      r1,[r0,#0]            ;2000
000034  f0210108          BIC      r1,r1,#8              ;2000
000038  6001              STR      r1,[r0,#0]            ;2000
00003a  6820              LDR      r0,[r4,#0]            ;2003
00003c  6801              LDR      r1,[r0,#0]            ;2003
00003e  4329              ORRS     r1,r1,r5              ;2003
000040  6001              STR      r1,[r0,#0]            ;2003
000042  2001              MOVS     r0,#1                 ;2006
000044  f884003d          STRB     r0,[r4,#0x3d]         ;2006
000048  2000              MOVS     r0,#0                 ;2008
00004a  bd70              POP      {r4-r6,pc}
;;;2010   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2056     */
;;;2057   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2058   {
;;;2059     /* Prevent unused argument(s) compilation warning */
;;;2060     UNUSED(htim);
;;;2061     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2062               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2063      */
;;;2064   }
;;;2065   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2042     */
;;;2043   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2044   {
;;;2045     /* Prevent unused argument(s) compilation warning */
;;;2046     UNUSED(htim);
;;;2047     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2048               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2049      */
;;;2050   }
;;;2051   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2074   */
;;;2075   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2076   {
000002  4604              MOV      r4,r0
;;;2077     /* Prevent unused argument(s) compilation warning */
;;;2078     UNUSED(OutputChannel);
;;;2079   
;;;2080     /* Enable the Capture compare and the Input Capture channels 
;;;2081       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2082       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2083       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2084       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2085   
;;;2086       No need to enable the counter, it's enabled automatically by hardware 
;;;2087       (the counter starts in response to a stimulus and generate a pulse */
;;;2088   
;;;2089     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2090     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2091   
;;;2092     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  4904              LDR      r1,|L65.44|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d103              BNE      |L65.40|
;;;2093     {
;;;2094       /* Enable the main output */
;;;2095       __HAL_TIM_MOE_ENABLE(htim);
000020  6c41              LDR      r1,[r0,#0x44]
000022  f4414100          ORR      r1,r1,#0x8000
000026  6441              STR      r1,[r0,#0x44]
                  |L65.40|
;;;2096     }
;;;2097   
;;;2098     /* Return function status */
;;;2099     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;2100   }
00002a  bd10              POP      {r4,pc}
;;;2101   
                          ENDP

                  |L65.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2146   */
;;;2147   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2148   {
000002  4604              MOV      r4,r0
;;;2149     /* Prevent unused argument(s) compilation warning */
;;;2150     UNUSED(OutputChannel);
;;;2151   
;;;2152     /* Enable the Capture compare and the Input Capture channels 
;;;2153       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2154       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2155       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2156       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2157   
;;;2158       No need to enable the counter, it's enabled automatically by hardware 
;;;2159       (the counter starts in response to a stimulus and generate a pulse */
;;;2160   
;;;2161     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2162     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2163   
;;;2164     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2165     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0410104          ORR      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2166   
;;;2167     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000018  2201              MOVS     r2,#1
00001a  2100              MOVS     r1,#0
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2168     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000022  2201              MOVS     r2,#1
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2169   
;;;2170     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4904              LDR      r1,|L66.64|
00002e  6820              LDR      r0,[r4,#0]
000030  4288              CMP      r0,r1
000032  d103              BNE      |L66.60|
;;;2171     {
;;;2172       /* Enable the main output */
;;;2173       __HAL_TIM_MOE_ENABLE(htim);
000034  6c41              LDR      r1,[r0,#0x44]
000036  f4414100          ORR      r1,r1,#0x8000
00003a  6441              STR      r1,[r0,#0x44]
                  |L66.60|
;;;2174     }
;;;2175   
;;;2176     /* Return function status */
;;;2177     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2178   }
00003e  bd10              POP      {r4,pc}
;;;2179   
                          ENDP

                  |L66.64|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2110   */
;;;2111   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2112   {
000002  4604              MOV      r4,r0
;;;2113     /* Prevent unused argument(s) compilation warning */
;;;2114     UNUSED(OutputChannel);
;;;2115   
;;;2116     /* Disable the Capture compare and the Input Capture channels
;;;2117     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2118     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2119     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2120     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2121   
;;;2122     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2123     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2124   
;;;2125     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  480e              LDR      r0,|L67.84|
;;;2126     {
;;;2127       /* Disable the Main Ouput */
;;;2128       __HAL_TIM_MOE_DISABLE(htim);
00001a  f2411211          MOV      r2,#0x1111
00001e  6821              LDR      r1,[r4,#0]            ;2125
000020  1093              ASRS     r3,r2,#2
000022  4281              CMP      r1,r0                 ;2125
000024  d109              BNE      |L67.58|
000026  6a08              LDR      r0,[r1,#0x20]
000028  4210              TST      r0,r2
00002a  d106              BNE      |L67.58|
00002c  6a08              LDR      r0,[r1,#0x20]
00002e  4218              TST      r0,r3
000030  d103              BNE      |L67.58|
000032  6c48              LDR      r0,[r1,#0x44]
000034  f4204000          BIC      r0,r0,#0x8000
000038  6448              STR      r0,[r1,#0x44]
                  |L67.58|
;;;2129     }
;;;2130   
;;;2131     /* Disable the Peripheral */
;;;2132     __HAL_TIM_DISABLE(htim);
00003a  6820              LDR      r0,[r4,#0]
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4211              TST      r1,r2
000040  d106              BNE      |L67.80|
000042  6a01              LDR      r1,[r0,#0x20]
000044  4219              TST      r1,r3
000046  d103              BNE      |L67.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L67.80|
;;;2133   
;;;2134     /* Return function status */
;;;2135     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;2136   }
000052  bd10              POP      {r4,pc}
;;;2137   
                          ENDP

                  |L67.84|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2188   */
;;;2189   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2190   {
000002  4604              MOV      r4,r0
;;;2191     /* Prevent unused argument(s) compilation warning */
;;;2192     UNUSED(OutputChannel);
;;;2193   
;;;2194     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2195     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0210102          BIC      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2196   
;;;2197     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2198     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210104          BIC      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2199   
;;;2200     /* Disable the Capture compare and the Input Capture channels 
;;;2201     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2202     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2203     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2204     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2205     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2206     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000022  2200              MOVS     r2,#0
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2207   
;;;2208     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4b0e              LDR      r3,|L68.104|
;;;2209     {
;;;2210       /* Disable the Main Ouput */
;;;2211       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411111          MOV      r1,#0x1111
000032  6820              LDR      r0,[r4,#0]            ;2208
000034  108a              ASRS     r2,r1,#2
000036  4298              CMP      r0,r3                 ;2208
000038  d109              BNE      |L68.78|
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  420b              TST      r3,r1
00003e  d106              BNE      |L68.78|
000040  6a03              LDR      r3,[r0,#0x20]
000042  4213              TST      r3,r2
000044  d103              BNE      |L68.78|
000046  6c43              LDR      r3,[r0,#0x44]
000048  f4234300          BIC      r3,r3,#0x8000
00004c  6443              STR      r3,[r0,#0x44]
                  |L68.78|
;;;2212     }
;;;2213   
;;;2214     /* Disable the Peripheral */
;;;2215      __HAL_TIM_DISABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6a03              LDR      r3,[r0,#0x20]
000052  420b              TST      r3,r1
000054  d106              BNE      |L68.100|
000056  6a01              LDR      r1,[r0,#0x20]
000058  4211              TST      r1,r2
00005a  d103              BNE      |L68.100|
00005c  6801              LDR      r1,[r0,#0]
00005e  f0210101          BIC      r1,r1,#1
000062  6001              STR      r1,[r0,#0]
                  |L68.100|
;;;2216   
;;;2217     /* Return function status */
;;;2218     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2219   }
000066  bd10              POP      {r4,pc}
;;;2220   
                          ENDP

                  |L68.104|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3099     */
;;;3100   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3101   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3102     __HAL_LOCK(htim);
000006  f894003c          LDRB     r0,[r4,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d00d              BEQ      |L69.42|
00000e  2601              MOVS     r6,#1
000010  f884603c          STRB     r6,[r4,#0x3c]
;;;3103   
;;;3104     /* Check the parameters */
;;;3105     assert_param(IS_TIM_CHANNELS(Channel));
;;;3106     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3107     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3108     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3109   
;;;3110     htim->State = HAL_TIM_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f884003d          STRB     r0,[r4,#0x3d]
00001a  b142              CBZ      r2,|L69.46|
;;;3111   
;;;3112     switch (Channel)
00001c  2a04              CMP      r2,#4
00001e  d01a              BEQ      |L69.86|
000020  2a08              CMP      r2,#8
000022  d02d              BEQ      |L69.128|
000024  2a0c              CMP      r2,#0xc
000026  d153              BNE      |L69.208|
000028  e03e              B        |L69.168|
                  |L69.42|
00002a  2002              MOVS     r0,#2                 ;3102
;;;3113     {
;;;3114       case TIM_CHANNEL_1:
;;;3115       {
;;;3116         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3117         /* Configure the Channel 1 in PWM mode */
;;;3118         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3119   
;;;3120         /* Set the Preload enable bit for channel1 */
;;;3121         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3122   
;;;3123         /* Configure the Output Fast mode */
;;;3124         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3125         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3126       }
;;;3127       break;
;;;3128   
;;;3129       case TIM_CHANNEL_2:
;;;3130       {
;;;3131         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3132         /* Configure the Channel 2 in PWM mode */
;;;3133         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3134   
;;;3135         /* Set the Preload enable bit for channel2 */
;;;3136         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3137   
;;;3138         /* Configure the Output Fast mode */
;;;3139         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3140         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3141       }
;;;3142       break;
;;;3143   
;;;3144       case TIM_CHANNEL_3:
;;;3145       {
;;;3146         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3147         /* Configure the Channel 3 in PWM mode */
;;;3148         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3149   
;;;3150         /* Set the Preload enable bit for channel3 */
;;;3151         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3152   
;;;3153        /* Configure the Output Fast mode */
;;;3154         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3155         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3156       }
;;;3157       break;
;;;3158   
;;;3159       case TIM_CHANNEL_4:
;;;3160       {
;;;3161         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3162         /* Configure the Channel 4 in PWM mode */
;;;3163         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3164   
;;;3165         /* Set the Preload enable bit for channel4 */
;;;3166         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3167   
;;;3168        /* Configure the Output Fast mode */
;;;3169         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3170         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
;;;3171       }
;;;3172       break;
;;;3173   
;;;3174       default:
;;;3175       break;
;;;3176     }
;;;3177   
;;;3178     htim->State = HAL_TIM_STATE_READY;
;;;3179   
;;;3180     __HAL_UNLOCK(htim);
;;;3181   
;;;3182     return HAL_OK;
;;;3183   }
00002c  bd70              POP      {r4-r6,pc}
                  |L69.46|
00002e  4629              MOV      r1,r5                 ;3118
000030  6820              LDR      r0,[r4,#0]            ;3118
000032  f7fffffe          BL       TIM_OC1_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;3121
000038  6981              LDR      r1,[r0,#0x18]         ;3121
00003a  f0410108          ORR      r1,r1,#8              ;3121
00003e  6181              STR      r1,[r0,#0x18]         ;3121
000040  6820              LDR      r0,[r4,#0]            ;3124
000042  6981              LDR      r1,[r0,#0x18]         ;3124
000044  f0210104          BIC      r1,r1,#4              ;3124
000048  6181              STR      r1,[r0,#0x18]         ;3124
00004a  6820              LDR      r0,[r4,#0]            ;3125
00004c  6981              LDR      r1,[r0,#0x18]         ;3125
00004e  692a              LDR      r2,[r5,#0x10]         ;3125
000050  4311              ORRS     r1,r1,r2              ;3125
000052  6181              STR      r1,[r0,#0x18]         ;3125
000054  e03c              B        |L69.208|
                  |L69.86|
000056  4629              MOV      r1,r5                 ;3133
000058  6820              LDR      r0,[r4,#0]            ;3133
00005a  f7fffffe          BL       TIM_OC2_SetConfig
00005e  6820              LDR      r0,[r4,#0]            ;3136
000060  6981              LDR      r1,[r0,#0x18]         ;3136
000062  f4416100          ORR      r1,r1,#0x800          ;3136
000066  6181              STR      r1,[r0,#0x18]         ;3136
000068  6820              LDR      r0,[r4,#0]            ;3139
00006a  6981              LDR      r1,[r0,#0x18]         ;3139
00006c  f4216180          BIC      r1,r1,#0x400          ;3139
000070  6181              STR      r1,[r0,#0x18]         ;3139
000072  6820              LDR      r0,[r4,#0]            ;3140
000074  6981              LDR      r1,[r0,#0x18]         ;3140
000076  692a              LDR      r2,[r5,#0x10]         ;3140
000078  ea412102          ORR      r1,r1,r2,LSL #8       ;3140
00007c  6181              STR      r1,[r0,#0x18]         ;3140
00007e  e027              B        |L69.208|
                  |L69.128|
000080  4629              MOV      r1,r5                 ;3148
000082  6820              LDR      r0,[r4,#0]            ;3148
000084  f7fffffe          BL       TIM_OC3_SetConfig
000088  6820              LDR      r0,[r4,#0]            ;3151
00008a  69c1              LDR      r1,[r0,#0x1c]         ;3151
00008c  f0410108          ORR      r1,r1,#8              ;3151
000090  61c1              STR      r1,[r0,#0x1c]         ;3151
000092  6820              LDR      r0,[r4,#0]            ;3154
000094  69c1              LDR      r1,[r0,#0x1c]         ;3154
000096  f0210104          BIC      r1,r1,#4              ;3154
00009a  61c1              STR      r1,[r0,#0x1c]         ;3154
00009c  6820              LDR      r0,[r4,#0]            ;3155
00009e  69c1              LDR      r1,[r0,#0x1c]         ;3155
0000a0  692a              LDR      r2,[r5,#0x10]         ;3155
0000a2  4311              ORRS     r1,r1,r2              ;3155
0000a4  61c1              STR      r1,[r0,#0x1c]         ;3155
0000a6  e013              B        |L69.208|
                  |L69.168|
0000a8  4629              MOV      r1,r5                 ;3163
0000aa  6820              LDR      r0,[r4,#0]            ;3163
0000ac  f7fffffe          BL       TIM_OC4_SetConfig
0000b0  6820              LDR      r0,[r4,#0]            ;3166
0000b2  69c1              LDR      r1,[r0,#0x1c]         ;3166
0000b4  f4416100          ORR      r1,r1,#0x800          ;3166
0000b8  61c1              STR      r1,[r0,#0x1c]         ;3166
0000ba  6820              LDR      r0,[r4,#0]            ;3169
0000bc  69c1              LDR      r1,[r0,#0x1c]         ;3169
0000be  f4216180          BIC      r1,r1,#0x400          ;3169
0000c2  61c1              STR      r1,[r0,#0x1c]         ;3169
0000c4  6820              LDR      r0,[r4,#0]            ;3170
0000c6  69c1              LDR      r1,[r0,#0x1c]         ;3170
0000c8  692a              LDR      r2,[r5,#0x10]         ;3170
0000ca  ea412102          ORR      r1,r1,r2,LSL #8       ;3170
0000ce  61c1              STR      r1,[r0,#0x1c]         ;3170
                  |L69.208|
0000d0  343c              ADDS     r4,r4,#0x3c           ;3178
0000d2  7066              STRB     r6,[r4,#1]            ;3178
0000d4  2000              MOVS     r0,#0                 ;3180
0000d6  7020              STRB     r0,[r4,#0]            ;3180
0000d8  bd70              POP      {r4-r6,pc}
;;;3184   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1026     */
;;;1027   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1028   {
000002  4604              MOV      r4,r0
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1031   
;;;1032     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1033   
;;;1034     /* Disable the TIM Peripheral Clock */
;;;1035     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L70.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L70.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L70.38|
;;;1036   
;;;1037     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1038     HAL_TIM_PWM_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1039   
;;;1040     /* Change TIM state */
;;;1041     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7060              STRB     r0,[r4,#1]
;;;1042   
;;;1043     /* Release Lock */
;;;1044     __HAL_UNLOCK(htim);
000032  7020              STRB     r0,[r4,#0]
;;;1045   
;;;1046     return HAL_OK;
;;;1047   }
000034  bd10              POP      {r4,pc}
;;;1048   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4408     */
;;;4409   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4410   {
;;;4411     return htim->State;
;;;4412   }
000004  4770              BX       lr
;;;4413   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;986      */
;;;987    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;988    {
000002  4604              MOV      r4,r0
;;;989      /* Check the TIM handle allocation */
;;;990      if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L72.16|
;;;991      {
;;;992        return HAL_ERROR;
;;;993      }
;;;994    
;;;995      /* Check the parameters */
;;;996      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;997      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;998      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;999      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1000   
;;;1001     if(htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L72.20|
00000e  e007              B        |L72.32|
                  |L72.16|
000010  2001              MOVS     r0,#1                 ;992
;;;1002     {
;;;1003       /* Allocate lock resource and initialize it */
;;;1004       htim->Lock = HAL_UNLOCKED;
;;;1005       
;;;1006       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1007       HAL_TIM_PWM_MspInit(htim);
;;;1008     }
;;;1009   
;;;1010     /* Set the TIM state */
;;;1011     htim->State= HAL_TIM_STATE_BUSY;
;;;1012   
;;;1013     /* Init the base time for the PWM */
;;;1014     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1015   
;;;1016     /* Initialize the TIM state*/
;;;1017     htim->State= HAL_TIM_STATE_READY;
;;;1018   
;;;1019     return HAL_OK;
;;;1020   }
000012  bd10              POP      {r4,pc}
                  |L72.20|
000014  2000              MOVS     r0,#0                 ;1004
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1004
00001a  4620              MOV      r0,r4                 ;1007
00001c  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.32|
000020  2002              MOVS     r0,#2                 ;1011
000022  f884003d          STRB     r0,[r4,#0x3d]         ;1011
000026  1d21              ADDS     r1,r4,#4              ;1014
000028  6820              LDR      r0,[r4,#0]            ;1014
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;1017
000030  f884003d          STRB     r0,[r4,#0x3d]         ;1017
000034  2000              MOVS     r0,#0                 ;1019
000036  bd10              POP      {r4,pc}
;;;1021   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1067     */
;;;1068   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1069   {
;;;1070     /* Prevent unused argument(s) compilation warning */
;;;1071     UNUSED(htim);
;;;1072     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1073               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1074      */
;;;1075   }
;;;1076   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1053     */
;;;1054   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1055   {
;;;1056     /* Prevent unused argument(s) compilation warning */
;;;1057     UNUSED(htim);
;;;1058     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1059               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1060      */
;;;1061   }
;;;1062   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4327     */
;;;4328   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4329   {
;;;4330     /* Prevent unused argument(s) compilation warning */
;;;4331     UNUSED(htim);
;;;4332     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4333               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4334      */
;;;4335   }
;;;4336   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1087   */
;;;1088   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1089   {
000002  4604              MOV      r4,r0
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1092   
;;;1093     /* Enable the Capture compare channel */
;;;1094     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  2201              MOVS     r2,#1
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1095   
;;;1096     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4907              LDR      r1,|L76.44|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d103              BNE      |L76.28|
;;;1097     {
;;;1098       /* Enable the main output */
;;;1099       __HAL_TIM_MOE_ENABLE(htim);
000014  6c41              LDR      r1,[r0,#0x44]
000016  f4414100          ORR      r1,r1,#0x8000
00001a  6441              STR      r1,[r0,#0x44]
                  |L76.28|
;;;1100     }
;;;1101   
;;;1102     /* Enable the Peripheral */
;;;1103     __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410101          ORR      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
;;;1104   
;;;1105     /* Return function status */
;;;1106     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;1107   }
000028  bd10              POP      {r4,pc}
;;;1108   
                          ENDP

00002a  0000              DCW      0x0000
                  |L76.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1288   */
;;;1289   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1290   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  4611              MOV      r1,r2
;;;1291     /* Check the parameters */
;;;1292     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1293   
;;;1294     if((htim->State == HAL_TIM_STATE_BUSY))
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2802              CMP      r0,#2
00000e  d004              BEQ      |L77.26|
;;;1295     {
;;;1296        return HAL_BUSY;
;;;1297     }
;;;1298     else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L77.30|
000018  e008              B        |L77.44|
                  |L77.26|
00001a  2002              MOVS     r0,#2                 ;1296
;;;1299     {
;;;1300       if(((uint32_t)pData == 0U) && (Length > 0U))
;;;1301       {
;;;1302         return HAL_ERROR;
;;;1303       }
;;;1304       else
;;;1305       {
;;;1306         htim->State = HAL_TIM_STATE_BUSY;
;;;1307       }
;;;1308     }
;;;1309     switch (Channel)
;;;1310     {
;;;1311       case TIM_CHANNEL_1:
;;;1312       {
;;;1313         /* Set the DMA Period elapsed callback */
;;;1314         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1315   
;;;1316         /* Set the DMA error callback */
;;;1317         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1318   
;;;1319         /* Enable the DMA channel */
;;;1320         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1321   
;;;1322         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1323         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1324       }
;;;1325       break;
;;;1326   
;;;1327       case TIM_CHANNEL_2:
;;;1328       {
;;;1329         /* Set the DMA Period elapsed callback */
;;;1330         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1331   
;;;1332         /* Set the DMA error callback */
;;;1333         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1334   
;;;1335         /* Enable the DMA channel */
;;;1336         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1337   
;;;1338         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1339         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1340       }
;;;1341       break;
;;;1342   
;;;1343       case TIM_CHANNEL_3:
;;;1344       {
;;;1345         /* Set the DMA Period elapsed callback */
;;;1346         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1347   
;;;1348         /* Set the DMA error callback */
;;;1349         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1350   
;;;1351         /* Enable the DMA channel */
;;;1352         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1353   
;;;1354         /* Enable the TIM Output Capture/Compare 3 request */
;;;1355         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1356       }
;;;1357       break;
;;;1358   
;;;1359       case TIM_CHANNEL_4:
;;;1360       {
;;;1361        /* Set the DMA Period elapsed callback */
;;;1362         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1363   
;;;1364         /* Set the DMA error callback */
;;;1365         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1366   
;;;1367         /* Enable the DMA channel */
;;;1368         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1369   
;;;1370         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1371         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1372       }
;;;1373       break;
;;;1374   
;;;1375       default:
;;;1376       break;
;;;1377     }
;;;1378   
;;;1379     /* Enable the Capture compare channel */
;;;1380     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1381   
;;;1382     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1383     {
;;;1384       /* Enable the main output */
;;;1385       __HAL_TIM_MOE_ENABLE(htim);
;;;1386     }
;;;1387   
;;;1388     /* Enable the Peripheral */
;;;1389     __HAL_TIM_ENABLE(htim);
;;;1390   
;;;1391     /* Return function status */
;;;1392     return HAL_OK;
;;;1393   }
00001c  bd70              POP      {r4-r6,pc}
                  |L77.30|
00001e  b911              CBNZ     r1,|L77.38|
000020  b10b              CBZ      r3,|L77.38|
000022  2001              MOVS     r0,#1                 ;1302
000024  bd70              POP      {r4-r6,pc}
                  |L77.38|
000026  2002              MOVS     r0,#2                 ;1306
000028  f884003d          STRB     r0,[r4,#0x3d]         ;1306
                  |L77.44|
00002c  482c              LDR      r0,|L77.224|
00002e  4a2d              LDR      r2,|L77.228|
000030  b135              CBZ      r5,|L77.64|
000032  2d04              CMP      r5,#4                 ;1309
000034  d013              BEQ      |L77.94|
000036  2d08              CMP      r5,#8                 ;1309
000038  d020              BEQ      |L77.124|
00003a  2d0c              CMP      r5,#0xc               ;1309
00003c  d13b              BNE      |L77.182|
00003e  e02c              B        |L77.154|
                  |L77.64|
000040  6a66              LDR      r6,[r4,#0x24]         ;1314
000042  62b0              STR      r0,[r6,#0x28]         ;1314
000044  6a60              LDR      r0,[r4,#0x24]         ;1317
000046  6302              STR      r2,[r0,#0x30]         ;1317
000048  6822              LDR      r2,[r4,#0]            ;1320
00004a  6a60              LDR      r0,[r4,#0x24]         ;1320
00004c  3234              ADDS     r2,r2,#0x34           ;1320
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;1323
000054  68c1              LDR      r1,[r0,#0xc]          ;1323
000056  f4417100          ORR      r1,r1,#0x200          ;1323
00005a  60c1              STR      r1,[r0,#0xc]          ;1323
00005c  e02b              B        |L77.182|
                  |L77.94|
00005e  6aa6              LDR      r6,[r4,#0x28]         ;1330
000060  62b0              STR      r0,[r6,#0x28]         ;1330
000062  6aa0              LDR      r0,[r4,#0x28]         ;1333
000064  6302              STR      r2,[r0,#0x30]         ;1333
000066  6822              LDR      r2,[r4,#0]            ;1336
000068  6aa0              LDR      r0,[r4,#0x28]         ;1336
00006a  3238              ADDS     r2,r2,#0x38           ;1336
00006c  f7fffffe          BL       HAL_DMA_Start_IT
000070  6820              LDR      r0,[r4,#0]            ;1339
000072  68c1              LDR      r1,[r0,#0xc]          ;1339
000074  f4416180          ORR      r1,r1,#0x400          ;1339
000078  60c1              STR      r1,[r0,#0xc]          ;1339
00007a  e01c              B        |L77.182|
                  |L77.124|
00007c  6ae6              LDR      r6,[r4,#0x2c]         ;1346
00007e  62b0              STR      r0,[r6,#0x28]         ;1346
000080  6ae0              LDR      r0,[r4,#0x2c]         ;1349
000082  6302              STR      r2,[r0,#0x30]         ;1349
000084  6822              LDR      r2,[r4,#0]            ;1352
000086  6ae0              LDR      r0,[r4,#0x2c]         ;1352
000088  323c              ADDS     r2,r2,#0x3c           ;1352
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  6820              LDR      r0,[r4,#0]            ;1355
000090  68c1              LDR      r1,[r0,#0xc]          ;1355
000092  f4416100          ORR      r1,r1,#0x800          ;1355
000096  60c1              STR      r1,[r0,#0xc]          ;1355
000098  e00d              B        |L77.182|
                  |L77.154|
00009a  6b26              LDR      r6,[r4,#0x30]         ;1362
00009c  62b0              STR      r0,[r6,#0x28]         ;1362
00009e  6b20              LDR      r0,[r4,#0x30]         ;1365
0000a0  6302              STR      r2,[r0,#0x30]         ;1365
0000a2  6822              LDR      r2,[r4,#0]            ;1368
0000a4  6b20              LDR      r0,[r4,#0x30]         ;1368
0000a6  3240              ADDS     r2,r2,#0x40           ;1368
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  6820              LDR      r0,[r4,#0]            ;1371
0000ae  68c1              LDR      r1,[r0,#0xc]          ;1371
0000b0  f4415180          ORR      r1,r1,#0x1000         ;1371
0000b4  60c1              STR      r1,[r0,#0xc]          ;1371
                  |L77.182|
0000b6  2201              MOVS     r2,#1                 ;1380
0000b8  4629              MOV      r1,r5                 ;1380
0000ba  6820              LDR      r0,[r4,#0]            ;1380
0000bc  f7fffffe          BL       TIM_CCxChannelCmd
0000c0  4909              LDR      r1,|L77.232|
0000c2  6820              LDR      r0,[r4,#0]            ;1382
0000c4  4288              CMP      r0,r1                 ;1382
0000c6  d103              BNE      |L77.208|
0000c8  6c41              LDR      r1,[r0,#0x44]         ;1385
0000ca  f4414100          ORR      r1,r1,#0x8000         ;1385
0000ce  6441              STR      r1,[r0,#0x44]         ;1385
                  |L77.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1389
0000d2  6801              LDR      r1,[r0,#0]            ;1389
0000d4  f0410101          ORR      r1,r1,#1              ;1389
0000d8  6001              STR      r1,[r0,#0]            ;1389
0000da  2000              MOVS     r0,#0                 ;1392
0000dc  bd70              POP      {r4-r6,pc}
;;;1394   
                          ENDP

0000de  0000              DCW      0x0000
                  |L77.224|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.228|
                          DCD      TIM_DMAError
                  |L77.232|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1154   */
;;;1155   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1156   {
000002  4604              MOV      r4,r0
;;;1157     /* Check the parameters */
;;;1158     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1159   
;;;1160     switch (Channel)
000004  2900              CMP      r1,#0
;;;1161     {
;;;1162       case TIM_CHANNEL_1:
;;;1163       {
;;;1164         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1165         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L78.24|
00000a  2904              CMP      r1,#4                 ;1160
00000c  d009              BEQ      |L78.34|
00000e  2908              CMP      r1,#8                 ;1160
000010  d00c              BEQ      |L78.44|
000012  290c              CMP      r1,#0xc               ;1160
000014  d113              BNE      |L78.62|
000016  e00e              B        |L78.54|
                  |L78.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;1166       }
;;;1167       break;
000020  e00d              B        |L78.62|
                  |L78.34|
;;;1168   
;;;1169       case TIM_CHANNEL_2:
;;;1170       {
;;;1171         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1172         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;1173       }
;;;1174       break;
00002a  e008              B        |L78.62|
                  |L78.44|
;;;1175   
;;;1176       case TIM_CHANNEL_3:
;;;1177       {
;;;1178         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1179         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0400008          ORR      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;1180       }
;;;1181       break;
000034  e003              B        |L78.62|
                  |L78.54|
;;;1182   
;;;1183       case TIM_CHANNEL_4:
;;;1184       {
;;;1185         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1186         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0400010          ORR      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L78.62|
;;;1187       }
;;;1188       break;
;;;1189   
;;;1190       default:
;;;1191       break;
;;;1192     }
;;;1193   
;;;1194     /* Enable the Capture compare channel */
;;;1195     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;1196   
;;;1197     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000046  4907              LDR      r1,|L78.100|
000048  6820              LDR      r0,[r4,#0]
00004a  4288              CMP      r0,r1
00004c  d103              BNE      |L78.86|
;;;1198     {
;;;1199       /* Enable the main output */
;;;1200       __HAL_TIM_MOE_ENABLE(htim);
00004e  6c41              LDR      r1,[r0,#0x44]
000050  f4414100          ORR      r1,r1,#0x8000
000054  6441              STR      r1,[r0,#0x44]
                  |L78.86|
;;;1201     }
;;;1202   
;;;1203     /* Enable the Peripheral */
;;;1204     __HAL_TIM_ENABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6801              LDR      r1,[r0,#0]
00005a  f0410101          ORR      r1,r1,#1
00005e  6001              STR      r1,[r0,#0]
;;;1205   
;;;1206     /* Return function status */
;;;1207     return HAL_OK;
000060  2000              MOVS     r0,#0
;;;1208   }
000062  bd10              POP      {r4,pc}
;;;1209   
                          ENDP

                  |L78.100|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1119   */
;;;1120   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1121   {
000002  4604              MOV      r4,r0
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1124   
;;;1125     /* Disable the Capture compare channel */
;;;1126     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1127   
;;;1128     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4810              LDR      r0,|L79.80|
;;;1129     {
;;;1130       /* Disable the Main Ouput */
;;;1131       __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411211          MOV      r2,#0x1111
000012  6821              LDR      r1,[r4,#0]            ;1128
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;1128
000018  d109              BNE      |L79.46|
00001a  6a08              LDR      r0,[r1,#0x20]
00001c  4210              TST      r0,r2
00001e  d106              BNE      |L79.46|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4218              TST      r0,r3
000024  d103              BNE      |L79.46|
000026  6c48              LDR      r0,[r1,#0x44]
000028  f4204000          BIC      r0,r0,#0x8000
00002c  6448              STR      r0,[r1,#0x44]
                  |L79.46|
;;;1132     }
;;;1133   
;;;1134     /* Disable the Peripheral */
;;;1135     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d106              BNE      |L79.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4219              TST      r1,r3
00003a  d103              BNE      |L79.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L79.68|
;;;1136   
;;;1137     /* Change the htim state */
;;;1138     htim->State = HAL_TIM_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;1139   
;;;1140     /* Return function status */
;;;1141     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1142   }
00004c  bd10              POP      {r4,pc}
;;;1143   
                          ENDP

00004e  0000              DCW      0x0000
                  |L79.80|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1405   */
;;;1406   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1407   {
000002  4604              MOV      r4,r0
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1410   
;;;1411     switch (Channel)
000004  2900              CMP      r1,#0
;;;1412     {
;;;1413       case TIM_CHANNEL_1:
;;;1414       {
;;;1415         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1416         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L80.24|
00000a  2904              CMP      r1,#4                 ;1411
00000c  d009              BEQ      |L80.34|
00000e  2908              CMP      r1,#8                 ;1411
000010  d00c              BEQ      |L80.44|
000012  290c              CMP      r1,#0xc               ;1411
000014  d113              BNE      |L80.62|
000016  e00e              B        |L80.54|
                  |L80.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  60d0              STR      r0,[r2,#0xc]
;;;1417       }
;;;1418       break;
000020  e00d              B        |L80.62|
                  |L80.34|
;;;1419   
;;;1420       case TIM_CHANNEL_2:
;;;1421       {
;;;1422         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1423         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f4206080          BIC      r0,r0,#0x400
000028  60d0              STR      r0,[r2,#0xc]
;;;1424       }
;;;1425       break;
00002a  e008              B        |L80.62|
                  |L80.44|
;;;1426   
;;;1427       case TIM_CHANNEL_3:
;;;1428       {
;;;1429         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1430         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f4206000          BIC      r0,r0,#0x800
000032  60d0              STR      r0,[r2,#0xc]
;;;1431       }
;;;1432       break;
000034  e003              B        |L80.62|
                  |L80.54|
;;;1433   
;;;1434       case TIM_CHANNEL_4:
;;;1435       {
;;;1436         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1437         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f4205080          BIC      r0,r0,#0x1000
00003c  60d0              STR      r0,[r2,#0xc]
                  |L80.62|
;;;1438       }
;;;1439       break;
;;;1440   
;;;1441       default:
;;;1442       break;
;;;1443     }
;;;1444   
;;;1445     /* Disable the Capture compare channel */
;;;1446     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;1447   
;;;1448     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000046  4b10              LDR      r3,|L80.136|
;;;1449     {
;;;1450       /* Disable the Main Ouput */
;;;1451       __HAL_TIM_MOE_DISABLE(htim);
000048  f2411211          MOV      r2,#0x1111
00004c  6820              LDR      r0,[r4,#0]            ;1448
00004e  1091              ASRS     r1,r2,#2
000050  4298              CMP      r0,r3                 ;1448
000052  d109              BNE      |L80.104|
000054  6a03              LDR      r3,[r0,#0x20]
000056  4213              TST      r3,r2
000058  d106              BNE      |L80.104|
00005a  6a03              LDR      r3,[r0,#0x20]
00005c  420b              TST      r3,r1
00005e  d103              BNE      |L80.104|
000060  6c43              LDR      r3,[r0,#0x44]
000062  f4234300          BIC      r3,r3,#0x8000
000066  6443              STR      r3,[r0,#0x44]
                  |L80.104|
;;;1452     }
;;;1453   
;;;1454     /* Disable the Peripheral */
;;;1455     __HAL_TIM_DISABLE(htim);
000068  6820              LDR      r0,[r4,#0]
00006a  6a03              LDR      r3,[r0,#0x20]
00006c  4213              TST      r3,r2
00006e  d106              BNE      |L80.126|
000070  6a02              LDR      r2,[r0,#0x20]
000072  420a              TST      r2,r1
000074  d103              BNE      |L80.126|
000076  6801              LDR      r1,[r0,#0]
000078  f0210101          BIC      r1,r1,#1
00007c  6001              STR      r1,[r0,#0]
                  |L80.126|
;;;1456   
;;;1457     /* Change the htim state */
;;;1458     htim->State = HAL_TIM_STATE_READY;
00007e  2001              MOVS     r0,#1
000080  f884003d          STRB     r0,[r4,#0x3d]
;;;1459   
;;;1460     /* Return function status */
;;;1461     return HAL_OK;
000084  2000              MOVS     r0,#0
;;;1462   }
000086  bd10              POP      {r4,pc}
;;;1463   
                          ENDP

                  |L80.136|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1220   */
;;;1221   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1222   {
000002  4604              MOV      r4,r0
;;;1223     /* Check the parameters */
;;;1224     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1225   
;;;1226     switch (Channel)
000004  2900              CMP      r1,#0
;;;1227     {
;;;1228       case TIM_CHANNEL_1:
;;;1229       {
;;;1230         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1231         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6822              LDR      r2,[r4,#0]
000008  d006              BEQ      |L81.24|
00000a  2904              CMP      r1,#4                 ;1226
00000c  d009              BEQ      |L81.34|
00000e  2908              CMP      r1,#8                 ;1226
000010  d00c              BEQ      |L81.44|
000012  290c              CMP      r1,#0xc               ;1226
000014  d113              BNE      |L81.62|
000016  e00e              B        |L81.54|
                  |L81.24|
000018  68d0              LDR      r0,[r2,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  60d0              STR      r0,[r2,#0xc]
;;;1232       }
;;;1233       break;
000020  e00d              B        |L81.62|
                  |L81.34|
;;;1234   
;;;1235       case TIM_CHANNEL_2:
;;;1236       {
;;;1237         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1238         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000022  68d0              LDR      r0,[r2,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  60d0              STR      r0,[r2,#0xc]
;;;1239       }
;;;1240       break;
00002a  e008              B        |L81.62|
                  |L81.44|
;;;1241   
;;;1242       case TIM_CHANNEL_3:
;;;1243       {
;;;1244         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1245         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f0200008          BIC      r0,r0,#8
000032  60d0              STR      r0,[r2,#0xc]
;;;1246       }
;;;1247       break;
000034  e003              B        |L81.62|
                  |L81.54|
;;;1248   
;;;1249       case TIM_CHANNEL_4:
;;;1250       {
;;;1251         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1252         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000036  68d0              LDR      r0,[r2,#0xc]
000038  f0200010          BIC      r0,r0,#0x10
00003c  60d0              STR      r0,[r2,#0xc]
                  |L81.62|
;;;1253       }
;;;1254       break;
;;;1255   
;;;1256       default:
;;;1257       break;
;;;1258     }
;;;1259   
;;;1260     /* Disable the Capture compare channel */
;;;1261     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;1262   
;;;1263     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000046  480f              LDR      r0,|L81.132|
;;;1264     {
;;;1265       /* Disable the Main Ouput */
;;;1266       __HAL_TIM_MOE_DISABLE(htim);
000048  f2411211          MOV      r2,#0x1111
00004c  6821              LDR      r1,[r4,#0]            ;1263
00004e  1093              ASRS     r3,r2,#2
000050  4281              CMP      r1,r0                 ;1263
000052  d109              BNE      |L81.104|
000054  6a08              LDR      r0,[r1,#0x20]
000056  4210              TST      r0,r2
000058  d106              BNE      |L81.104|
00005a  6a08              LDR      r0,[r1,#0x20]
00005c  4218              TST      r0,r3
00005e  d103              BNE      |L81.104|
000060  6c48              LDR      r0,[r1,#0x44]
000062  f4204000          BIC      r0,r0,#0x8000
000066  6448              STR      r0,[r1,#0x44]
                  |L81.104|
;;;1267     }
;;;1268   
;;;1269     /* Disable the Peripheral */
;;;1270     __HAL_TIM_DISABLE(htim);
000068  6820              LDR      r0,[r4,#0]
00006a  6a01              LDR      r1,[r0,#0x20]
00006c  4211              TST      r1,r2
00006e  d106              BNE      |L81.126|
000070  6a01              LDR      r1,[r0,#0x20]
000072  4219              TST      r1,r3
000074  d103              BNE      |L81.126|
000076  6801              LDR      r1,[r0,#0]
000078  f0210101          BIC      r1,r1,#1
00007c  6001              STR      r1,[r0,#0]
                  |L81.126|
;;;1271   
;;;1272     /* Return function status */
;;;1273     return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;1274   }
000080  bd10              POP      {r4,pc}
;;;1275   
                          ENDP

000082  0000              DCW      0x0000
                  |L81.132|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4286     */
;;;4287   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4288   {
;;;4289     /* Prevent unused argument(s) compilation warning */
;;;4290     UNUSED(htim);
;;;4291     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4292               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4293      */
;;;4294   
;;;4295   }
;;;4296   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4199     */
;;;4200   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  2200              MOVS     r2,#0
;;;4201   {
;;;4202     uint32_t tmpreg = 0U;
;;;4203   
;;;4204     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L83.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L83.36|
;;;4205   
;;;4206     switch (Channel)
000012  2904              CMP      r1,#4
000014  d009              BEQ      |L83.42|
000016  2908              CMP      r1,#8
000018  d00a              BEQ      |L83.48|
00001a  290c              CMP      r1,#0xc
00001c  d10d              BNE      |L83.58|
00001e  e00a              B        |L83.54|
                  |L83.32|
000020  2002              MOVS     r0,#2                 ;4204
;;;4207     {
;;;4208     case TIM_CHANNEL_1:
;;;4209       {
;;;4210         /* Check the parameters */
;;;4211         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4212   
;;;4213         /* Return the capture 1 value */
;;;4214         tmpreg =  htim->Instance->CCR1;
;;;4215   
;;;4216         break;
;;;4217       }
;;;4218     case TIM_CHANNEL_2:
;;;4219       {
;;;4220         /* Check the parameters */
;;;4221         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4222   
;;;4223         /* Return the capture 2 value */
;;;4224         tmpreg =   htim->Instance->CCR2;
;;;4225   
;;;4226         break;
;;;4227       }
;;;4228   
;;;4229     case TIM_CHANNEL_3:
;;;4230       {
;;;4231         /* Check the parameters */
;;;4232         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4233   
;;;4234         /* Return the capture 3 value */
;;;4235         tmpreg =   htim->Instance->CCR3;
;;;4236   
;;;4237         break;
;;;4238       }
;;;4239   
;;;4240     case TIM_CHANNEL_4:
;;;4241       {
;;;4242         /* Check the parameters */
;;;4243         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4244   
;;;4245         /* Return the capture 4 value */
;;;4246         tmpreg =   htim->Instance->CCR4;
;;;4247   
;;;4248         break;
;;;4249       }
;;;4250   
;;;4251     default:
;;;4252       break;
;;;4253     }
;;;4254   
;;;4255     __HAL_UNLOCK(htim);
;;;4256     return tmpreg;
;;;4257   }
000022  4770              BX       lr
                  |L83.36|
000024  6801              LDR      r1,[r0,#0]            ;4214
000026  6b4a              LDR      r2,[r1,#0x34]         ;4214
000028  e007              B        |L83.58|
                  |L83.42|
00002a  6801              LDR      r1,[r0,#0]            ;4224
00002c  6b8a              LDR      r2,[r1,#0x38]         ;4224
00002e  e004              B        |L83.58|
                  |L83.48|
000030  6801              LDR      r1,[r0,#0]            ;4235
000032  6bca              LDR      r2,[r1,#0x3c]         ;4235
000034  e001              B        |L83.58|
                  |L83.54|
000036  6801              LDR      r1,[r0,#0]            ;4246
000038  6c0a              LDR      r2,[r1,#0x40]         ;4246
                  |L83.58|
00003a  2100              MOVS     r1,#0                 ;4255
00003c  f880103c          STRB     r1,[r0,#0x3c]         ;4255
000040  4610              MOV      r0,r2                 ;4256
000042  4770              BX       lr
;;;4258   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4126     */
;;;4127   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4128   {
000002  4604              MOV      r4,r0
;;;4129     /* Check the parameters */
;;;4130     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4131     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4132     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4133   
;;;4134     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d018              BEQ      |L84.62|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;4135   
;;;4136     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;4137   
;;;4138     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4139   
;;;4140     /* Disable Trigger Interrupt */
;;;4141     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
00001e  6820              LDR      r0,[r4,#0]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0210140          BIC      r1,r1,#0x40
000026  60c1              STR      r1,[r0,#0xc]
;;;4142   
;;;4143     /* Disable Trigger DMA request */
;;;4144     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4214180          BIC      r1,r1,#0x4000
000030  60c1              STR      r1,[r0,#0xc]
;;;4145   
;;;4146     htim->State = HAL_TIM_STATE_READY;
000032  f884503d          STRB     r5,[r4,#0x3d]
;;;4147   
;;;4148     __HAL_UNLOCK(htim);
000036  2000              MOVS     r0,#0
000038  f884003c          STRB     r0,[r4,#0x3c]
;;;4149   
;;;4150     return HAL_OK;
;;;4151       }
00003c  bd70              POP      {r4-r6,pc}
                  |L84.62|
00003e  2002              MOVS     r0,#2                 ;4134
000040  bd70              POP      {r4-r6,pc}
;;;4152   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4161     */
;;;4162   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4163                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4164       {
000002  4604              MOV      r4,r0
;;;4165         /* Check the parameters */
;;;4166     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4167     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4168     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4169   
;;;4170     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d018              BEQ      |L85.62|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;4171   
;;;4172     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;4173   
;;;4174     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4175   
;;;4176     /* Enable Trigger Interrupt */
;;;4177     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
00001e  6820              LDR      r0,[r4,#0]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0410140          ORR      r1,r1,#0x40
000026  60c1              STR      r1,[r0,#0xc]
;;;4178   
;;;4179     /* Disable Trigger DMA request */
;;;4180     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4214180          BIC      r1,r1,#0x4000
000030  60c1              STR      r1,[r0,#0xc]
;;;4181   
;;;4182     htim->State = HAL_TIM_STATE_READY;
000032  f884503d          STRB     r5,[r4,#0x3d]
;;;4183   
;;;4184     __HAL_UNLOCK(htim);
000036  2000              MOVS     r0,#0
000038  f884003c          STRB     r0,[r4,#0x3c]
;;;4185   
;;;4186     return HAL_OK;
;;;4187   }
00003c  bd70              POP      {r4-r6,pc}
                  |L85.62|
00003e  2002              MOVS     r0,#2                 ;4170
000040  bd70              POP      {r4-r6,pc}
;;;4188   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4341     */
;;;4342   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4343   {
;;;4344     /* Prevent unused argument(s) compilation warning */
;;;4345     UNUSED(htim);
;;;4346     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4347               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4348      */
;;;4349   }
;;;4350   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4568     */
;;;4569   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b5f0              PUSH     {r4-r7,lr}
;;;4570   {
;;;4571     uint32_t tmpcr1 = 0U;
;;;4572     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4573   
;;;4574     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4575     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  4c16              LDR      r4,|L87.96|
000006  4d17              LDR      r5,|L87.100|
000008  4e17              LDR      r6,|L87.104|
00000a  f04f4780          MOV      r7,#0x40000000
00000e  42a0              CMP      r0,r4
000010  d005              BEQ      |L87.30|
000012  42b8              CMP      r0,r7
000014  d003              BEQ      |L87.30|
000016  42a8              CMP      r0,r5
000018  d001              BEQ      |L87.30|
00001a  42b0              CMP      r0,r6
00001c  d103              BNE      |L87.38|
                  |L87.30|
;;;4576     {
;;;4577       /* Select the Counter Mode */
;;;4578       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
00001e  f0220370          BIC      r3,r2,#0x70
;;;4579       tmpcr1 |= Structure->CounterMode;
000022  684a              LDR      r2,[r1,#4]
000024  431a              ORRS     r2,r2,r3
                  |L87.38|
;;;4580     }
;;;4581   
;;;4582     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
000026  42a0              CMP      r0,r4
000028  d005              BEQ      |L87.54|
00002a  42b8              CMP      r0,r7
00002c  d003              BEQ      |L87.54|
00002e  42a8              CMP      r0,r5
000030  d001              BEQ      |L87.54|
000032  42b0              CMP      r0,r6
000034  d103              BNE      |L87.62|
                  |L87.54|
;;;4583     {
;;;4584       /* Set the clock division */
;;;4585       tmpcr1 &= ~TIM_CR1_CKD;
000036  f4227340          BIC      r3,r2,#0x300
;;;4586       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00003a  68ca              LDR      r2,[r1,#0xc]
00003c  431a              ORRS     r2,r2,r3
                  |L87.62|
;;;4587     }
;;;4588   
;;;4589     /* Set the auto-reload preload */
;;;4590     tmpcr1 &= ~TIM_CR1_ARPE;
00003e  f0220280          BIC      r2,r2,#0x80
;;;4591     tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
000042  694b              LDR      r3,[r1,#0x14]
000044  4313              ORRS     r3,r3,r2
;;;4592   
;;;4593     TIMx->CR1 = tmpcr1;
000046  6003              STR      r3,[r0,#0]
;;;4594   
;;;4595     /* Set the Autoreload value */
;;;4596     TIMx->ARR = (uint32_t)Structure->Period ;
000048  688a              LDR      r2,[r1,#8]
00004a  62c2              STR      r2,[r0,#0x2c]
;;;4597   
;;;4598     /* Set the Prescaler value */
;;;4599     TIMx->PSC = (uint32_t)Structure->Prescaler;
00004c  680a              LDR      r2,[r1,#0]
00004e  6282              STR      r2,[r0,#0x28]
;;;4600   
;;;4601     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000050  42a0              CMP      r0,r4
000052  d101              BNE      |L87.88|
;;;4602     {
;;;4603       /* Set the Repetition Counter value */
;;;4604       TIMx->RCR = Structure->RepetitionCounter;
000054  6909              LDR      r1,[r1,#0x10]
000056  6301              STR      r1,[r0,#0x30]
                  |L87.88|
;;;4605     }
;;;4606   
;;;4607     /* Generate an update event to reload the Prescaler 
;;;4608        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4609     TIMx->EGR = TIM_EGR_UG;
000058  2101              MOVS     r1,#1
00005a  6141              STR      r1,[r0,#0x14]
;;;4610   }
00005c  bdf0              POP      {r4-r7,pc}
;;;4611   
                          ENDP

00005e  0000              DCW      0x0000
                  |L87.96|
                          DCD      0x40012c00
                  |L87.100|
                          DCD      0x40000400
                  |L87.104|
                          DCD      0x40000800

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5363     */
;;;5364   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b510              PUSH     {r4,lr}
;;;5365   {
;;;5366     uint32_t tmp = 0U;
;;;5367   
;;;5368     /* Check the parameters */
;;;5369     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5370     assert_param(IS_TIM_CHANNELS(Channel));
;;;5371   
;;;5372     tmp = TIM_CCER_CC1E << Channel;
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
;;;5373   
;;;5374     /* Reset the CCxE Bit */
;;;5375     TIMx->CCER &= ~tmp;
000006  6a04              LDR      r4,[r0,#0x20]
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;5376   
;;;5377     /* Set or reset the CCxE Bit */
;;;5378     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;5379   }
000014  bd10              POP      {r4,pc}
;;;5380   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4506     */
;;;4507   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4508   {
;;;4509     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a44              LDR      r4,[r0,#0x24]
;;;4510   
;;;4511     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f884103d          STRB     r1,[r4,#0x3d]
;;;4512   
;;;4513     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a62              LDR      r2,[r4,#0x24]
00000c  4282              CMP      r2,r0
00000e  d101              BNE      |L89.20|
;;;4514     {
;;;4515       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  7721              STRB     r1,[r4,#0x1c]
000012  e010              B        |L89.54|
                  |L89.20|
;;;4516     }
;;;4517     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6aa1              LDR      r1,[r4,#0x28]
000016  4281              CMP      r1,r0
000018  d102              BNE      |L89.32|
;;;4518     {
;;;4519       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  7720              STRB     r0,[r4,#0x1c]
00001e  e00a              B        |L89.54|
                  |L89.32|
;;;4520     }
;;;4521     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000020  6ae1              LDR      r1,[r4,#0x2c]
000022  4281              CMP      r1,r0
000024  d102              BNE      |L89.44|
;;;4522     {
;;;4523       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000026  2004              MOVS     r0,#4
000028  7720              STRB     r0,[r4,#0x1c]
00002a  e004              B        |L89.54|
                  |L89.44|
;;;4524     }
;;;4525     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00002c  6b21              LDR      r1,[r4,#0x30]
00002e  4281              CMP      r1,r0
000030  d101              BNE      |L89.54|
;;;4526     {
;;;4527       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000032  2008              MOVS     r0,#8
000034  7720              STRB     r0,[r4,#0x1c]
                  |L89.54|
;;;4528     }
;;;4529   
;;;4530     HAL_TIM_IC_CaptureCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4531   
;;;4532     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003c  2000              MOVS     r0,#0
00003e  7720              STRB     r0,[r4,#0x1c]
;;;4533   }
000040  bd10              POP      {r4,pc}
;;;4534   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4474     */
;;;4475   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4476   {
;;;4477     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a44              LDR      r4,[r0,#0x24]
;;;4478   
;;;4479     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f884103d          STRB     r1,[r4,#0x3d]
;;;4480   
;;;4481     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a62              LDR      r2,[r4,#0x24]
00000c  4282              CMP      r2,r0
00000e  d101              BNE      |L90.20|
;;;4482     {
;;;4483       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  7721              STRB     r1,[r4,#0x1c]
000012  e010              B        |L90.54|
                  |L90.20|
;;;4484     }
;;;4485     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6aa1              LDR      r1,[r4,#0x28]
000016  4281              CMP      r1,r0
000018  d102              BNE      |L90.32|
;;;4486     {
;;;4487       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  7720              STRB     r0,[r4,#0x1c]
00001e  e00a              B        |L90.54|
                  |L90.32|
;;;4488     }
;;;4489     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000020  6ae1              LDR      r1,[r4,#0x2c]
000022  4281              CMP      r1,r0
000024  d102              BNE      |L90.44|
;;;4490     {
;;;4491       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000026  2004              MOVS     r0,#4
000028  7720              STRB     r0,[r4,#0x1c]
00002a  e004              B        |L90.54|
                  |L90.44|
;;;4492     }
;;;4493     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00002c  6b21              LDR      r1,[r4,#0x30]
00002e  4281              CMP      r1,r0
000030  d101              BNE      |L90.54|
;;;4494     {
;;;4495       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000032  2008              MOVS     r0,#8
000034  7720              STRB     r0,[r4,#0x1c]
                  |L90.54|
;;;4496     }
;;;4497   
;;;4498     HAL_TIM_PWM_PulseFinishedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4499   
;;;4500     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003c  2000              MOVS     r0,#0
00003e  7720              STRB     r0,[r4,#0x1c]
;;;4501   }
000040  bd10              POP      {r4,pc}
;;;4502   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4460     */
;;;4461   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4462   {
;;;4463     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4464   
;;;4465     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;4466   
;;;4467     HAL_TIM_ErrorCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4468   }
00000e  bd10              POP      {r4,pc}
;;;4469   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4539     */
;;;4540   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4541   {
;;;4542     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4543   
;;;4544     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;4545   
;;;4546     HAL_TIM_PeriodElapsedCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4547   }
00000e  bd10              POP      {r4,pc}
;;;4548   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4553     */
;;;4554   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4555   {
;;;4556     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4557   
;;;4558     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;4559   
;;;4560     HAL_TIM_TriggerCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4561   }
00000e  bd10              POP      {r4,pc}
;;;4562   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5333     */
;;;5334   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;5335                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5336   {
;;;5337     uint32_t tmpsmcr = 0U;
;;;5338   
;;;5339     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;5340   
;;;5341     /* Reset the ETR Bits */
;;;5342     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000004  f424447f          BIC      r4,r4,#0xff00
;;;5343   
;;;5344     /* Set the Prescaler, the Filter value and the Polarity */
;;;5345     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
000008  ea422203          ORR      r2,r2,r3,LSL #8
00000c  430a              ORRS     r2,r2,r1
00000e  4322              ORRS     r2,r2,r4
;;;5346   
;;;5347     /* Write to TIMx SMCR */
;;;5348     TIMx->SMCR = tmpsmcr;
000010  6082              STR      r2,[r0,#8]
;;;5349   }
000012  bd10              POP      {r4,pc}
;;;5350   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;5303     */
;;;5304   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
000000  6882              LDR      r2,[r0,#8]
;;;5305   {
;;;5306     uint32_t tmpsmcr = 0U;
;;;5307   
;;;5308      /* Get the TIMx SMCR register value */
;;;5309      tmpsmcr = TIMx->SMCR;
;;;5310      /* Reset the TS Bits */
;;;5311      tmpsmcr &= ~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;5312      /* Set the Input Trigger source and the slave mode*/
;;;5313      tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
000006  430a              ORRS     r2,r2,r1
000008  f0420107          ORR      r1,r2,#7
;;;5314      /* Write to TIMx SMCR */
;;;5315      TIMx->SMCR = tmpsmcr;
00000c  6081              STR      r1,[r0,#8]
;;;5316   }
00000e  4770              BX       lr
;;;5317   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4617     */
;;;4618   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4619   {
;;;4620     uint32_t tmpccmrx = 0U;
;;;4621     uint32_t tmpccer = 0U;
;;;4622     uint32_t tmpcr2 = 0U;
;;;4623   
;;;4624      /* Disable the Channel 1: Reset the CC1E Bit */
;;;4625     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  6202              STR      r2,[r0,#0x20]
;;;4626   
;;;4627     /* Get the TIMx CCER register value */
;;;4628     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4629     /* Get the TIMx CR2 register value */
;;;4630     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4631   
;;;4632     /* Get the TIMx CCMR1 register value */
;;;4633     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4634   
;;;4635     /* Reset the Output Compare Mode Bits */
;;;4636     tmpccmrx &= ~TIM_CCMR1_OC1M;
000010  f0240470          BIC      r4,r4,#0x70
;;;4637     tmpccmrx &= ~TIM_CCMR1_CC1S;
000014  f0240503          BIC      r5,r4,#3
;;;4638     /* Select the Output Compare Mode */
;;;4639     tmpccmrx |= OC_Config->OCMode;
000018  680c              LDR      r4,[r1,#0]
00001a  432c              ORRS     r4,r4,r5
;;;4640   
;;;4641     /* Reset the Output Polarity level */
;;;4642     tmpccer &= ~TIM_CCER_CC1P;
00001c  f0230502          BIC      r5,r3,#2
;;;4643     /* Set the Output Compare Polarity */
;;;4644     tmpccer |= OC_Config->OCPolarity;
000020  688b              LDR      r3,[r1,#8]
000022  432b              ORRS     r3,r3,r5
;;;4645   
;;;4646     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000024  4d0d              LDR      r5,|L96.92|
000026  42a8              CMP      r0,r5
000028  d106              BNE      |L96.56|
;;;4647     {
;;;4648       /* Check parameters */
;;;4649       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4650   
;;;4651       /* Reset the Output N Polarity level */
;;;4652       tmpccer &= ~TIM_CCER_CC1NP;
00002a  f0230508          BIC      r5,r3,#8
;;;4653       /* Set the Output N Polarity */
;;;4654       tmpccer |= OC_Config->OCNPolarity;
00002e  68cb              LDR      r3,[r1,#0xc]
000030  ea430305          ORR      r3,r3,r5
;;;4655       /* Reset the Output N State */
;;;4656       tmpccer &= ~TIM_CCER_CC1NE;
000034  f0230304          BIC      r3,r3,#4
                  |L96.56|
;;;4657     }
;;;4658   
;;;4659     if(IS_TIM_BREAK_INSTANCE(TIMx))
000038  d109              BNE      |L96.78|
;;;4660     {
;;;4661       /* Check parameters */
;;;4662       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4663       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4664   
;;;4665       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4666       tmpcr2 &= ~TIM_CR2_OIS1;
00003a  f4227280          BIC      r2,r2,#0x100
;;;4667       tmpcr2 &= ~TIM_CR2_OIS1N;
00003e  f4227200          BIC      r2,r2,#0x200
;;;4668       /* Set the Output Idle state */
;;;4669       tmpcr2 |= OC_Config->OCIdleState;
000042  694d              LDR      r5,[r1,#0x14]
000044  ea450502          ORR      r5,r5,r2
;;;4670       /* Set the Output N Idle state */
;;;4671       tmpcr2 |= OC_Config->OCNIdleState;
000048  698a              LDR      r2,[r1,#0x18]
00004a  ea420205          ORR      r2,r2,r5
                  |L96.78|
;;;4672     }
;;;4673     /* Write to TIMx CR2 */
;;;4674     TIMx->CR2 = tmpcr2;
00004e  6042              STR      r2,[r0,#4]
;;;4675   
;;;4676     /* Write to TIMx CCMR1 */
;;;4677     TIMx->CCMR1 = tmpccmrx;
000050  6184              STR      r4,[r0,#0x18]
;;;4678   
;;;4679     /* Set the Capture Compare Register value */
;;;4680     TIMx->CCR1 = OC_Config->Pulse;
000052  6849              LDR      r1,[r1,#4]
000054  6341              STR      r1,[r0,#0x34]
;;;4681   
;;;4682     /* Write to TIMx CCER */
;;;4683     TIMx->CCER = tmpccer;
000056  6203              STR      r3,[r0,#0x20]
;;;4684   }
000058  bd30              POP      {r4,r5,pc}
;;;4685   
                          ENDP

00005a  0000              DCW      0x0000
                  |L96.92|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4691     */
;;;4692   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4693   {
;;;4694     uint32_t tmpccmrx = 0U;
;;;4695     uint32_t tmpccer = 0U;
;;;4696     uint32_t tmpcr2 = 0U;
;;;4697   
;;;4698     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4699     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;4700   
;;;4701     /* Get the TIMx CCER register value */
;;;4702     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4703     /* Get the TIMx CR2 register value */
;;;4704     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4705   
;;;4706     /* Get the TIMx CCMR1 register value */
;;;4707     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4708   
;;;4709     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4710     tmpccmrx &= ~TIM_CCMR1_OC2M;
000010  f42444e0          BIC      r4,r4,#0x7000
;;;4711     tmpccmrx &= ~TIM_CCMR1_CC2S;
000014  f4247440          BIC      r4,r4,#0x300
;;;4712   
;;;4713     /* Select the Output Compare Mode */
;;;4714     tmpccmrx |= (OC_Config->OCMode << 8U);
000018  680d              LDR      r5,[r1,#0]
00001a  ea442405          ORR      r4,r4,r5,LSL #8
;;;4715   
;;;4716     /* Reset the Output Polarity level */
;;;4717     tmpccer &= ~TIM_CCER_CC2P;
00001e  f0230320          BIC      r3,r3,#0x20
;;;4718     /* Set the Output Compare Polarity */
;;;4719     tmpccer |= (OC_Config->OCPolarity << 4U);
000022  688d              LDR      r5,[r1,#8]
000024  ea431305          ORR      r3,r3,r5,LSL #4
;;;4720   
;;;4721     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000028  4d0d              LDR      r5,|L97.96|
00002a  42a8              CMP      r0,r5
00002c  d106              BNE      |L97.60|
;;;4722     {
;;;4723       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4724   
;;;4725       /* Reset the Output N Polarity level */
;;;4726       tmpccer &= ~TIM_CCER_CC2NP;
00002e  f0230380          BIC      r3,r3,#0x80
;;;4727       /* Set the Output N Polarity */
;;;4728       tmpccer |= (OC_Config->OCNPolarity << 4U);
000032  68cd              LDR      r5,[r1,#0xc]
000034  ea431305          ORR      r3,r3,r5,LSL #4
;;;4729       /* Reset the Output N State */
;;;4730       tmpccer &= ~TIM_CCER_CC2NE;
000038  f0230340          BIC      r3,r3,#0x40
                  |L97.60|
;;;4731   
;;;4732     }
;;;4733   
;;;4734     if(IS_TIM_BREAK_INSTANCE(TIMx))
00003c  d109              BNE      |L97.82|
;;;4735     {
;;;4736       /* Check parameters */
;;;4737       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4738       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4739   
;;;4740       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4741       tmpcr2 &= ~TIM_CR2_OIS2;
00003e  f4226280          BIC      r2,r2,#0x400
;;;4742       tmpcr2 &= ~TIM_CR2_OIS2N;
000042  f4226200          BIC      r2,r2,#0x800
;;;4743       /* Set the Output Idle state */
;;;4744       tmpcr2 |= (OC_Config->OCIdleState << 2);
000046  694d              LDR      r5,[r1,#0x14]
000048  ea420285          ORR      r2,r2,r5,LSL #2
;;;4745       /* Set the Output N Idle state */
;;;4746       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00004c  698d              LDR      r5,[r1,#0x18]
00004e  ea420285          ORR      r2,r2,r5,LSL #2
                  |L97.82|
;;;4747     }
;;;4748   
;;;4749     /* Write to TIMx CR2 */
;;;4750     TIMx->CR2 = tmpcr2;
000052  6042              STR      r2,[r0,#4]
;;;4751   
;;;4752     /* Write to TIMx CCMR1 */
;;;4753     TIMx->CCMR1 = tmpccmrx;
000054  6184              STR      r4,[r0,#0x18]
;;;4754   
;;;4755     /* Set the Capture Compare Register value */
;;;4756     TIMx->CCR2 = OC_Config->Pulse;
000056  6849              LDR      r1,[r1,#4]
000058  6381              STR      r1,[r0,#0x38]
;;;4757   
;;;4758     /* Write to TIMx CCER */
;;;4759     TIMx->CCER = tmpccer;
00005a  6203              STR      r3,[r0,#0x20]
;;;4760   }
00005c  bd30              POP      {r4,r5,pc}
;;;4761   
                          ENDP

00005e  0000              DCW      0x0000
                  |L97.96|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4767     */
;;;4768   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4769   {
;;;4770     uint32_t tmpccmrx = 0U;
;;;4771     uint32_t tmpccer = 0U;
;;;4772     uint32_t tmpcr2 = 0U;
;;;4773   
;;;4774     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4775     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  6202              STR      r2,[r0,#0x20]
;;;4776   
;;;4777     /* Get the TIMx CCER register value */
;;;4778     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4779     /* Get the TIMx CR2 register value */
;;;4780     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4781   
;;;4782     /* Get the TIMx CCMR2 register value */
;;;4783     tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;4784   
;;;4785     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4786     tmpccmrx &= ~TIM_CCMR2_OC3M;
000010  f0240470          BIC      r4,r4,#0x70
;;;4787     tmpccmrx &= ~TIM_CCMR2_CC3S;
000014  f0240503          BIC      r5,r4,#3
;;;4788     /* Select the Output Compare Mode */
;;;4789     tmpccmrx |= OC_Config->OCMode;
000018  680c              LDR      r4,[r1,#0]
00001a  432c              ORRS     r4,r4,r5
;;;4790   
;;;4791     /* Reset the Output Polarity level */
;;;4792     tmpccer &= ~TIM_CCER_CC3P;
00001c  f4237300          BIC      r3,r3,#0x200
;;;4793     /* Set the Output Compare Polarity */
;;;4794     tmpccer |= (OC_Config->OCPolarity << 8U);
000020  688d              LDR      r5,[r1,#8]
000022  ea432305          ORR      r3,r3,r5,LSL #8
;;;4795   
;;;4796     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
000026  4d0d              LDR      r5,|L98.92|
000028  42a8              CMP      r0,r5
00002a  d106              BNE      |L98.58|
;;;4797     {
;;;4798       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4799   
;;;4800       /* Reset the Output N Polarity level */
;;;4801       tmpccer &= ~TIM_CCER_CC3NP;
00002c  f4236300          BIC      r3,r3,#0x800
;;;4802       /* Set the Output N Polarity */
;;;4803       tmpccer |= (OC_Config->OCNPolarity << 8U);
000030  68cd              LDR      r5,[r1,#0xc]
000032  ea432305          ORR      r3,r3,r5,LSL #8
;;;4804       /* Reset the Output N State */
;;;4805       tmpccer &= ~TIM_CCER_CC3NE;
000036  f4236380          BIC      r3,r3,#0x400
                  |L98.58|
;;;4806     }
;;;4807   
;;;4808     if(IS_TIM_BREAK_INSTANCE(TIMx))
00003a  d109              BNE      |L98.80|
;;;4809     {
;;;4810       /* Check parameters */
;;;4811       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4812       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4813   
;;;4814       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4815       tmpcr2 &= ~TIM_CR2_OIS3;
00003c  f4225280          BIC      r2,r2,#0x1000
;;;4816       tmpcr2 &= ~TIM_CR2_OIS3N;
000040  f4225200          BIC      r2,r2,#0x2000
;;;4817       /* Set the Output Idle state */
;;;4818       tmpcr2 |= (OC_Config->OCIdleState << 4U);
000044  694d              LDR      r5,[r1,#0x14]
000046  ea421205          ORR      r2,r2,r5,LSL #4
;;;4819       /* Set the Output N Idle state */
;;;4820       tmpcr2 |= (OC_Config->OCNIdleState << 4U);
00004a  698d              LDR      r5,[r1,#0x18]
00004c  ea421205          ORR      r2,r2,r5,LSL #4
                  |L98.80|
;;;4821     }
;;;4822   
;;;4823     /* Write to TIMx CR2 */
;;;4824     TIMx->CR2 = tmpcr2;
000050  6042              STR      r2,[r0,#4]
;;;4825   
;;;4826     /* Write to TIMx CCMR2 */
;;;4827     TIMx->CCMR2 = tmpccmrx;
000052  61c4              STR      r4,[r0,#0x1c]
;;;4828   
;;;4829     /* Set the Capture Compare Register value */
;;;4830     TIMx->CCR3 = OC_Config->Pulse;
000054  6849              LDR      r1,[r1,#4]
000056  63c1              STR      r1,[r0,#0x3c]
;;;4831   
;;;4832     /* Write to TIMx CCER */
;;;4833     TIMx->CCER = tmpccer;
000058  6203              STR      r3,[r0,#0x20]
;;;4834   }
00005a  bd30              POP      {r4,r5,pc}
;;;4835   
                          ENDP

                  |L98.92|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4841     */
;;;4842   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4843   {
;;;4844     uint32_t tmpccmrx = 0U;
;;;4845     uint32_t tmpccer = 0U;
;;;4846     uint32_t tmpcr2 = 0U;
;;;4847   
;;;4848     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4849     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  6202              STR      r2,[r0,#0x20]
;;;4850   
;;;4851     /* Get the TIMx CCER register value */
;;;4852     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4853     /* Get the TIMx CR2 register value */
;;;4854     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4855   
;;;4856     /* Get the TIMx CCMR2 register value */
;;;4857     tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;4858   
;;;4859     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4860     tmpccmrx &= ~TIM_CCMR2_OC4M;
000010  f42444e0          BIC      r4,r4,#0x7000
;;;4861     tmpccmrx &= ~TIM_CCMR2_CC4S;
000014  f4247440          BIC      r4,r4,#0x300
;;;4862   
;;;4863     /* Select the Output Compare Mode */
;;;4864     tmpccmrx |= (OC_Config->OCMode << 8U);
000018  680d              LDR      r5,[r1,#0]
00001a  ea442405          ORR      r4,r4,r5,LSL #8
;;;4865   
;;;4866     /* Reset the Output Polarity level */
;;;4867     tmpccer &= ~TIM_CCER_CC4P;
00001e  f4235300          BIC      r3,r3,#0x2000
;;;4868     /* Set the Output Compare Polarity */
;;;4869     tmpccer |= (OC_Config->OCPolarity << 12U);
000022  688d              LDR      r5,[r1,#8]
000024  ea433305          ORR      r3,r3,r5,LSL #12
;;;4870   
;;;4871     if(IS_TIM_BREAK_INSTANCE(TIMx))
000028  4d06              LDR      r5,|L99.68|
00002a  42a8              CMP      r0,r5
00002c  d104              BNE      |L99.56|
;;;4872     {
;;;4873       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4874   
;;;4875      /* Reset the Output Compare IDLE State */
;;;4876       tmpcr2 &= ~TIM_CR2_OIS4;
00002e  f4224280          BIC      r2,r2,#0x4000
;;;4877       /* Set the Output Idle state */
;;;4878       tmpcr2 |= (OC_Config->OCIdleState << 6);
000032  694d              LDR      r5,[r1,#0x14]
000034  ea421285          ORR      r2,r2,r5,LSL #6
                  |L99.56|
;;;4879     }
;;;4880   
;;;4881     /* Write to TIMx CR2 */
;;;4882     TIMx->CR2 = tmpcr2;
000038  6042              STR      r2,[r0,#4]
;;;4883   
;;;4884     /* Write to TIMx CCMR2 */
;;;4885     TIMx->CCMR2 = tmpccmrx;
00003a  61c4              STR      r4,[r0,#0x1c]
;;;4886   
;;;4887     /* Set the Capture Compare Register value */
;;;4888     TIMx->CCR4 = OC_Config->Pulse;
00003c  6849              LDR      r1,[r1,#4]
00003e  6401              STR      r1,[r0,#0x40]
;;;4889   
;;;4890     /* Write to TIMx CCER */
;;;4891     TIMx->CCER = tmpccer;
000040  6203              STR      r3,[r0,#0x20]
;;;4892   }
000042  bd30              POP      {r4,r5,pc}
;;;4893   
                          ENDP

                  |L99.68|
                          DCD      0x40012c00

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4901     */
;;;4902   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b430              PUSH     {r4,r5}
;;;4903                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4904   {
;;;4905     uint32_t tmpsmcr = 0U;
;;;4906     uint32_t tmpccmr1 = 0U;
;;;4907     uint32_t tmpccer = 0U;
;;;4908   
;;;4909     /* Get the TIMx SMCR register value */
;;;4910     tmpsmcr = htim->Instance->SMCR;
000002  6802              LDR      r2,[r0,#0]
000004  6893              LDR      r3,[r2,#8]
;;;4911   
;;;4912     /* Reset the Trigger Selection Bits */
;;;4913     tmpsmcr &= ~TIM_SMCR_TS;
000006  f0230470          BIC      r4,r3,#0x70
;;;4914     /* Set the Input Trigger source */
;;;4915     tmpsmcr |= sSlaveConfig->InputTrigger;
00000a  684b              LDR      r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
;;;4916   
;;;4917     /* Reset the slave mode Bits */
;;;4918     tmpsmcr &= ~TIM_SMCR_SMS;
00000e  f0230407          BIC      r4,r3,#7
;;;4919     /* Set the slave mode */
;;;4920     tmpsmcr |= sSlaveConfig->SlaveMode;
000012  680b              LDR      r3,[r1,#0]
000014  4323              ORRS     r3,r3,r4
;;;4921   
;;;4922     /* Write to TIMx SMCR */
;;;4923     htim->Instance->SMCR = tmpsmcr;
000016  6093              STR      r3,[r2,#8]
;;;4924   
;;;4925     /* Configure the trigger prescaler, filter, and polarity */
;;;4926     switch (sSlaveConfig->InputTrigger)
000018  684a              LDR      r2,[r1,#4]
00001a  f0120f0f          TST      r2,#0xf
00001e  d11f              BNE      |L100.96|
000020  1112              ASRS     r2,r2,#4
000022  2a08              CMP      r2,#8
000024  d21c              BCS      |L100.96|
000026  e8dff002          TBB      [pc,r2]
00002a  1b1b              DCB      0x1b,0x1b
00002c  1b1b0b1d          DCB      0x1b,0x1b,0x0b,0x1d
000030  2304              DCB      0x23,0x04
;;;4927     {
;;;4928     case TIM_TS_ETRF:
;;;4929       {
;;;4930         /* Check the parameters */
;;;4931         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4932         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4933         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4934         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4935         /* Configure the ETR Trigger source */
;;;4936         TIM_ETR_SetConfig(htim->Instance,
000032  690b              LDR      r3,[r1,#0x10]
000034  e9d12102          LDRD     r2,r1,[r1,#8]
000038  6800              LDR      r0,[r0,#0]
00003a  bc30              POP      {r4,r5}
00003c  f7ffbffe          B.W      TIM_ETR_SetConfig
;;;4937                           sSlaveConfig->TriggerPrescaler,
;;;4938                           sSlaveConfig->TriggerPolarity,
;;;4939                           sSlaveConfig->TriggerFilter);
;;;4940       }
;;;4941       break;
;;;4942   
;;;4943     case TIM_TS_TI1F_ED:
;;;4944       {
;;;4945         /* Check the parameters */
;;;4946         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4947         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4948   
;;;4949         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4950         tmpccer = htim->Instance->CCER;
000040  6802              LDR      r2,[r0,#0]
000042  6a14              LDR      r4,[r2,#0x20]
;;;4951         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000044  6a13              LDR      r3,[r2,#0x20]
000046  f0230301          BIC      r3,r3,#1
00004a  6213              STR      r3,[r2,#0x20]
;;;4952         tmpccmr1 = htim->Instance->CCMR1;
00004c  6802              LDR      r2,[r0,#0]
00004e  6993              LDR      r3,[r2,#0x18]
;;;4953   
;;;4954         /* Set the filter */
;;;4955         tmpccmr1 &= ~TIM_CCMR1_IC1F;
000050  f02303f0          BIC      r3,r3,#0xf0
;;;4956         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
000054  6909              LDR      r1,[r1,#0x10]
000056  ea431101          ORR      r1,r3,r1,LSL #4
;;;4957   
;;;4958         /* Write to TIMx CCMR1 and CCER registers */
;;;4959         htim->Instance->CCMR1 = tmpccmr1;
00005a  6191              STR      r1,[r2,#0x18]
;;;4960         htim->Instance->CCER = tmpccer;
00005c  6800              LDR      r0,[r0,#0]
00005e  6204              STR      r4,[r0,#0x20]
                  |L100.96|
;;;4961   
;;;4962       }
;;;4963       break;
;;;4964   
;;;4965     case TIM_TS_TI1FP1:
;;;4966       {
;;;4967         /* Check the parameters */
;;;4968         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4969         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4970         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4971   
;;;4972         /* Configure TI1 Filter and Polarity */
;;;4973         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4974                                  sSlaveConfig->TriggerPolarity,
;;;4975                                  sSlaveConfig->TriggerFilter);
;;;4976       }
;;;4977       break;
;;;4978   
;;;4979     case TIM_TS_TI2FP2:
;;;4980       {
;;;4981         /* Check the parameters */
;;;4982         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4983         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4984         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4985   
;;;4986         /* Configure TI2 Filter and Polarity */
;;;4987         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4988                                   sSlaveConfig->TriggerPolarity,
;;;4989                                   sSlaveConfig->TriggerFilter);
;;;4990       }
;;;4991       break;
;;;4992   
;;;4993     case TIM_TS_ITR0:
;;;4994       {
;;;4995         /* Check the parameter */
;;;4996         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4997       }
;;;4998       break;
;;;4999   
;;;5000     case TIM_TS_ITR1:
;;;5001       {
;;;5002         /* Check the parameter */
;;;5003         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5004       }
;;;5005       break;
;;;5006   
;;;5007     case TIM_TS_ITR2:
;;;5008       {
;;;5009         /* Check the parameter */
;;;5010         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5011       }
;;;5012       break;
;;;5013   
;;;5014     case TIM_TS_ITR3:
;;;5015       {
;;;5016         /* Check the parameter */
;;;5017         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5018       }
;;;5019       break;
;;;5020   
;;;5021     default:
;;;5022       break;
;;;5023     }
;;;5024   }
000060  bc30              POP      {r4,r5}
000062  4770              BX       lr
000064  690a              LDR      r2,[r1,#0x10]         ;4973
000066  6889              LDR      r1,[r1,#8]            ;4973
000068  6800              LDR      r0,[r0,#0]            ;4973
00006a  bc30              POP      {r4,r5}               ;4973
00006c  f7ffbffe          B.W      TIM_TI1_ConfigInputStage
000070  690a              LDR      r2,[r1,#0x10]         ;4987
000072  6889              LDR      r1,[r1,#8]            ;4987
000074  6800              LDR      r0,[r0,#0]            ;4987
000076  bc30              POP      {r4,r5}               ;4987
000078  f7ffbffe          B.W      TIM_TI2_ConfigInputStage
;;;5025   
                          ENDP


                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5090     */
;;;5091   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5092   {
;;;5093     uint32_t tmpccmr1 = 0U;
;;;5094     uint32_t tmpccer = 0U;
;;;5095   
;;;5096     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5097     tmpccer = TIMx->CCER;
000002  6a03              LDR      r3,[r0,#0x20]
;;;5098     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a04              LDR      r4,[r0,#0x20]
000006  f0240401          BIC      r4,r4,#1
00000a  6204              STR      r4,[r0,#0x20]
;;;5099     tmpccmr1 = TIMx->CCMR1;
00000c  6984              LDR      r4,[r0,#0x18]
;;;5100   
;;;5101     /* Set the filter */
;;;5102     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00000e  f02404f0          BIC      r4,r4,#0xf0
;;;5103     tmpccmr1 |= (TIM_ICFilter << 4U);
000012  ea441402          ORR      r4,r4,r2,LSL #4
;;;5104   
;;;5105     /* Select the Polarity and set the CC1E Bit */
;;;5106     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000016  f023020a          BIC      r2,r3,#0xa
;;;5107     tmpccer |= TIM_ICPolarity;
00001a  430a              ORRS     r2,r2,r1
;;;5108   
;;;5109     /* Write to TIMx CCMR1 and CCER registers */
;;;5110     TIMx->CCMR1 = tmpccmr1;
00001c  6184              STR      r4,[r0,#0x18]
;;;5111     TIMx->CCER = tmpccer;
00001e  6202              STR      r2,[r0,#0x20]
;;;5112   }
000020  bd10              POP      {r4,pc}
;;;5113   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5044     */
;;;5045   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5046                          uint32_t TIM_ICFilter)
;;;5047   {
;;;5048     uint32_t tmpccmr1 = 0U;
;;;5049     uint32_t tmpccer = 0U;
;;;5050   
;;;5051     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5052     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;5053     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5054     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5055   
;;;5056     /* Select the Input */
;;;5057     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
00000e  4e0f              LDR      r6,|L102.76|
000010  42b0              CMP      r0,r6
000012  d008              BEQ      |L102.38|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d005              BEQ      |L102.38|
00001a  4e0d              LDR      r6,|L102.80|
00001c  42b0              CMP      r0,r6
00001e  d002              BEQ      |L102.38|
000020  4e0c              LDR      r6,|L102.84|
000022  42b0              CMP      r0,r6
000024  d103              BNE      |L102.46|
                  |L102.38|
;;;5058     {
;;;5059       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000026  f0240403          BIC      r4,r4,#3
;;;5060       tmpccmr1 |= TIM_ICSelection;
00002a  4314              ORRS     r4,r4,r2
00002c  e001              B        |L102.50|
                  |L102.46|
;;;5061     }
;;;5062     else
;;;5063     {
;;;5064       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00002e  f0440401          ORR      r4,r4,#1
                  |L102.50|
;;;5065     }
;;;5066   
;;;5067     /* Set the filter */
;;;5068     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000032  f02404f0          BIC      r4,r4,#0xf0
;;;5069     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
000036  071a              LSLS     r2,r3,#28
000038  ea446212          ORR      r2,r4,r2,LSR #24
;;;5070   
;;;5071     /* Select the Polarity and set the CC1E Bit */
;;;5072     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00003c  f025030a          BIC      r3,r5,#0xa
;;;5073     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000040  f001010a          AND      r1,r1,#0xa
000044  4319              ORRS     r1,r1,r3
;;;5074   
;;;5075     /* Write to TIMx CCMR1 and CCER registers */
;;;5076     TIMx->CCMR1 = tmpccmr1;
000046  6182              STR      r2,[r0,#0x18]
;;;5077     TIMx->CCER = tmpccer;
000048  6201              STR      r1,[r0,#0x20]
;;;5078   }
00004a  bd70              POP      {r4-r6,pc}
;;;5079   
                          ENDP

                  |L102.76|
                          DCD      0x40012c00
                  |L102.80|
                          DCD      0x40000400
                  |L102.84|
                          DCD      0x40000800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;5171     */
;;;5172   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5173   {
;;;5174     uint32_t tmpccmr1 = 0U;
;;;5175     uint32_t tmpccer = 0U;
;;;5176   
;;;5177     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5178     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a03              LDR      r3,[r0,#0x20]
000004  f0230310          BIC      r3,r3,#0x10
000008  6203              STR      r3,[r0,#0x20]
;;;5179     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5180     tmpccer = TIMx->CCER;
00000c  6a03              LDR      r3,[r0,#0x20]
;;;5181   
;;;5182     /* Set the filter */
;;;5183     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00000e  f4244470          BIC      r4,r4,#0xf000
;;;5184     tmpccmr1 |= (TIM_ICFilter << 12U);
000012  ea443202          ORR      r2,r4,r2,LSL #12
;;;5185   
;;;5186     /* Select the Polarity and set the CC2E Bit */
;;;5187     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000016  f02303a0          BIC      r3,r3,#0xa0
;;;5188     tmpccer |= (TIM_ICPolarity << 4U);
00001a  ea431101          ORR      r1,r3,r1,LSL #4
;;;5189   
;;;5190     /* Write to TIMx CCMR1 and CCER registers */
;;;5191     TIMx->CCMR1 = tmpccmr1 ;
00001e  6182              STR      r2,[r0,#0x18]
;;;5192     TIMx->CCER = tmpccer;
000020  6201              STR      r1,[r0,#0x20]
;;;5193   }
000022  bd10              POP      {r4,pc}
;;;5194   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5132     */
;;;5133   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;5134                          uint32_t TIM_ICFilter)
;;;5135   {
;;;5136     uint32_t tmpccmr1 = 0U;
;;;5137     uint32_t tmpccer = 0U;
;;;5138   
;;;5139     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5140     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  6204              STR      r4,[r0,#0x20]
;;;5141     tmpccmr1 = TIMx->CCMR1;
00000a  6985              LDR      r5,[r0,#0x18]
;;;5142     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;5143   
;;;5144     /* Select the Input */
;;;5145     tmpccmr1 &= ~TIM_CCMR1_CC2S;
00000e  f4257540          BIC      r5,r5,#0x300
;;;5146     tmpccmr1 |= (TIM_ICSelection << 8U);
000012  ea452202          ORR      r2,r5,r2,LSL #8
;;;5147   
;;;5148     /* Set the filter */
;;;5149     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4224570          BIC      r5,r2,#0xf000
;;;5150     tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
00001a  f64f72ff          MOV      r2,#0xffff
00001e  ea023203          AND      r2,r2,r3,LSL #12
000022  432a              ORRS     r2,r2,r5
;;;5151   
;;;5152     /* Select the Polarity and set the CC2E Bit */
;;;5153     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000024  f02403a0          BIC      r3,r4,#0xa0
;;;5154     tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000028  24a0              MOVS     r4,#0xa0
00002a  ea041101          AND      r1,r4,r1,LSL #4
00002e  4319              ORRS     r1,r1,r3
;;;5155   
;;;5156     /* Write to TIMx CCMR1 and CCER registers */
;;;5157     TIMx->CCMR1 = tmpccmr1 ;
000030  6182              STR      r2,[r0,#0x18]
;;;5158     TIMx->CCER = tmpccer;
000032  6201              STR      r1,[r0,#0x20]
;;;5159   }
000034  bd30              POP      {r4,r5,pc}
;;;5160   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;5213     */
;;;5214   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;5215                          uint32_t TIM_ICFilter)
;;;5216   {
;;;5217     uint32_t tmpccmr2 = 0U;
;;;5218     uint32_t tmpccer = 0U;
;;;5219   
;;;5220     /* Disable the Channel 3: Reset the CC3E Bit */
;;;5221     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f4247480          BIC      r4,r4,#0x100
000008  6204              STR      r4,[r0,#0x20]
;;;5222     tmpccmr2 = TIMx->CCMR2;
00000a  69c4              LDR      r4,[r0,#0x1c]
;;;5223     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5224   
;;;5225     /* Select the Input */
;;;5226     tmpccmr2 &= ~TIM_CCMR2_CC3S;
00000e  f0240403          BIC      r4,r4,#3
;;;5227     tmpccmr2 |= TIM_ICSelection;
000012  4314              ORRS     r4,r4,r2
;;;5228   
;;;5229     /* Set the filter */
;;;5230     tmpccmr2 &= ~TIM_CCMR2_IC3F;
000014  f02404f0          BIC      r4,r4,#0xf0
;;;5231     tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
000018  071a              LSLS     r2,r3,#28
00001a  ea446212          ORR      r2,r4,r2,LSR #24
;;;5232   
;;;5233     /* Select the Polarity and set the CC3E Bit */
;;;5234     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
00001e  f4256320          BIC      r3,r5,#0xa00
;;;5235     tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
000022  f44f6420          MOV      r4,#0xa00
000026  ea042101          AND      r1,r4,r1,LSL #8
00002a  4319              ORRS     r1,r1,r3
;;;5236   
;;;5237     /* Write to TIMx CCMR2 and CCER registers */
;;;5238     TIMx->CCMR2 = tmpccmr2;
00002c  61c2              STR      r2,[r0,#0x1c]
;;;5239     TIMx->CCER = tmpccer;
00002e  6201              STR      r1,[r0,#0x20]
;;;5240   }
000030  bd30              POP      {r4,r5,pc}
;;;5241   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;5260     */
;;;5261   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;5262                          uint32_t TIM_ICFilter)
;;;5263   {
;;;5264     uint32_t tmpccmr2 = 0U;
;;;5265     uint32_t tmpccer = 0U;
;;;5266   
;;;5267     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5268     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f4245480          BIC      r4,r4,#0x1000
000008  6204              STR      r4,[r0,#0x20]
;;;5269     tmpccmr2 = TIMx->CCMR2;
00000a  69c5              LDR      r5,[r0,#0x1c]
;;;5270     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;5271   
;;;5272     /* Select the Input */
;;;5273     tmpccmr2 &= ~TIM_CCMR2_CC4S;
00000e  f4257540          BIC      r5,r5,#0x300
;;;5274     tmpccmr2 |= (TIM_ICSelection << 8U);
000012  ea452202          ORR      r2,r5,r2,LSL #8
;;;5275   
;;;5276     /* Set the filter */
;;;5277     tmpccmr2 &= ~TIM_CCMR2_IC4F;
000016  f4224570          BIC      r5,r2,#0xf000
;;;5278     tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
00001a  f64f72ff          MOV      r2,#0xffff
00001e  ea023203          AND      r2,r2,r3,LSL #12
000022  432a              ORRS     r2,r2,r5
;;;5279   
;;;5280     /* Select the Polarity and set the CC4E Bit */
;;;5281     tmpccer &= ~TIM_CCER_CC4P;
000024  f4245300          BIC      r3,r4,#0x2000
;;;5282     tmpccer |= ((TIM_ICPolarity << 12U) & TIM_CCER_CC4P);
000028  f44f5400          MOV      r4,#0x2000
00002c  ea043101          AND      r1,r4,r1,LSL #12
000030  4319              ORRS     r1,r1,r3
;;;5283   
;;;5284     /* Write to TIMx CCMR2 and CCER registers */
;;;5285     TIMx->CCMR2 = tmpccmr2;
000032  61c2              STR      r2,[r0,#0x1c]
;;;5286     TIMx->CCER = tmpccer ;
000034  6201              STR      r1,[r0,#0x20]
;;;5287   }
000036  bd30              POP      {r4,r5,pc}
;;;5288   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
