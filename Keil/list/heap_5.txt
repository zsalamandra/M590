; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -ogsm_stm32f103\heap_5.o --asm_dir=..\..\list\ --list_dir=..\..\list\ --depend=gsm_stm32f103\heap_5.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I..\Hardware\SSD1306 -I..\Hardware\delay -I..\Hardware\GSM_LIB\GENERAL -I..\Hardware\GSM_LIB\USART -IE:\MC\2.STM32\STMProjects\GSM\GSM_M590\Project\gsm_stm32f103\MDK-ARM\RTE -IE:\MC\2.STM32\STMProjects\GSM\GSM_M590\Project\gsm_stm32f103\MDK-ARM\RTE\RTOS -IC:\Keil_v5\ARM\PACK\ARM\CMSIS-FreeRTOS\9.0.0\CMSIS\RTOS2\FreeRTOS\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS-FreeRTOS\9.0.0\Source\include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS-FreeRTOS\9.0.0\Source\portable\RVDS\ARM_CM3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB C:\Keil_v5\ARM\PACK\ARM\CMSIS-FreeRTOS\9.0.0\Source\portable\MemMang\heap_5.c]
                          THUMB

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;373    
;;;374    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b530              PUSH     {r4,r5,lr}
;;;375    {
;;;376    BlockLink_t *pxIterator;
;;;377    uint8_t *puc;
;;;378    
;;;379    	/* Iterate through the list until a block is found that has a higher address
;;;380    	than the block being inserted. */
;;;381    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000002  4913              LDR      r1,|L1.80|
000004  e000              B        |L1.8|
                  |L1.6|
000006  4611              MOV      r1,r2
                  |L1.8|
000008  680a              LDR      r2,[r1,#0]
00000a  4282              CMP      r2,r0
00000c  d3fb              BCC      |L1.6|
;;;382    	{
;;;383    		/* Nothing to do here, just iterate to the right position. */
;;;384    	}
;;;385    
;;;386    	/* Do the block being inserted, and the block it is being inserted after
;;;387    	make a contiguous block of memory? */
;;;388    	puc = ( uint8_t * ) pxIterator;
;;;389    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
00000e  684b              LDR      r3,[r1,#4]
000010  185c              ADDS     r4,r3,r1
000012  4284              CMP      r4,r0
000014  d103              BNE      |L1.30|
;;;390    	{
;;;391    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
000016  6840              LDR      r0,[r0,#4]
000018  4418              ADD      r0,r0,r3
00001a  6048              STR      r0,[r1,#4]
;;;392    		pxBlockToInsert = pxIterator;
00001c  4608              MOV      r0,r1
                  |L1.30|
;;;393    	}
;;;394    	else
;;;395    	{
;;;396    		mtCOVERAGE_TEST_MARKER();
;;;397    	}
;;;398    
;;;399    	/* Do the block being inserted, and the block it is being inserted before
;;;400    	make a contiguous block of memory? */
;;;401    	puc = ( uint8_t * ) pxBlockToInsert;
;;;402    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
00001e  680d              LDR      r5,[r1,#0]
000020  6844              LDR      r4,[r0,#4]
000022  1823              ADDS     r3,r4,r0
000024  42ab              CMP      r3,r5
000026  d10d              BNE      |L1.68|
;;;403    	{
;;;404    		if( pxIterator->pxNextFreeBlock != pxEnd )
000028  4b09              LDR      r3,|L1.80|
00002a  3b10              SUBS     r3,r3,#0x10
00002c  681b              LDR      r3,[r3,#0]  ; pxEnd
00002e  429a              CMP      r2,r3
000030  d006              BEQ      |L1.64|
;;;405    		{
;;;406    			/* Form one big block from the two blocks. */
;;;407    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
000032  6852              LDR      r2,[r2,#4]
000034  4422              ADD      r2,r2,r4
000036  6042              STR      r2,[r0,#4]
;;;408    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000038  680a              LDR      r2,[r1,#0]
00003a  6812              LDR      r2,[r2,#0]
00003c  6002              STR      r2,[r0,#0]
00003e  e002              B        |L1.70|
                  |L1.64|
;;;409    		}
;;;410    		else
;;;411    		{
;;;412    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
000040  6003              STR      r3,[r0,#0]
000042  e000              B        |L1.70|
                  |L1.68|
;;;413    		}
;;;414    	}
;;;415    	else
;;;416    	{
;;;417    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
000044  6002              STR      r2,[r0,#0]
                  |L1.70|
;;;418    	}
;;;419    
;;;420    	/* If the block being inserted plugged a gab, so was merged with the block
;;;421    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;422    	already been set, and should not be set here as that would make it point
;;;423    	to itself. */
;;;424    	if( pxIterator != pxBlockToInsert )
000046  4281              CMP      r1,r0
000048  d000              BEQ      |L1.76|
;;;425    	{
;;;426    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
00004a  6008              STR      r0,[r1,#0]
                  |L1.76|
;;;427    	}
;;;428    	else
;;;429    	{
;;;430    		mtCOVERAGE_TEST_MARKER();
;;;431    	}
;;;432    }
00004c  bd30              POP      {r4,r5,pc}
;;;433    /*-----------------------------------------------------------*/
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      ||.data||+0x10

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;173    
;;;174    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;175    {
000004  4605              MOV      r5,r0
;;;176    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;177    void *pvReturn = NULL;
000006  2600              MOVS     r6,#0
;;;178    
;;;179    	/* The heap must be initialised before the first call to
;;;180    	prvPortMalloc(). */
;;;181    	configASSERT( pxEnd );
000008  4f26              LDR      r7,|L2.164|
00000a  6838              LDR      r0,[r7,#0]  ; pxEnd
00000c  2800              CMP      r0,#0
00000e  d016              BEQ      |L2.62|
;;;182    
;;;183    	vTaskSuspendAll();
000010  f7fffffe          BL       vTaskSuspendAll
;;;184    	{
;;;185    		/* Check the requested block size is not so large that the top bit is
;;;186    		set.  The top bit of the block size member of the BlockLink_t structure
;;;187    		is used to determine who owns the block - the application or the
;;;188    		kernel, so it must be free. */
;;;189    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000014  68f8              LDR      r0,[r7,#0xc]  ; xBlockAllocatedBit
000016  4205              TST      r5,r0
000018  d13e              BNE      |L2.152|
;;;190    		{
;;;191    			/* The wanted size is increased so it can contain a BlockLink_t
;;;192    			structure in addition to the requested amount of bytes. */
;;;193    			if( xWantedSize > 0 )
00001a  b13d              CBZ      r5,|L2.44|
;;;194    			{
;;;195    				xWantedSize += xHeapStructSize;
00001c  3508              ADDS     r5,r5,#8
;;;196    
;;;197    				/* Ensure that blocks are always aligned to the required number
;;;198    				of bytes. */
;;;199    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
00001e  0768              LSLS     r0,r5,#29
000020  d004              BEQ      |L2.44|
;;;200    				{
;;;201    					/* Byte alignment required. */
;;;202    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000022  f0050007          AND      r0,r5,#7
000026  f1c00008          RSB      r0,r0,#8
00002a  4405              ADD      r5,r5,r0
                  |L2.44|
;;;203    				}
;;;204    				else
;;;205    				{
;;;206    					mtCOVERAGE_TEST_MARKER();
;;;207    				}
;;;208    			}
;;;209    			else
;;;210    			{
;;;211    				mtCOVERAGE_TEST_MARKER();
;;;212    			}
;;;213    
;;;214    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
00002c  b3a5              CBZ      r5,|L2.152|
00002e  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
000030  4285              CMP      r5,r0
000032  d831              BHI      |L2.152|
;;;215    			{
;;;216    				/* Traverse the list from the start	(lowest address) block until
;;;217    				one	of adequate size is found. */
;;;218    				pxPreviousBlock = &xStart;
000034  491b              LDR      r1,|L2.164|
000036  3110              ADDS     r1,r1,#0x10
;;;219    				pxBlock = xStart.pxNextFreeBlock;
000038  4608              MOV      r0,r1
00003a  6804              LDR      r4,[r0,#0]  ; xStart
;;;220    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
00003c  e009              B        |L2.82|
                  |L2.62|
00003e  20a0              MOVS     r0,#0xa0
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L2.76|
00004c  e7fe              B        |L2.76|
                  |L2.78|
;;;221    				{
;;;222    					pxPreviousBlock = pxBlock;
00004e  4621              MOV      r1,r4
;;;223    					pxBlock = pxBlock->pxNextFreeBlock;
000050  4604              MOV      r4,r0
                  |L2.82|
000052  6860              LDR      r0,[r4,#4]            ;220
000054  42a8              CMP      r0,r5                 ;220
000056  d202              BCS      |L2.94|
000058  6820              LDR      r0,[r4,#0]            ;220
00005a  2800              CMP      r0,#0                 ;220
00005c  d1f7              BNE      |L2.78|
                  |L2.94|
;;;224    				}
;;;225    
;;;226    				/* If the end marker was reached then a block of adequate size
;;;227    				was	not found. */
;;;228    				if( pxBlock != pxEnd )
00005e  6838              LDR      r0,[r7,#0]  ; pxEnd
000060  4284              CMP      r4,r0
000062  d019              BEQ      |L2.152|
;;;229    				{
;;;230    					/* Return the memory space pointed to - jumping over the
;;;231    					BlockLink_t structure at its start. */
;;;232    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
000064  680e              LDR      r6,[r1,#0]
000066  3608              ADDS     r6,r6,#8
;;;233    
;;;234    					/* This block is being returned for use so must be taken out
;;;235    					of the list of free blocks. */
;;;236    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
000068  6820              LDR      r0,[r4,#0]
00006a  6008              STR      r0,[r1,#0]
;;;237    
;;;238    					/* If the block is larger than required it can be split into
;;;239    					two. */
;;;240    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
00006c  6860              LDR      r0,[r4,#4]
00006e  1b41              SUBS     r1,r0,r5
000070  2910              CMP      r1,#0x10
000072  d904              BLS      |L2.126|
;;;241    					{
;;;242    						/* This block is to be split into two.  Create a new
;;;243    						block following the number of bytes requested. The void
;;;244    						cast is used to prevent byte alignment warnings from the
;;;245    						compiler. */
;;;246    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
000074  1960              ADDS     r0,r4,r5
;;;247    
;;;248    						/* Calculate the sizes of two blocks split from the
;;;249    						single block. */
;;;250    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
000076  6041              STR      r1,[r0,#4]
;;;251    						pxBlock->xBlockSize = xWantedSize;
000078  6065              STR      r5,[r4,#4]
;;;252    
;;;253    						/* Insert the new block into the list of free blocks. */
;;;254    						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
00007a  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L2.126|
;;;255    					}
;;;256    					else
;;;257    					{
;;;258    						mtCOVERAGE_TEST_MARKER();
;;;259    					}
;;;260    
;;;261    					xFreeBytesRemaining -= pxBlock->xBlockSize;
00007e  6861              LDR      r1,[r4,#4]
000080  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
000082  1a40              SUBS     r0,r0,r1
000084  6078              STR      r0,[r7,#4]  ; xFreeBytesRemaining
;;;262    
;;;263    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
000086  68ba              LDR      r2,[r7,#8]  ; xMinimumEverFreeBytesRemaining
000088  4290              CMP      r0,r2
00008a  d200              BCS      |L2.142|
;;;264    					{
;;;265    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
00008c  60b8              STR      r0,[r7,#8]  ; xMinimumEverFreeBytesRemaining
                  |L2.142|
;;;266    					}
;;;267    					else
;;;268    					{
;;;269    						mtCOVERAGE_TEST_MARKER();
;;;270    					}
;;;271    
;;;272    					/* The block is being returned - it is allocated and owned
;;;273    					by the application and has no "next" block. */
;;;274    					pxBlock->xBlockSize |= xBlockAllocatedBit;
00008e  68f8              LDR      r0,[r7,#0xc]  ; xBlockAllocatedBit
000090  4301              ORRS     r1,r1,r0
000092  6061              STR      r1,[r4,#4]
;;;275    					pxBlock->pxNextFreeBlock = NULL;
000094  2000              MOVS     r0,#0
000096  6020              STR      r0,[r4,#0]
                  |L2.152|
;;;276    				}
;;;277    				else
;;;278    				{
;;;279    					mtCOVERAGE_TEST_MARKER();
;;;280    				}
;;;281    			}
;;;282    			else
;;;283    			{
;;;284    				mtCOVERAGE_TEST_MARKER();
;;;285    			}
;;;286    		}
;;;287    		else
;;;288    		{
;;;289    			mtCOVERAGE_TEST_MARKER();
;;;290    		}
;;;291    
;;;292    		traceMALLOC( pvReturn, xWantedSize );
;;;293    	}
;;;294    	( void ) xTaskResumeAll();
000098  f7fffffe          BL       xTaskResumeAll
;;;295    
;;;296    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;297    	{
;;;298    		if( pvReturn == NULL )
;;;299    		{
;;;300    			extern void vApplicationMallocFailedHook( void );
;;;301    			vApplicationMallocFailedHook();
;;;302    		}
;;;303    		else
;;;304    		{
;;;305    			mtCOVERAGE_TEST_MARKER();
;;;306    		}
;;;307    	}
;;;308    	#endif
;;;309    
;;;310    	return pvReturn;
00009c  4630              MOV      r0,r6
;;;311    }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;312    /*-----------------------------------------------------------*/
                          ENDP

0000a2  0000              DCW      0x0000
                  |L2.164|
                          DCD      ||.data||

                          AREA ||i.vPortDefineHeapRegions||, CODE, READONLY, ALIGN=2

                  vPortDefineHeapRegions PROC
;;;434    
;;;435    void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )
000000  b5f0              PUSH     {r4-r7,lr}
;;;436    {
;;;437    BlockLink_t *pxFirstFreeBlockInRegion = NULL, *pxPreviousFreeBlock;
;;;438    size_t xAlignedHeap;
;;;439    size_t xTotalRegionSize, xTotalHeapSize = 0;
000002  2400              MOVS     r4,#0
;;;440    BaseType_t xDefinedRegions = 0;
000004  2200              MOVS     r2,#0
;;;441    size_t xAddress;
;;;442    const HeapRegion_t *pxHeapRegion;
;;;443    
;;;444    	/* Can only call once! */
;;;445    	configASSERT( pxEnd == NULL );
000006  4f2c              LDR      r7,|L3.184|
000008  6839              LDR      r1,[r7,#0]  ; pxEnd
00000a  2900              CMP      r1,#0
00000c  d007              BEQ      |L3.30|
00000e  20a0              MOVS     r0,#0xa0              ;436
000010  f3808811          MSR      BASEPRI,r0            ;436
000014  f3bf8f4f          DSB                            ;436
000018  f3bf8f6f          ISB                            ;436
                  |L3.28|
00001c  e7fe              B        |L3.28|
                  |L3.30|
;;;446    
;;;447    	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
00001e  4605              MOV      r5,r0
;;;448    
;;;449    	while( pxHeapRegion->xSizeInBytes > 0 )
000020  f04f0c00          MOV      r12,#0
000024  e02e              B        |L3.132|
                  |L3.38|
;;;450    	{
;;;451    		xTotalRegionSize = pxHeapRegion->xSizeInBytes;
;;;452    
;;;453    		/* Ensure the heap region starts on a correctly aligned boundary. */
;;;454    		xAddress = ( size_t ) pxHeapRegion->pucStartAddress;
000026  6829              LDR      r1,[r5,#0]
000028  460d              MOV      r5,r1
;;;455    		if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
00002a  074e              LSLS     r6,r1,#29
00002c  d004              BEQ      |L3.56|
;;;456    		{
;;;457    			xAddress += ( portBYTE_ALIGNMENT - 1 );
00002e  1dc9              ADDS     r1,r1,#7
;;;458    			xAddress &= ~portBYTE_ALIGNMENT_MASK;
000030  f0210107          BIC      r1,r1,#7
;;;459    
;;;460    			/* Adjust the size for the bytes lost to alignment. */
;;;461    			xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;
000034  1b4d              SUBS     r5,r1,r5
000036  1b5b              SUBS     r3,r3,r5
                  |L3.56|
;;;462    		}
;;;463    
;;;464    		xAlignedHeap = xAddress;
;;;465    
;;;466    		/* Set xStart if it has not already been set. */
;;;467    		if( xDefinedRegions == 0 )
000038  b15a              CBZ      r2,|L3.82|
;;;468    		{
;;;469    			/* xStart is used to hold a pointer to the first item in the list of
;;;470    			free blocks.  The void cast is used to prevent compiler warnings. */
;;;471    			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
;;;472    			xStart.xBlockSize = ( size_t ) 0;
;;;473    		}
;;;474    		else
;;;475    		{
;;;476    			/* Should only get here if one region has already been added to the
;;;477    			heap. */
;;;478    			configASSERT( pxEnd != NULL );
00003a  683d              LDR      r5,[r7,#0]  ; pxEnd
00003c  b365              CBZ      r5,|L3.152|
;;;479    
;;;480    			/* Check blocks are passed in with increasing start addresses. */
;;;481    			configASSERT( xAddress > ( size_t ) pxEnd );
00003e  42a9              CMP      r1,r5
000040  d80c              BHI      |L3.92|
000042  20a0              MOVS     r0,#0xa0
000044  f3808811          MSR      BASEPRI,r0
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
                  |L3.80|
000050  e7fe              B        |L3.80|
                  |L3.82|
000052  4d19              LDR      r5,|L3.184|
000054  3510              ADDS     r5,r5,#0x10           ;471
000056  6029              STR      r1,[r5,#0]            ;471  ; xStart
000058  f8c5c004          STR      r12,[r5,#4]           ;472  ; xStart
                  |L3.92|
;;;482    		}
;;;483    
;;;484    		/* Remember the location of the end marker in the previous region, if
;;;485    		any. */
;;;486    		pxPreviousFreeBlock = pxEnd;
00005c  683e              LDR      r6,[r7,#0]  ; pxEnd
;;;487    
;;;488    		/* pxEnd is used to mark the end of the list of free blocks and is
;;;489    		inserted at the end of the region space. */
;;;490    		xAddress = xAlignedHeap + xTotalRegionSize;
00005e  440b              ADD      r3,r3,r1
;;;491    		xAddress -= xHeapStructSize;
000060  3b08              SUBS     r3,r3,#8
;;;492    		xAddress &= ~portBYTE_ALIGNMENT_MASK;
000062  f0230307          BIC      r3,r3,#7
;;;493    		pxEnd = ( BlockLink_t * ) xAddress;
000066  603b              STR      r3,[r7,#0]  ; pxEnd
;;;494    		pxEnd->xBlockSize = 0;
000068  f8c3c004          STR      r12,[r3,#4]
;;;495    		pxEnd->pxNextFreeBlock = NULL;
00006c  f8c3c000          STR      r12,[r3,#0]
;;;496    
;;;497    		/* To start with there is a single free block in this region that is
;;;498    		sized to take up the entire heap region minus the space taken by the
;;;499    		free block structure. */
;;;500    		pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;
;;;501    		pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;
000070  1a5d              SUBS     r5,r3,r1
000072  604d              STR      r5,[r1,#4]
;;;502    		pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;
000074  600b              STR      r3,[r1,#0]
;;;503    
;;;504    		/* If this is not the first region that makes up the entire heap space
;;;505    		then link the previous region to this region. */
;;;506    		if( pxPreviousFreeBlock != NULL )
000076  b106              CBZ      r6,|L3.122|
;;;507    		{
;;;508    			pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;
000078  6031              STR      r1,[r6,#0]
                  |L3.122|
;;;509    		}
;;;510    
;;;511    		xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;
00007a  6849              LDR      r1,[r1,#4]
00007c  440c              ADD      r4,r4,r1
;;;512    
;;;513    		/* Move onto the next HeapRegion_t structure. */
;;;514    		xDefinedRegions++;
00007e  1c52              ADDS     r2,r2,#1
;;;515    		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
000080  eb0005c2          ADD      r5,r0,r2,LSL #3
                  |L3.132|
000084  686b              LDR      r3,[r5,#4]            ;449
000086  2b00              CMP      r3,#0                 ;449
000088  d1cd              BNE      |L3.38|
;;;516    	}
;;;517    
;;;518    	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
00008a  60bc              STR      r4,[r7,#8]  ; xMinimumEverFreeBytesRemaining
;;;519    	xFreeBytesRemaining = xTotalHeapSize;
00008c  607c              STR      r4,[r7,#4]  ; xFreeBytesRemaining
;;;520    
;;;521    	/* Check something was actually defined before it is accessed. */
;;;522    	configASSERT( xTotalHeapSize );
00008e  b15c              CBZ      r4,|L3.168|
;;;523    
;;;524    	/* Work out the position of the top bit in a size_t variable. */
;;;525    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
000090  f04f4000          MOV      r0,#0x80000000
000094  60f8              STR      r0,[r7,#0xc]  ; xBlockAllocatedBit
;;;526    }
000096  bdf0              POP      {r4-r7,pc}
                  |L3.152|
000098  20a0              MOVS     r0,#0xa0
00009a  f3808811          MSR      BASEPRI,r0
00009e  f3bf8f4f          DSB      
0000a2  f3bf8f6f          ISB      
                  |L3.166|
0000a6  e7fe              B        |L3.166|
                  |L3.168|
0000a8  20a0              MOVS     r0,#0xa0              ;478
0000aa  f3808811          MSR      BASEPRI,r0            ;478
0000ae  f3bf8f4f          DSB                            ;478
0000b2  f3bf8f6f          ISB                            ;478
                  |L3.182|
0000b6  e7fe              B        |L3.182|
;;;527    
                          ENDP

                  |L3.184|
                          DCD      ||.data||

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;313    
;;;314    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
;;;316    uint8_t *puc = ( uint8_t * ) pv;
;;;317    BlockLink_t *pxLink;
;;;318    
;;;319    	if( pv != NULL )
000002  2800              CMP      r0,#0
000004  d027              BEQ      |L4.86|
;;;320    	{
;;;321    		/* The memory being freed will have an BlockLink_t structure immediately
;;;322    		before it. */
;;;323    		puc -= xHeapStructSize;
000006  3808              SUBS     r0,r0,#8
;;;324    
;;;325    		/* This casting is to keep the compiler from issuing warnings. */
;;;326    		pxLink = ( void * ) puc;
000008  4604              MOV      r4,r0
;;;327    
;;;328    		/* Check the block is actually allocated. */
;;;329    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
00000a  4d13              LDR      r5,|L4.88|
00000c  6860              LDR      r0,[r4,#4]
00000e  68e9              LDR      r1,[r5,#0xc]  ; xBlockAllocatedBit
000010  4208              TST      r0,r1
000012  d107              BNE      |L4.36|
000014  20a0              MOVS     r0,#0xa0
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L4.34|
000022  e7fe              B        |L4.34|
                  |L4.36|
;;;330    		configASSERT( pxLink->pxNextFreeBlock == NULL );
000024  6822              LDR      r2,[r4,#0]
000026  b13a              CBZ      r2,|L4.56|
000028  20a0              MOVS     r0,#0xa0
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L4.54|
000036  e7fe              B        |L4.54|
                  |L4.56|
;;;331    
;;;332    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
;;;333    		{
;;;334    			if( pxLink->pxNextFreeBlock == NULL )
;;;335    			{
;;;336    				/* The block is being returned to the heap - it is no longer
;;;337    				allocated. */
;;;338    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
000038  4388              BICS     r0,r0,r1
00003a  6060              STR      r0,[r4,#4]
;;;339    
;;;340    				vTaskSuspendAll();
00003c  f7fffffe          BL       vTaskSuspendAll
;;;341    				{
;;;342    					/* Add this block to the list of free blocks. */
;;;343    					xFreeBytesRemaining += pxLink->xBlockSize;
000040  6860              LDR      r0,[r4,#4]
000042  6869              LDR      r1,[r5,#4]  ; xFreeBytesRemaining
000044  4408              ADD      r0,r0,r1
000046  6068              STR      r0,[r5,#4]  ; xFreeBytesRemaining
;;;344    					traceFREE( pv, pxLink->xBlockSize );
;;;345    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;346    				}
;;;347    				( void ) xTaskResumeAll();
00004e  e8bd4070          POP      {r4-r6,lr}
000052  f7ffbffe          B.W      xTaskResumeAll
                  |L4.86|
;;;348    			}
;;;349    			else
;;;350    			{
;;;351    				mtCOVERAGE_TEST_MARKER();
;;;352    			}
;;;353    		}
;;;354    		else
;;;355    		{
;;;356    			mtCOVERAGE_TEST_MARKER();
;;;357    		}
;;;358    	}
;;;359    }
000056  bd70              POP      {r4-r6,pc}
;;;360    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.88|
                          DCD      ||.data||

                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;361    
;;;362    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L5.8|
;;;363    {
;;;364    	return xFreeBytesRemaining;
000002  6840              LDR      r0,[r0,#4]  ; xFreeBytesRemaining
;;;365    }
000004  4770              BX       lr
;;;366    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;367    
;;;368    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L6.8|
;;;369    {
;;;370    	return xMinimumEverFreeBytesRemaining;
000002  6880              LDR      r0,[r0,#8]  ; xMinimumEverFreeBytesRemaining
;;;371    }
000004  4770              BX       lr
;;;372    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
                  xStart
                          %        8
